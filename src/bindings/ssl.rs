/* automatically generated by rust-bindgen 0.71.1 */

pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const BIGINT_M_OFFSET: u32 = 0;
pub const BIGINT_NUM_MODS: u32 = 1;
pub const COMP_RADIX: u64 = 4294967296;
pub const COMP_MAX: i32 = -1;
pub const COMP_BIT_SIZE: u32 = 32;
pub const COMP_BYTE_SIZE: u32 = 4;
pub const COMP_NUM_NIBBLES: u32 = 8;
pub const PERMANENT: u32 = 2147440042;
pub const HAVE_DOT_CONFIG: u32 = 1;
pub const CONFIG_PLATFORM_CYGWIN: u32 = 1;
pub const PREFIX: &[u8; 11] = b"/usr/local\0";
pub const CONFIG_DEBUG: u32 = 1;
pub const CONFIG_VISUAL_STUDIO_7_0_BASE: &[u8; 1] = b"\0";
pub const CONFIG_VISUAL_STUDIO_8_0_BASE: &[u8; 1] = b"\0";
pub const CONFIG_VISUAL_STUDIO_10_0_BASE: &[u8; 1] = b"\0";
pub const CONFIG_EXTRA_CFLAGS_OPTIONS: &[u8; 1] = b"\0";
pub const CONFIG_EXTRA_LDFLAGS_OPTIONS: &[u8; 1] = b"\0";
pub const CONFIG_SSL_FULL_MODE: u32 = 1;
pub const CONFIG_SSL_PROT_MEDIUM: u32 = 1;
pub const CONFIG_SSL_PRIVATE_KEY_LOCATION: &[u8; 1] = b"\0";
pub const CONFIG_SSL_PRIVATE_KEY_PASSWORD: &[u8; 1] = b"\0";
pub const CONFIG_SSL_X509_CERT_LOCATION: &[u8; 1] = b"\0";
pub const CONFIG_SSL_X509_COMMON_NAME: &[u8; 1] = b"\0";
pub const CONFIG_SSL_X509_ORGANIZATION_NAME: &[u8; 1] = b"\0";
pub const CONFIG_SSL_X509_ORGANIZATION_UNIT_NAME: &[u8; 1] = b"\0";
pub const CONFIG_SSL_HAS_PEM: u32 = 1;
pub const CONFIG_SSL_EXPIRY_TIME: u32 = 24;
pub const CONFIG_X509_MAX_CA_CERTS: u32 = 3;
pub const CONFIG_SSL_MAX_CERTS: u32 = 3;
pub const CONFIG_USE_DEV_URANDOM: u32 = 1;
pub const CONFIG_SSL_TEST: u32 = 1;
pub const CONFIG_AXHTTPD: u32 = 1;
pub const CONFIG_SSL_DISPLAY_MODE: u32 = 1;
pub const CONFIG_HTTP_PORT: u32 = 80;
pub const CONFIG_HTTP_HTTPS_PORT: u32 = 443;
pub const CONFIG_HTTP_SESSION_CACHE_SIZE: u32 = 5;
pub const CONFIG_HTTP_WEBROOT: &[u8; 7] = b"../www\0";
pub const CONFIG_HTTP_TIMEOUT: u32 = 300;
pub const CONFIG_HTTP_CGI_EXTENSIONS: &[u8; 14] = b".lua,.lp,.php\0";
pub const CONFIG_HTTP_ENABLE_LUA: u32 = 1;
pub const CONFIG_HTTP_LUA_PREFIX: &[u8; 5] = b"/usr\0";
pub const CONFIG_HTTP_CGI_LAUNCHER: &[u8; 13] = b"/usr/bin/cgi\0";
pub const CONFIG_HTTP_DIRECTORIES: u32 = 1;
pub const CONFIG_HTTP_HAS_AUTHORIZATION: u32 = 1;
pub const CONFIG_HTTP_USER: &[u8; 1] = b"\0";
pub const CONFIG_HTTP_VERBOSE: u32 = 0;
pub const CONFIG_DOT_NET_FRAMEWORK_BASE: &[u8; 1] = b"\0";
pub const CONFIG_JAVA_HOME: &[u8; 1] = b"\0";
pub const CONFIG_PERL_CORE: &[u8; 1] = b"\0";
pub const CONFIG_PERL_LIB: &[u8; 1] = b"\0";
pub const CONFIG_LUA_CORE: &[u8; 1] = b"\0";
pub const CONFIG_SAMPLES: u32 = 1;
pub const CONFIG_C_SAMPLES: u32 = 1;
pub const CONFIG_BIGINT_BARRETT: u32 = 1;
pub const CONFIG_BIGINT_CRT: u32 = 1;
pub const CONFIG_BIGINT_SLIDING_WINDOW: u32 = 1;
pub const CONFIG_BIGINT_SQUARE: u32 = 1;
pub const CONFIG_BIGINT_CHECK_ON: u32 = 1;
pub const CONFIG_INTEGER_32BIT: u32 = 1;
pub const AES_MAXROUNDS: u32 = 14;
pub const AES_BLOCKSIZE: u32 = 16;
pub const AES_IV_SIZE: u32 = 16;
pub const SHA1_SIZE: u32 = 20;
pub const SHA256_SIZE: u32 = 32;
pub const SHA512_SIZE: u32 = 64;
pub const SHA384_SIZE: u32 = 48;
pub const MD5_SIZE: u32 = 16;
pub const _STRING_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC23: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_TIME_BITS64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C23_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 40;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const BIT31: u32 = 2147483648;
pub const BIT30: u32 = 1073741824;
pub const BIT29: u32 = 536870912;
pub const BIT28: u32 = 268435456;
pub const BIT27: u32 = 134217728;
pub const BIT26: u32 = 67108864;
pub const BIT25: u32 = 33554432;
pub const BIT24: u32 = 16777216;
pub const BIT23: u32 = 8388608;
pub const BIT22: u32 = 4194304;
pub const BIT21: u32 = 2097152;
pub const BIT20: u32 = 1048576;
pub const BIT19: u32 = 524288;
pub const BIT18: u32 = 262144;
pub const BIT17: u32 = 131072;
pub const BIT16: u32 = 65536;
pub const BIT15: u32 = 32768;
pub const BIT14: u32 = 16384;
pub const BIT13: u32 = 8192;
pub const BIT12: u32 = 4096;
pub const BIT11: u32 = 2048;
pub const BIT10: u32 = 1024;
pub const BIT9: u32 = 512;
pub const BIT8: u32 = 256;
pub const BIT7: u32 = 128;
pub const BIT6: u32 = 64;
pub const BIT5: u32 = 32;
pub const BIT4: u32 = 16;
pub const BIT3: u32 = 8;
pub const BIT2: u32 = 4;
pub const BIT1: u32 = 2;
pub const BIT0: u32 = 1;
pub const APB_CLK_FREQ: u32 = 80000000;
pub const UART_CLK_FREQ: u32 = 80000000;
pub const TIMER_CLK_FREQ: u32 = 312500;
pub const PERIPHS_DPORT_BASEADDR: u32 = 1072693248;
pub const PERIPHS_GPIO_BASEADDR: u32 = 1610613504;
pub const PERIPHS_TIMER_BASEDDR: u32 = 1610614272;
pub const PERIPHS_RTC_BASEADDR: u32 = 1610614528;
pub const PERIPHS_IO_MUX: u32 = 1610614784;
pub const EDGE_INT_ENABLE_REG: u32 = 1072693252;
pub const GPIO_OUT_ADDRESS: u32 = 0;
pub const GPIO_OUT_W1TS_ADDRESS: u32 = 4;
pub const GPIO_OUT_W1TC_ADDRESS: u32 = 8;
pub const GPIO_ENABLE_ADDRESS: u32 = 12;
pub const GPIO_ENABLE_W1TS_ADDRESS: u32 = 16;
pub const GPIO_ENABLE_W1TC_ADDRESS: u32 = 20;
pub const GPIO_OUT_W1TC_DATA_MASK: u32 = 65535;
pub const GPIO_IN_ADDRESS: u32 = 24;
pub const GPIO_STATUS_ADDRESS: u32 = 28;
pub const GPIO_STATUS_W1TS_ADDRESS: u32 = 32;
pub const GPIO_STATUS_W1TC_ADDRESS: u32 = 36;
pub const GPIO_STATUS_INTERRUPT_MASK: u32 = 65535;
pub const GPIO_RTC_CALIB_SYNC: u32 = 1610613612;
pub const RTC_CALIB_START: u32 = 2147483648;
pub const RTC_PERIOD_NUM_MASK: u32 = 1023;
pub const GPIO_RTC_CALIB_VALUE: u32 = 1610613616;
pub const RTC_CALIB_RDY_S: u32 = 31;
pub const RTC_CALIB_VALUE_MASK: u32 = 1048575;
pub const GPIO_PIN0_ADDRESS: u32 = 40;
pub const GPIO_ID_PIN0: u32 = 0;
pub const GPIO_ID_NONE: u32 = 4294967295;
pub const GPIO_PIN_COUNT: u32 = 16;
pub const GPIO_PIN_CONFIG_MSB: u32 = 12;
pub const GPIO_PIN_CONFIG_LSB: u32 = 11;
pub const GPIO_PIN_CONFIG_MASK: u32 = 6144;
pub const GPIO_WAKEUP_ENABLE: u32 = 1;
pub const GPIO_WAKEUP_DISABLE: i32 = -2;
pub const GPIO_PIN_WAKEUP_ENABLE_MSB: u32 = 10;
pub const GPIO_PIN_WAKEUP_ENABLE_LSB: u32 = 10;
pub const GPIO_PIN_WAKEUP_ENABLE_MASK: u32 = 1024;
pub const GPIO_PIN_INT_TYPE_MASK: u32 = 896;
pub const GPIO_PIN_INT_TYPE_MSB: u32 = 9;
pub const GPIO_PIN_INT_TYPE_LSB: u32 = 7;
pub const GPIO_PAD_DRIVER_ENABLE: u32 = 1;
pub const GPIO_PAD_DRIVER_DISABLE: i32 = -2;
pub const GPIO_PIN_PAD_DRIVER_MSB: u32 = 2;
pub const GPIO_PIN_PAD_DRIVER_LSB: u32 = 2;
pub const GPIO_PIN_PAD_DRIVER_MASK: u32 = 4;
pub const GPIO_AS_PIN_SOURCE: u32 = 0;
pub const SIGMA_AS_PIN_SOURCE: i32 = -1;
pub const GPIO_PIN_SOURCE_MSB: u32 = 0;
pub const GPIO_PIN_SOURCE_LSB: u32 = 0;
pub const GPIO_PIN_SOURCE_MASK: u32 = 1;
pub const FRC1_LOAD_ADDRESS: u32 = 0;
pub const FRC1_COUNT_ADDRESS: u32 = 4;
pub const FRC1_CTRL_ADDRESS: u32 = 8;
pub const FRC1_INT_ADDRESS: u32 = 12;
pub const FRC1_INT_CLR_MASK: u32 = 1;
pub const FRC2_COUNT_ADDRESS: u32 = 36;
pub const REG_RTC_BASE: u32 = 1610614528;
pub const RTC_STORE0: u32 = 1610614576;
pub const RTC_STORE1: u32 = 1610614580;
pub const RTC_STORE2: u32 = 1610614584;
pub const RTC_STORE3: u32 = 1610614588;
pub const RTC_GPIO_OUT: u32 = 1610614632;
pub const RTC_GPIO_ENABLE: u32 = 1610614644;
pub const RTC_GPIO_IN_DATA: u32 = 1610614668;
pub const RTC_GPIO_CONF: u32 = 1610614672;
pub const PAD_XPD_DCDC_CONF: u32 = 1610614688;
pub const PERIPHS_IO_MUX_FUNC: u32 = 19;
pub const PERIPHS_IO_MUX_FUNC_S: u32 = 4;
pub const PERIPHS_IO_MUX_PULLUP: u32 = 128;
pub const PERIPHS_IO_MUX_PULLUP2: u32 = 64;
pub const PERIPHS_IO_MUX_SLEEP_PULLUP: u32 = 8;
pub const PERIPHS_IO_MUX_SLEEP_PULLUP2: u32 = 4;
pub const PERIPHS_IO_MUX_SLEEP_OE: u32 = 2;
pub const PERIPHS_IO_MUX_OE: u32 = 1;
pub const PERIPHS_IO_MUX_CONF_U: u32 = 1610614784;
pub const SPI0_CLK_EQU_SYS_CLK: u32 = 256;
pub const SPI1_CLK_EQU_SYS_CLK: u32 = 512;
pub const PERIPHS_IO_MUX_MTDI_U: u32 = 1610614788;
pub const FUNC_GPIO12: u32 = 3;
pub const PERIPHS_IO_MUX_MTCK_U: u32 = 1610614792;
pub const FUNC_GPIO13: u32 = 3;
pub const PERIPHS_IO_MUX_MTMS_U: u32 = 1610614796;
pub const FUNC_GPIO14: u32 = 3;
pub const PERIPHS_IO_MUX_MTDO_U: u32 = 1610614800;
pub const FUNC_GPIO15: u32 = 3;
pub const FUNC_U0RTS: u32 = 4;
pub const PERIPHS_IO_MUX_U0RXD_U: u32 = 1610614804;
pub const FUNC_GPIO3: u32 = 3;
pub const PERIPHS_IO_MUX_U0TXD_U: u32 = 1610614808;
pub const FUNC_U0TXD: u32 = 0;
pub const FUNC_GPIO1: u32 = 3;
pub const PERIPHS_IO_MUX_SD_CLK_U: u32 = 1610614812;
pub const FUNC_SDCLK: u32 = 0;
pub const FUNC_SPICLK: u32 = 1;
pub const PERIPHS_IO_MUX_SD_DATA0_U: u32 = 1610614816;
pub const FUNC_SDDATA0: u32 = 0;
pub const FUNC_SPIQ: u32 = 1;
pub const FUNC_U1TXD: u32 = 4;
pub const PERIPHS_IO_MUX_SD_DATA1_U: u32 = 1610614820;
pub const FUNC_SDDATA1: u32 = 0;
pub const FUNC_SPID: u32 = 1;
pub const FUNC_U1RXD: u32 = 4;
pub const FUNC_SDDATA1_U1RXD: u32 = 7;
pub const PERIPHS_IO_MUX_SD_DATA2_U: u32 = 1610614824;
pub const FUNC_SDDATA2: u32 = 0;
pub const FUNC_SPIHD: u32 = 1;
pub const FUNC_GPIO9: u32 = 3;
pub const PERIPHS_IO_MUX_SD_DATA3_U: u32 = 1610614828;
pub const FUNC_SDDATA3: u32 = 0;
pub const FUNC_SPIWP: u32 = 1;
pub const FUNC_GPIO10: u32 = 3;
pub const PERIPHS_IO_MUX_SD_CMD_U: u32 = 1610614832;
pub const FUNC_SDCMD: u32 = 0;
pub const FUNC_SPICS0: u32 = 1;
pub const PERIPHS_IO_MUX_GPIO0_U: u32 = 1610614836;
pub const FUNC_GPIO0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO2_U: u32 = 1610614840;
pub const FUNC_GPIO2: u32 = 0;
pub const FUNC_U1TXD_BK: u32 = 2;
pub const FUNC_U0TXD_BK: u32 = 4;
pub const PERIPHS_IO_MUX_GPIO4_U: u32 = 1610614844;
pub const FUNC_GPIO4: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO5_U: u32 = 1610614848;
pub const FUNC_GPIO5: u32 = 0;
pub const ETS_SDIO_INUM: u32 = 1;
pub const ETS_SPI_INUM: u32 = 2;
pub const ETS_GPIO_INUM: u32 = 4;
pub const ETS_UART_INUM: u32 = 5;
pub const ETS_UART1_INUM: u32 = 5;
pub const ETS_FRC_TIMER1_INUM: u32 = 9;
pub const ESP_SYSTEM_APP: u32 = 1;
pub const SYS_LIGHTWEIGHT_PROT: u32 = 0;
pub const NO_SYS: u32 = 1;
pub const NO_SYS_NO_TIMERS: u32 = 0;
pub const MEM_LIBC_MALLOC: u32 = 1;
pub const MEMP_MEM_MALLOC: u32 = 1;
pub const MEM_ALIGNMENT: u32 = 4;
pub const MEM_SIZE: u32 = 16000;
pub const MEMP_SEPARATE_POOLS: u32 = 1;
pub const MEMP_OVERFLOW_CHECK: u32 = 0;
pub const MEMP_SANITY_CHECK: u32 = 1;
pub const MEM_USE_POOLS: u32 = 0;
pub const MEM_USE_POOLS_TRY_BIGGER_POOL: u32 = 0;
pub const MEMP_USE_CUSTOM_POOLS: u32 = 0;
pub const LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT: u32 = 0;
pub const MEMP_NUM_PBUF: u32 = 10;
pub const MEMP_NUM_RAW_PCB: u32 = 4;
pub const MEMP_NUM_UDP_PCB: u32 = 4;
pub const MEMP_NUM_TCP_PCB_LISTEN: u32 = 2;
pub const MEMP_NUM_TCP_SEG: u32 = 16;
pub const MEMP_NUM_REASSDATA: u32 = 0;
pub const MEMP_NUM_FRAG_PBUF: u32 = 0;
pub const MEMP_NUM_ARP_QUEUE: u32 = 10;
pub const MEMP_NUM_IGMP_GROUP: u32 = 8;
pub const MEMP_NUM_SYS_TIMEOUT: u32 = 8;
pub const MEMP_NUM_NETBUF: u32 = 0;
pub const MEMP_NUM_NETCONN: u32 = 0;
pub const MEMP_NUM_TCPIP_MSG_API: u32 = 4;
pub const MEMP_NUM_TCPIP_MSG_INPKT: u32 = 4;
pub const MEMP_NUM_SNMP_NODE: u32 = 0;
pub const MEMP_NUM_SNMP_ROOTNODE: u32 = 0;
pub const MEMP_NUM_SNMP_VARBIND: u32 = 0;
pub const MEMP_NUM_SNMP_VALUE: u32 = 0;
pub const MEMP_NUM_NETDB: u32 = 0;
pub const MEMP_NUM_LOCALHOSTLIST: u32 = 0;
pub const MEMP_NUM_PPPOE_INTERFACES: u32 = 0;
pub const PBUF_POOL_SIZE: u32 = 10;
pub const LWIP_ARP: u32 = 1;
pub const ARP_TABLE_SIZE: u32 = 10;
pub const ARP_QUEUEING: u32 = 1;
pub const ETHARP_TRUST_IP_MAC: u32 = 0;
pub const ETHARP_SUPPORT_VLAN: u32 = 0;
pub const ETH_PAD_SIZE: u32 = 0;
pub const ETHARP_SUPPORT_STATIC_ENTRIES: u32 = 0;
pub const IP_FORWARD: u32 = 0;
pub const IP_OPTIONS_ALLOWED: u32 = 1;
pub const IP_REASSEMBLY: u32 = 0;
pub const IP_FRAG: u32 = 0;
pub const IP_REASS_MAXAGE: u32 = 3;
pub const IP_REASS_MAX_PBUFS: u32 = 10;
pub const IP_FRAG_USES_STATIC_BUF: u32 = 1;
pub const IP_FRAG_MAX_MTU: u32 = 1500;
pub const IP_DEFAULT_TTL: u32 = 128;
pub const IP_SOF_BROADCAST: u32 = 0;
pub const IP_SOF_BROADCAST_RECV: u32 = 0;
pub const LWIP_ICMP: u32 = 1;
pub const ICMP_TTL: u32 = 128;
pub const LWIP_BROADCAST_PING: u32 = 0;
pub const LWIP_MULTICAST_PING: u32 = 0;
pub const LWIP_RAW: u32 = 1;
pub const RAW_TTL: u32 = 128;
pub const LWIP_DHCP: u32 = 1;
pub const LWIP_AUTOIP: u32 = 0;
pub const LWIP_DHCP_AUTOIP_COOP: u32 = 0;
pub const LWIP_DHCP_AUTOIP_COOP_TRIES: u32 = 9;
pub const LWIP_SNMP: u32 = 0;
pub const SNMP_CONCURRENT_REQUESTS: u32 = 0;
pub const SNMP_TRAP_DESTINATIONS: u32 = 0;
pub const SNMP_PRIVATE_MIB: u32 = 0;
pub const SNMP_SAFE_REQUESTS: u32 = 0;
pub const SNMP_MAX_OCTET_STRING_LEN: u32 = 127;
pub const SNMP_MAX_TREE_DEPTH: u32 = 15;
pub const LWIP_IGMP: u32 = 1;
pub const LWIP_MDNS: u32 = 1;
pub const LWIP_DNS: u32 = 1;
pub const DNS_TABLE_SIZE: u32 = 4;
pub const DNS_MAX_NAME_LENGTH: u32 = 256;
pub const DNS_MAX_SERVERS: u32 = 2;
pub const DNS_DOES_NAME_CHECK: u32 = 1;
pub const DNS_MSG_SIZE: u32 = 512;
pub const DNS_LOCAL_HOSTLIST: u32 = 0;
pub const DNS_LOCAL_HOSTLIST_IS_DYNAMIC: u32 = 0;
pub const LWIP_UDP: u32 = 1;
pub const LWIP_UDPLITE: u32 = 0;
pub const UDP_TTL: u32 = 128;
pub const LWIP_NETBUF_RECVINFO: u32 = 0;
pub const LWIP_TCP: u32 = 1;
pub const TCP_TTL: u32 = 128;
pub const TCP_MAXRTO: u32 = 10;
pub const TCP_MINRTO: u32 = 2;
pub const TCP_QUEUE_OOSEQ: u32 = 1;
pub const TCP_MSS: u32 = 1460;
pub const TCP_CALCULATE_EFF_SEND_MSS: u32 = 1;
pub const TCP_SND_BUF: u32 = 2920;
pub const TCP_SND_QUEUELEN: u32 = 8;
pub const TCP_SNDLOWAT: u32 = 1460;
pub const TCP_LISTEN_BACKLOG: u32 = 0;
pub const TCP_DEFAULT_LISTEN_BACKLOG: u32 = 255;
pub const TCP_OVERSIZE: u32 = 1460;
pub const LWIP_TCP_TIMESTAMPS: u32 = 0;
pub const LWIP_EVENT_API: u32 = 0;
pub const LWIP_CALLBACK_API: u32 = 1;
pub const PBUF_LINK_HLEN: u32 = 14;
pub const LWIP_NETIF_HOSTNAME: u32 = 1;
pub const LWIP_NETIF_API: u32 = 0;
pub const LWIP_NETIF_STATUS_CALLBACK: u32 = 0;
pub const LWIP_NETIF_LINK_CALLBACK: u32 = 0;
pub const LWIP_NETIF_HWADDRHINT: u32 = 0;
pub const LWIP_NETIF_LOOPBACK: u32 = 0;
pub const LWIP_LOOPBACK_MAX_PBUFS: u32 = 0;
pub const LWIP_NETIF_TX_SINGLE_PBUF: u32 = 1;
pub const LWIP_HAVE_LOOPIF: u32 = 0;
pub const LWIP_HAVE_SLIPIF: u32 = 0;
pub const TCPIP_THREAD_NAME: &[u8; 13] = b"tcpip_thread\0";
pub const TCPIP_THREAD_STACKSIZE: u32 = 0;
pub const TCPIP_THREAD_PRIO: u32 = 1;
pub const TCPIP_MBOX_SIZE: u32 = 0;
pub const SLIPIF_THREAD_NAME: &[u8; 12] = b"slipif_loop\0";
pub const SLIPIF_THREAD_STACKSIZE: u32 = 0;
pub const SLIPIF_THREAD_PRIO: u32 = 1;
pub const PPP_THREAD_NAME: &[u8; 15] = b"pppInputThread\0";
pub const PPP_THREAD_STACKSIZE: u32 = 0;
pub const PPP_THREAD_PRIO: u32 = 1;
pub const DEFAULT_THREAD_NAME: &[u8; 5] = b"lwIP\0";
pub const DEFAULT_THREAD_STACKSIZE: u32 = 0;
pub const DEFAULT_THREAD_PRIO: u32 = 1;
pub const DEFAULT_RAW_RECVMBOX_SIZE: u32 = 0;
pub const DEFAULT_UDP_RECVMBOX_SIZE: u32 = 0;
pub const DEFAULT_TCP_RECVMBOX_SIZE: u32 = 0;
pub const DEFAULT_ACCEPTMBOX_SIZE: u32 = 0;
pub const LWIP_TCPIP_CORE_LOCKING: u32 = 0;
pub const LWIP_TCPIP_CORE_LOCKING_INPUT: u32 = 0;
pub const LWIP_NETCONN: u32 = 0;
pub const LWIP_TCPIP_TIMEOUT: u32 = 1;
pub const LWIP_SOCKET: u32 = 0;
pub const LWIP_COMPAT_SOCKETS: u32 = 0;
pub const LWIP_POSIX_SOCKETS_IO_NAMES: u32 = 0;
pub const LWIP_TCP_KEEPALIVE: u32 = 1;
pub const LWIP_SO_RCVTIMEO: u32 = 0;
pub const LWIP_SO_RCVBUF: u32 = 0;
pub const SO_REUSE: u32 = 0;
pub const SO_REUSE_RXTOALL: u32 = 0;
pub const LWIP_STATS: u32 = 0;
pub const ETHARP_STATS: u32 = 0;
pub const LINK_STATS: u32 = 0;
pub const IP_STATS: u32 = 0;
pub const IPFRAG_STATS: u32 = 0;
pub const ICMP_STATS: u32 = 0;
pub const IGMP_STATS: u32 = 0;
pub const UDP_STATS: u32 = 0;
pub const TCP_STATS: u32 = 0;
pub const MEM_STATS: u32 = 0;
pub const MEMP_STATS: u32 = 0;
pub const SYS_STATS: u32 = 0;
pub const LWIP_STATS_DISPLAY: u32 = 0;
pub const PPP_SUPPORT: u32 = 0;
pub const PPPOE_SUPPORT: u32 = 0;
pub const PPPOS_SUPPORT: u32 = 0;
pub const CHECKSUM_GEN_IP: u32 = 1;
pub const CHECKSUM_GEN_UDP: u32 = 1;
pub const CHECKSUM_GEN_TCP: u32 = 1;
pub const CHECKSUM_CHECK_IP: u32 = 1;
pub const CHECKSUM_CHECK_UDP: u32 = 1;
pub const CHECKSUM_CHECK_TCP: u32 = 1;
pub const LWIP_CHECKSUM_ON_COPY: u32 = 0;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const EFAULT: u32 = 14;
pub const BYTE_ORDER: u32 = 1234;
pub const S16_F: &[u8; 2] = b"d\0";
pub const U16_F: &[u8; 2] = b"d\0";
pub const X16_F: &[u8; 2] = b"x\0";
pub const S32_F: &[u8; 2] = b"d\0";
pub const U32_F: &[u8; 2] = b"d\0";
pub const X32_F: &[u8; 2] = b"x\0";
pub const LWIP_PLATFORM_BYTESWAP: u32 = 1;
pub const SZT_F: &[u8; 2] = b"d\0";
pub const X8_F: &[u8; 4] = b"02x\0";
pub const LWIP_DBG_LEVEL_ALL: u32 = 0;
pub const LWIP_DBG_LEVEL_OFF: u32 = 0;
pub const LWIP_DBG_LEVEL_WARNING: u32 = 1;
pub const LWIP_DBG_LEVEL_SERIOUS: u32 = 2;
pub const LWIP_DBG_LEVEL_SEVERE: u32 = 3;
pub const LWIP_DBG_MASK_LEVEL: u32 = 3;
pub const LWIP_DBG_ON: u32 = 128;
pub const LWIP_DBG_OFF: u32 = 0;
pub const LWIP_DBG_TRACE: u32 = 64;
pub const LWIP_DBG_STATE: u32 = 32;
pub const LWIP_DBG_FRESH: u32 = 16;
pub const LWIP_DBG_HALT: u32 = 8;
pub const IP_CLASSA_NET: u32 = 4278190080;
pub const IP_CLASSA_NSHIFT: u32 = 24;
pub const IP_CLASSA_HOST: u32 = 16777215;
pub const IP_CLASSA_MAX: u32 = 128;
pub const IP_CLASSB_NET: u32 = 4294901760;
pub const IP_CLASSB_NSHIFT: u32 = 16;
pub const IP_CLASSB_HOST: u32 = 65535;
pub const IP_CLASSB_MAX: u32 = 65536;
pub const IP_CLASSC_NET: u32 = 4294967040;
pub const IP_CLASSC_NSHIFT: u32 = 8;
pub const IP_CLASSC_HOST: u32 = 255;
pub const IP_CLASSD_NET: u32 = 4026531840;
pub const IP_CLASSD_NSHIFT: u32 = 28;
pub const IP_CLASSD_HOST: u32 = 268435455;
pub const IP_LOOPBACKNET: u32 = 127;
pub const IPSTR: &[u8; 12] = b"%d.%d.%d.%d\0";
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const SNTP_MAX_SERVERS: u32 = 3;
pub const SNTP_GET_SERVERS_FROM_DHCP: u32 = 0;
pub const SNTP_SERVER_DNS: u32 = 1;
pub const _SYS_TIME_H: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const SSL_SESSION_ID_SIZE: u32 = 32;
pub const AXTLS_VERSION: &[u8; 6] = b"1.4.9\0";
pub const X509_OK: u32 = 0;
pub const X509_NOT_OK: i32 = -1;
pub const X509_VFY_ERROR_NO_TRUSTED_CERT: i32 = -2;
pub const X509_VFY_ERROR_BAD_SIGNATURE: i32 = -3;
pub const X509_VFY_ERROR_NOT_YET_VALID: i32 = -4;
pub const X509_VFY_ERROR_EXPIRED: i32 = -5;
pub const X509_VFY_ERROR_SELF_SIGNED: i32 = -6;
pub const X509_VFY_ERROR_INVALID_CHAIN: i32 = -7;
pub const X509_VFY_ERROR_UNSUPPORTED_DIGEST: i32 = -8;
pub const X509_INVALID_PRIV_KEY: i32 = -9;
pub const X509_MAX_CERTS: i32 = -10;
pub const X509_NUM_DN_TYPES: u32 = 3;
pub const X509_COMMON_NAME: u32 = 0;
pub const X509_ORGANIZATION: u32 = 1;
pub const X509_ORGANIZATIONAL_UNIT: u32 = 2;
pub const ASN1_INTEGER: u32 = 2;
pub const ASN1_BIT_STRING: u32 = 3;
pub const ASN1_OCTET_STRING: u32 = 4;
pub const ASN1_NULL: u32 = 5;
pub const ASN1_PRINTABLE_STR2: u32 = 12;
pub const ASN1_OID: u32 = 6;
pub const ASN1_PRINTABLE_STR: u32 = 19;
pub const ASN1_TELETEX_STR: u32 = 20;
pub const ASN1_IA5_STR: u32 = 22;
pub const ASN1_UTC_TIME: u32 = 23;
pub const ASN1_GENERALIZED_TIME: u32 = 24;
pub const ASN1_UNICODE_STR: u32 = 30;
pub const ASN1_SEQUENCE: u32 = 48;
pub const ASN1_CONTEXT_DNSNAME: u32 = 130;
pub const ASN1_SET: u32 = 49;
pub const ASN1_V3_DATA: u32 = 163;
pub const ASN1_IMPLICIT_TAG: u32 = 128;
pub const ASN1_EXPLICIT_TAG: u32 = 160;
pub const SIG_TYPE_MD2: u32 = 2;
pub const SIG_TYPE_MD5: u32 = 4;
pub const SIG_TYPE_SHA1: u32 = 5;
pub const SIG_TYPE_SHA256: u32 = 11;
pub const SIG_TYPE_SHA384: u32 = 12;
pub const SIG_TYPE_SHA512: u32 = 13;
pub const SALT_SIZE: u32 = 8;
pub const ERR_OK: u32 = 0;
pub const ERR_MEM: i32 = -1;
pub const ERR_BUF: i32 = -2;
pub const ERR_TIMEOUT: i32 = -3;
pub const ERR_RTE: i32 = -4;
pub const ERR_INPROGRESS: i32 = -5;
pub const ERR_VAL: i32 = -6;
pub const ERR_WOULDBLOCK: i32 = -7;
pub const ERR_ABRT: i32 = -8;
pub const ERR_RST: i32 = -9;
pub const ERR_CLSD: i32 = -10;
pub const ERR_CONN: i32 = -11;
pub const ERR_ARG: i32 = -12;
pub const ERR_USE: i32 = -13;
pub const ERR_IF: i32 = -14;
pub const ERR_ISCONN: i32 = -15;
pub const PBUF_TRANSPORT_HLEN: u32 = 20;
pub const PBUF_IP_HLEN: u32 = 20;
pub const PBUF_FLAG_PUSH: u32 = 1;
pub const PBUF_FLAG_IS_CUSTOM: u32 = 2;
pub const PBUF_FLAG_MCASTLOOP: u32 = 4;
pub const NETIF_MAX_HWADDR_LEN: u32 = 6;
pub const NETIF_FLAG_UP: u32 = 1;
pub const NETIF_FLAG_BROADCAST: u32 = 2;
pub const NETIF_FLAG_POINTTOPOINT: u32 = 4;
pub const NETIF_FLAG_DHCP: u32 = 8;
pub const NETIF_FLAG_LINK_UP: u32 = 16;
pub const NETIF_FLAG_ETHARP: u32 = 32;
pub const NETIF_FLAG_ETHERNET: u32 = 64;
pub const NETIF_FLAG_IGMP: u32 = 128;
pub const IP_OPTIONS_SEND: u32 = 1;
pub const IP_HLEN: u32 = 20;
pub const IP_PROTO_ICMP: u32 = 1;
pub const IP_PROTO_IGMP: u32 = 2;
pub const IP_PROTO_UDP: u32 = 17;
pub const IP_PROTO_UDPLITE: u32 = 136;
pub const IP_PROTO_TCP: u32 = 6;
pub const IP_RF: u32 = 32768;
pub const IP_DF: u32 = 16384;
pub const IP_MF: u32 = 8192;
pub const IP_OFFMASK: u32 = 8191;
pub const ICMP_ER: u32 = 0;
pub const ICMP_DUR: u32 = 3;
pub const ICMP_SQ: u32 = 4;
pub const ICMP_RD: u32 = 5;
pub const ICMP_ECHO: u32 = 8;
pub const ICMP_TE: u32 = 11;
pub const ICMP_PP: u32 = 12;
pub const ICMP_TS: u32 = 13;
pub const ICMP_TSR: u32 = 14;
pub const ICMP_IRQ: u32 = 15;
pub const ICMP_IR: u32 = 16;
pub const TCP_SNDQUEUELEN_OVERFLOW: u32 = 65532;
pub const TCP_WRITE_FLAG_COPY: u32 = 1;
pub const TCP_WRITE_FLAG_MORE: u32 = 2;
pub const TCP_PRIO_MIN: u32 = 1;
pub const TCP_PRIO_NORMAL: u32 = 64;
pub const TCP_PRIO_MAX: u32 = 127;
pub const SSL_PROTOCOL_MIN_VERSION: u32 = 49;
pub const SSL_PROTOCOL_MINOR_VERSION: u32 = 2;
pub const SSL_PROTOCOL_VERSION_MAX: u32 = 50;
pub const SSL_PROTOCOL_VERSION1_1: u32 = 50;
pub const SSL_RANDOM_SIZE: u32 = 32;
pub const SSL_SECRET_SIZE: u32 = 48;
pub const SSL_FINISHED_HASH_SIZE: u32 = 12;
pub const SSL_RECORD_SIZE: u32 = 5;
pub const SSL_SERVER_READ: u32 = 0;
pub const SSL_SERVER_WRITE: u32 = 1;
pub const SSL_CLIENT_READ: u32 = 2;
pub const SSL_CLIENT_WRITE: u32 = 3;
pub const SSL_HS_HDR_SIZE: u32 = 4;
pub const SSL_NEED_RECORD: u32 = 1;
pub const SSL_TX_ENCRYPTED: u32 = 2;
pub const SSL_RX_ENCRYPTED: u32 = 4;
pub const SSL_SESSION_RESUME: u32 = 8;
pub const SSL_IS_CLIENT: u32 = 16;
pub const SSL_HAS_CERT_REQ: u32 = 32;
pub const SSL_SENT_CLOSE_NOTIFY: u32 = 64;
pub const MAX_KEY_BYTE_SIZE: u32 = 512;
pub const RT_MAX_PLAIN_LENGTH: u32 = 1024;
pub const RT_EXTRA: u32 = 1024;
pub const BM_RECORD_OFFSET: u32 = 5;
pub const NUM_PROTOCOLS: u32 = 4;
pub const SSL_CLIENT_AUTHENTICATION: u32 = 65536;
pub const SSL_SERVER_VERIFY_LATER: u32 = 131072;
pub const SSL_NO_DEFAULT_KEY: u32 = 262144;
pub const SSL_DISPLAY_STATES: u32 = 524288;
pub const SSL_DISPLAY_BYTES: u32 = 1048576;
pub const SSL_DISPLAY_CERTS: u32 = 2097152;
pub const SSL_DISPLAY_RSA: u32 = 4194304;
pub const SSL_CONNECT_IN_PARTS: u32 = 8388608;
pub const SSL_OK: u32 = 0;
pub const SSL_NOT_OK: i32 = -1;
pub const SSL_ERROR_DEAD: i32 = -2;
pub const SSL_CLOSE_NOTIFY: i32 = -3;
pub const SSL_ERROR_CONN_LOST: i32 = -256;
pub const SSL_ERROR_SOCK_SETUP_FAILURE: i32 = -258;
pub const SSL_ERROR_INVALID_HANDSHAKE: i32 = -260;
pub const SSL_ERROR_INVALID_PROT_MSG: i32 = -261;
pub const SSL_ERROR_INVALID_HMAC: i32 = -262;
pub const SSL_ERROR_INVALID_VERSION: i32 = -263;
pub const SSL_ERROR_INVALID_SESSION: i32 = -265;
pub const SSL_ERROR_NO_CIPHER: i32 = -266;
pub const SSL_ERROR_BAD_CERTIFICATE: i32 = -268;
pub const SSL_ERROR_INVALID_KEY: i32 = -269;
pub const SSL_ERROR_FINISHED_INVALID: i32 = -271;
pub const SSL_ERROR_NO_CERT_DEFINED: i32 = -272;
pub const SSL_ERROR_NO_CLIENT_RENOG: i32 = -273;
pub const SSL_ERROR_NOT_SUPPORTED: i32 = -274;
pub const SSL_X509_OFFSET: i32 = -512;
pub const SSL_ALERT_TYPE_WARNING: u32 = 1;
pub const SLL_ALERT_TYPE_FATAL: u32 = 2;
pub const SSL_ALERT_CLOSE_NOTIFY: u32 = 0;
pub const SSL_ALERT_UNEXPECTED_MESSAGE: u32 = 10;
pub const SSL_ALERT_BAD_RECORD_MAC: u32 = 20;
pub const SSL_ALERT_HANDSHAKE_FAILURE: u32 = 40;
pub const SSL_ALERT_BAD_CERTIFICATE: u32 = 42;
pub const SSL_ALERT_ILLEGAL_PARAMETER: u32 = 47;
pub const SSL_ALERT_DECODE_ERROR: u32 = 50;
pub const SSL_ALERT_DECRYPT_ERROR: u32 = 51;
pub const SSL_ALERT_INVALID_VERSION: u32 = 70;
pub const SSL_ALERT_NO_RENEGOTIATION: u32 = 100;
pub const SSL_AES128_SHA: u32 = 47;
pub const SSL_AES256_SHA: u32 = 53;
pub const SSL_RC4_128_SHA: u32 = 5;
pub const SSL_RC4_128_MD5: u32 = 4;
pub const SSL_BUILD_SKELETON_MODE: u32 = 1;
pub const SSL_BUILD_SERVER_ONLY: u32 = 2;
pub const SSL_BUILD_ENABLE_VERIFICATION: u32 = 3;
pub const SSL_BUILD_ENABLE_CLIENT: u32 = 4;
pub const SSL_BUILD_FULL_MODE: u32 = 5;
pub const SSL_BUILD_MODE: u32 = 0;
pub const SSL_MAX_CERT_CFG_OFFSET: u32 = 1;
pub const SSL_MAX_CA_CERT_CFG_OFFSET: u32 = 2;
pub const SSL_HAS_PEM: u32 = 3;
pub const SSL_DEFAULT_SVR_SESS: u32 = 1;
pub const SSL_DEFAULT_CLNT_SESS: u32 = 1;
pub const SSL_X509_CERT_COMMON_NAME: u32 = 0;
pub const SSL_X509_CERT_ORGANIZATION: u32 = 1;
pub const SSL_X509_CERT_ORGANIZATIONAL_NAME: u32 = 2;
pub const SSL_X509_CA_CERT_COMMON_NAME: u32 = 3;
pub const SSL_X509_CA_CERT_ORGANIZATION: u32 = 4;
pub const SSL_X509_CA_CERT_ORGANIZATIONAL_NAME: u32 = 5;
pub const SSL_OBJ_X509_CERT: u32 = 1;
pub const SSL_OBJ_X509_CACERT: u32 = 2;
pub const SSL_OBJ_RSA_KEY: u32 = 3;
pub const SSL_OBJ_PKCS8: u32 = 4;
pub const SSL_OBJ_PKCS12: u32 = 5;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const DNS_TMR_INTERVAL: u32 = 1000;
pub const DNS_RRTYPE_A: u32 = 1;
pub const DNS_RRTYPE_NS: u32 = 2;
pub const DNS_RRTYPE_MD: u32 = 3;
pub const DNS_RRTYPE_MF: u32 = 4;
pub const DNS_RRTYPE_CNAME: u32 = 5;
pub const DNS_RRTYPE_SOA: u32 = 6;
pub const DNS_RRTYPE_MB: u32 = 7;
pub const DNS_RRTYPE_MG: u32 = 8;
pub const DNS_RRTYPE_MR: u32 = 9;
pub const DNS_RRTYPE_NULL: u32 = 10;
pub const DNS_RRTYPE_WKS: u32 = 11;
pub const DNS_RRTYPE_PTR: u32 = 12;
pub const DNS_RRTYPE_HINFO: u32 = 13;
pub const DNS_RRTYPE_MINFO: u32 = 14;
pub const DNS_RRTYPE_MX: u32 = 15;
pub const DNS_RRTYPE_TXT: u32 = 16;
pub const DNS_RRCLASS_IN: u32 = 1;
pub const DNS_RRCLASS_CS: u32 = 2;
pub const DNS_RRCLASS_CH: u32 = 3;
pub const DNS_RRCLASS_HS: u32 = 4;
pub const DNS_RRCLASS_FLUSH: u32 = 2048;
pub const NETDB_ELEM_SIZE: u32 = 305;
pub const ESPCONN_OK: u32 = 0;
pub const ESPCONN_MEM: i32 = -1;
pub const ESPCONN_TIMEOUT: i32 = -3;
pub const ESPCONN_RTE: i32 = -4;
pub const ESPCONN_INPROGRESS: i32 = -5;
pub const ESPCONN_MAXNUM: i32 = -7;
pub const ESPCONN_ABRT: i32 = -8;
pub const ESPCONN_RST: i32 = -9;
pub const ESPCONN_CLSD: i32 = -10;
pub const ESPCONN_CONN: i32 = -11;
pub const ESPCONN_ARG: i32 = -12;
pub const ESPCONN_IF: i32 = -14;
pub const ESPCONN_ISCONN: i32 = -15;
pub const ESPCONN_TIME: i32 = -16;
pub const ESPCONN_NODATA: i32 = -17;
pub const ESPCONN_HANDSHAKE: i32 = -28;
pub const ESPCONN_RESP_TIMEOUT: i32 = -29;
pub const ESPCONN_PROTO_MSG: i32 = -61;
pub const ESPCONN_SSL: u32 = 1;
pub const ESPCONN_NORM: u32 = 0;
pub const ESPCONN_STA: u32 = 1;
pub const ESPCONN_AP: u32 = 2;
pub const ESPCONN_AP_STA: u32 = 3;
pub const STA_NETIF: u32 = 0;
pub const AP_NETIF: u32 = 1;
pub const linkMax: u32 = 15;
pub const espconn_TaskPrio: u32 = 26;
pub const espconn_TaskQueueLen: u32 = 15;
pub const SSL_KEEP_INTVL: u32 = 1000;
pub const SSL_KEEP_CNT: u32 = 3;
pub const SSL_KEEP_IDLE: u32 = 60000;
pub const ESPCONN_SECURE_MAX_SIZE: u32 = 8192;
pub const ESPCONN_SECURE_DEFAULT_HEAP: u32 = 14336;
pub const ESPCONN_SECURE_DEFAULT_SIZE: u32 = 2048;
pub const ESPCONN_HANDSHAKE_TIMEOUT: u32 = 60;
pub const espconn_TlsTaskPrio: u32 = 25;
pub type sint8_t = ::core::ffi::c_schar;
pub type sint16_t = ::core::ffi::c_short;
pub type sint32_t = ::core::ffi::c_int;
pub type sint64_t = ::core::ffi::c_longlong;
pub type u_int64_t = ::core::ffi::c_ulonglong;
pub type real32_t = f32;
pub type real64_t = f64;
pub type uint8 = ::core::ffi::c_uchar;
pub type u8_ = ::core::ffi::c_uchar;
pub type sint8 = ::core::ffi::c_schar;
pub type int8 = ::core::ffi::c_schar;
pub type s8 = ::core::ffi::c_schar;
pub type uint16 = ::core::ffi::c_ushort;
pub type u16_ = ::core::ffi::c_ushort;
pub type sint16 = ::core::ffi::c_short;
pub type s16 = ::core::ffi::c_short;
pub type uint32 = ::core::ffi::c_uint;
pub type u_int = ::core::ffi::c_uint;
pub type u32_ = ::core::ffi::c_uint;
pub type sint32 = ::core::ffi::c_int;
pub type s32 = ::core::ffi::c_int;
pub type int32 = ::core::ffi::c_int;
pub type sint64 = ::core::ffi::c_longlong;
pub type uint64 = ::core::ffi::c_ulonglong;
pub type u64_ = ::core::ffi::c_ulonglong;
pub type real32 = f32;
pub type real64 = f64;
pub const STATUS_OK: STATUS = 0;
pub const STATUS_FAIL: STATUS = 1;
pub const STATUS_PENDING: STATUS = 2;
pub const STATUS_BUSY: STATUS = 3;
pub const STATUS_CANCEL: STATUS = 4;
pub type STATUS = ::core::ffi::c_uint;
pub type bool_ = ::core::ffi::c_uchar;
pub type comp = u32;
pub type long_comp = u64;
pub type slong_comp = sint64_t;
#[doc = " @struct  _bigint\n @brief A big integer basic object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bigint {
    #[doc = "< The next bigint in the cache."]
    pub next: *mut _bigint,
    #[doc = "< The number of components in this bigint."]
    pub size: ::core::ffi::c_short,
    #[doc = "< The heapsize allocated for this bigint"]
    pub max_comps: ::core::ffi::c_short,
    #[doc = "< An internal reference count."]
    pub refs: ::core::ffi::c_int,
    #[doc = "< A ptr to the actual component data"]
    pub comps: *mut comp,
}
#[doc = " @struct  _bigint\n @brief A big integer basic object"]
pub type bigint = _bigint;
#[doc = " Maintains the state of the cache, and a number of variables used in\n reduction."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BI_CTX {
    #[doc = "< Bigints currently used."]
    pub active_list: *mut bigint,
    #[doc = "< Bigints not used."]
    pub free_list: *mut bigint,
    #[doc = "< The radix used."]
    pub bi_radix: *mut bigint,
    #[doc = "< modulus"]
    pub bi_mod: [*mut bigint; 1usize],
    #[doc = "< Normalised mod storage."]
    pub bi_normalised_mod: [*mut bigint; 1usize],
    #[doc = "< Used by sliding-window."]
    pub g: *mut *mut bigint,
    #[doc = "< The size of the sliding window"]
    pub window: ::core::ffi::c_int,
    #[doc = "< Number of active bigints."]
    pub active_count: ::core::ffi::c_int,
    #[doc = "< Number of free bigints."]
    pub free_count: ::core::ffi::c_int,
    #[doc = "< The mod offset we are using"]
    pub mod_offset: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aes_key_st {
    pub rounds: u16,
    pub key_size: u16,
    pub ks: [u32; 120usize],
    pub iv: [u8; 16usize],
}
pub type AES_CTX = aes_key_st;
pub const AES_MODE_AES_MODE_128: AES_MODE = 0;
pub const AES_MODE_AES_MODE_256: AES_MODE = 1;
pub type AES_MODE = ::core::ffi::c_uint;
#[doc = " RC4 declarations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RC4_CTX {
    pub x: u8,
    pub y: u8,
    pub m: [u8; 256usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHA1_CTX {
    pub Intermediate_Hash: [u32; 5usize],
    pub Length_Low: u32,
    pub Length_High: u32,
    pub Message_Block_Index: u16,
    pub Message_Block: [u8; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHA256_CTX {
    pub total: [u32; 2usize],
    pub state: [u32; 8usize],
    pub buffer: [u8; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SHA512_CTX {
    pub h_dig: SHA512_CTX__bindgen_ty_1,
    pub w_buf: SHA512_CTX__bindgen_ty_2,
    pub size: usize,
    pub totalSize: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SHA512_CTX__bindgen_ty_1 {
    pub h: [u64; 8usize],
    pub digest: [u8; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SHA512_CTX__bindgen_ty_2 {
    pub w: [u64; 80usize],
    pub buffer: [u8; 128usize],
}
pub type SHA384_CTX = SHA512_CTX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MD5_CTX {
    pub state: [u32; 4usize],
    pub count: [u32; 2usize],
    pub buffer: [u8; 64usize],
}
#[doc = " RSA declarations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RSA_CTX {
    pub m: *mut bigint,
    pub e: *mut bigint,
    pub d: *mut bigint,
    pub p: *mut bigint,
    pub q: *mut bigint,
    pub dP: *mut bigint,
    pub dQ: *mut bigint,
    pub qInv: *mut bigint,
    pub num_octets: ::core::ffi::c_int,
    pub bi_ctx: *mut BI_CTX,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::core::ffi::c_ushort,
    pub __ctype_tolower: *const ::core::ffi::c_int,
    pub __ctype_toupper: *const ::core::ffi::c_int,
    pub __names: [*const ::core::ffi::c_char; 13usize],
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
pub type ETSSignal = u32;
pub type ETSParam = u32;
pub type ETSEvent = ETSEventTag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ETSEventTag {
    pub sig: ETSSignal,
    pub par: ETSParam,
}
pub type ETSTask = ::core::option::Option<unsafe extern "C" fn(e: *mut ETSEvent)>;
pub type ETSHandle = u32;
pub type ETSTimerFunc =
    ::core::option::Option<unsafe extern "C" fn(timer_arg: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETSTIMER_ {
    pub timer_next: *mut _ETSTIMER_,
    pub timer_expire: u32,
    pub timer_period: u32,
    pub timer_func: ETSTimerFunc,
    pub timer_arg: *mut ::core::ffi::c_void,
}
pub type ETSTimer = _ETSTIMER_;
pub type ets_isr_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
pub type u8_t = ::core::ffi::c_uchar;
pub type s8_t = ::core::ffi::c_schar;
pub type u16_t = ::core::ffi::c_ushort;
pub type s16_t = ::core::ffi::c_short;
pub type u32_t = ::core::ffi::c_ulong;
pub type s32_t = ::core::ffi::c_long;
pub type mem_ptr_t = ::core::ffi::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_addr {
    pub addr: u32_t,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ip_addr_packed {
    pub addr: u32_t,
}
#[doc = " ip_addr_t uses a struct for convenience only, so that the same defines can\n operate both on ip_addr_t as well as on ip_addr_p_t."]
pub type ip_addr_t = ip_addr;
pub type ip_addr_p_t = ip_addr_packed;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ip_addr2 {
    pub addrw: [u16_t; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_info {
    pub ip: ip_addr,
    pub netmask: ip_addr,
    pub gw: ip_addr,
}
pub type __u_char = ::core::ffi::c_uchar;
pub type __u_short = ::core::ffi::c_ushort;
pub type __u_int = ::core::ffi::c_uint;
pub type __u_long = ::core::ffi::c_ulong;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_long;
pub type __uint64_t = ::core::ffi::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::core::ffi::c_long;
pub type __u_quad_t = ::core::ffi::c_ulong;
pub type __intmax_t = ::core::ffi::c_long;
pub type __uintmax_t = ::core::ffi::c_ulong;
pub type __dev_t = ::core::ffi::c_ulong;
pub type __uid_t = ::core::ffi::c_uint;
pub type __gid_t = ::core::ffi::c_uint;
pub type __ino_t = ::core::ffi::c_ulong;
pub type __ino64_t = ::core::ffi::c_ulong;
pub type __mode_t = ::core::ffi::c_uint;
pub type __nlink_t = ::core::ffi::c_ulong;
pub type __off_t = ::core::ffi::c_long;
pub type __off64_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::core::ffi::c_int; 2usize],
}
pub type __clock_t = ::core::ffi::c_long;
pub type __rlim_t = ::core::ffi::c_ulong;
pub type __rlim64_t = ::core::ffi::c_ulong;
pub type __id_t = ::core::ffi::c_uint;
pub type __time_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_uint;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __suseconds64_t = ::core::ffi::c_long;
pub type __daddr_t = ::core::ffi::c_int;
pub type __key_t = ::core::ffi::c_int;
pub type __clockid_t = ::core::ffi::c_int;
pub type __timer_t = *mut ::core::ffi::c_void;
pub type __blksize_t = ::core::ffi::c_long;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blkcnt64_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = ::core::ffi::c_ulong;
pub type __fsblkcnt64_t = ::core::ffi::c_ulong;
pub type __fsfilcnt_t = ::core::ffi::c_ulong;
pub type __fsfilcnt64_t = ::core::ffi::c_ulong;
pub type __fsword_t = ::core::ffi::c_long;
pub type __ssize_t = ::core::ffi::c_long;
pub type __syscall_slong_t = ::core::ffi::c_long;
pub type __syscall_ulong_t = ::core::ffi::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::core::ffi::c_char;
pub type __intptr_t = ::core::ffi::c_long;
pub type __socklen_t = ::core::ffi::c_uint;
pub type __sig_atomic_t = ::core::ffi::c_int;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::core::ffi::c_int,
    pub tm_min: ::core::ffi::c_int,
    pub tm_hour: ::core::ffi::c_int,
    pub tm_mday: ::core::ffi::c_int,
    pub tm_mon: ::core::ffi::c_int,
    pub tm_year: ::core::ffi::c_int,
    pub tm_wday: ::core::ffi::c_int,
    pub tm_yday: ::core::ffi::c_int,
    pub tm_isdst: ::core::ffi::c_int,
    pub tm_gmtoff: ::core::ffi::c_long,
    pub tm_zone: *const ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
pub type suseconds_t = __suseconds_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::core::ffi::c_ulong; 16usize],
}
pub type sigset_t = __sigset_t;
pub type __fd_mask = ::core::ffi::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
pub type fd_mask = __fd_mask;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::core::ffi::c_int,
    pub tz_dsttime: ::core::ffi::c_int,
}
pub const __itimer_which_ITIMER_REAL: __itimer_which = 0;
pub const __itimer_which_ITIMER_VIRTUAL: __itimer_which = 1;
pub const __itimer_which_ITIMER_PROF: __itimer_which = 2;
pub type __itimer_which = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
pub type __itimer_which_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _x509_ctx {
    pub ca_cert_dn: [*mut ::core::ffi::c_char; 3usize],
    pub cert_dn: [*mut ::core::ffi::c_char; 3usize],
    pub subject_alt_dnsnames: *mut *mut ::core::ffi::c_char,
    pub not_before: time_t,
    pub not_after: time_t,
    pub signature: *mut u8,
    pub sig_len: u16,
    pub sig_type: u8,
    pub rsa_ctx: *mut RSA_CTX,
    pub digest: *mut bigint,
    pub next: *mut _x509_ctx,
}
pub type X509_CTX = _x509_ctx;
pub type crypt_func = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const u8,
        arg3: *mut u8,
        arg4: ::core::ffi::c_int,
    ),
>;
pub type hmac_func = ::core::option::Option<
    unsafe extern "C" fn(
        msg: *const u8,
        length: ::core::ffi::c_int,
        key: *const u8,
        key_len: ::core::ffi::c_int,
        digest: *mut u8,
    ),
>;
pub type sys_sem_t = u8_t;
pub type sys_mutex_t = u8_t;
pub type sys_mbox_t = u8_t;
pub type wchar_t = ::core::ffi::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::core::ffi::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
pub type mem_size_t = usize;
pub type err_t = s32_t;
pub const pbuf_layer_PBUF_TRANSPORT: pbuf_layer = 0;
pub const pbuf_layer_PBUF_IP: pbuf_layer = 1;
pub const pbuf_layer_PBUF_LINK: pbuf_layer = 2;
pub const pbuf_layer_PBUF_RAW: pbuf_layer = 3;
pub type pbuf_layer = ::core::ffi::c_uint;
pub const pbuf_type_PBUF_RAM: pbuf_type = 0;
pub const pbuf_type_PBUF_ROM: pbuf_type = 1;
pub const pbuf_type_PBUF_REF: pbuf_type = 2;
pub const pbuf_type_PBUF_POOL: pbuf_type = 3;
pub type pbuf_type = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pbuf {
    #[doc = " next pbuf in singly linked pbuf chain"]
    pub next: *mut pbuf,
    #[doc = " pointer to the actual data in the buffer"]
    pub payload: *mut ::core::ffi::c_void,
    #[doc = " total length of this buffer and all next buffers in chain\n belonging to the same packet.\n\n For non-queue packet chains this is the invariant:\n p->tot_len == p->len + (p->next? p->next->tot_len: 0)"]
    pub tot_len: u16_t,
    #[doc = " length of this buffer"]
    pub len: u16_t,
    #[doc = " pbuf_type as u8_t instead of enum to save space"]
    pub type_: u8_t,
    #[doc = " misc flags"]
    pub flags: u8_t,
    #[doc = " the reference count always equals the number of pointers\n that refer to this pbuf. This can be pointers from an application,\n the stack itself, or pbuf->next pointers from a chain."]
    pub ref_: u16_t,
    pub eb: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dhcp {
    _unused: [u8; 0],
}
#[doc = " Function prototype for netif init functions. Set up flags and output/linkoutput\n callback functions in this function.\n\n @param netif The netif to initialize"]
pub type netif_init_fn = ::core::option::Option<unsafe extern "C" fn(netif: *mut netif) -> err_t>;
#[doc = " Function prototype for netif->input functions. This function is saved as 'input'\n callback function in the netif struct. Call it when a packet has been received.\n\n @param p The received packet, copied into a pbuf\n @param inp The netif which received the packet"]
pub type netif_input_fn =
    ::core::option::Option<unsafe extern "C" fn(p: *mut pbuf, inp: *mut netif) -> err_t>;
#[doc = " Function prototype for netif->output functions. Called by lwIP when a packet\n shall be sent. For ethernet netif, set this to 'etharp_output' and set\n 'linkoutput'.\n\n @param netif The netif which shall send a packet\n @param p The packet to send (p->payload points to IP header)\n @param ipaddr The IP address to which the packet shall be sent"]
pub type netif_output_fn = ::core::option::Option<
    unsafe extern "C" fn(netif: *mut netif, p: *mut pbuf, ipaddr: *mut ip_addr_t) -> err_t,
>;
#[doc = " Function prototype for netif->linkoutput functions. Only used for ethernet\n netifs. This function is called by ARP when a packet shall be sent.\n\n @param netif The netif which shall send a packet\n @param p The packet to send (raw ethernet packet)"]
pub type netif_linkoutput_fn =
    ::core::option::Option<unsafe extern "C" fn(netif: *mut netif, p: *mut pbuf) -> err_t>;
#[doc = " Function prototype for netif status- or link-callback functions."]
pub type netif_status_callback_fn = ::core::option::Option<unsafe extern "C" fn(netif: *mut netif)>;
#[doc = " Function prototype for netif igmp_mac_filter functions"]
pub type netif_igmp_mac_filter_fn = ::core::option::Option<
    unsafe extern "C" fn(netif: *mut netif, group: *mut ip_addr_t, action: u8_t) -> err_t,
>;
pub type dhcp_event_fn = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " Generic data structure used for all lwIP network interfaces.\n  The following fields should be filled in by the initialization\n  function for the device driver: hwaddr_len, hwaddr[], mtu, flags"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netif {
    #[doc = " pointer to next in linked list"]
    pub next: *mut netif,
    #[doc = " IP address configuration in network byte order"]
    pub ip_addr: ip_addr_t,
    pub netmask: ip_addr_t,
    pub gw: ip_addr_t,
    #[doc = " This function is called by the network device driver\n  to pass a packet up the TCP/IP stack. ��IP���������ݰ�"]
    pub input: netif_input_fn,
    #[doc = " This function is called by the IP module when it wants\n  to send a packet on the interface. This function typically\n  first resolves the hardware address, then sends the packet. ����IP���ݰ�"]
    pub output: netif_output_fn,
    #[doc = " This function is called by the ARP module when it wants\n  to send a packet on the interface. This function outputs\n  the pbuf as-is on the link medium. �ײ����ݰ�����"]
    pub linkoutput: netif_linkoutput_fn,
    #[doc = " This field can be set by the device driver and could point\n  to state information for the device. ���������\u{5b6}Σ�����\u{5b8}��ײ��豸�����Ϣ"]
    pub state: *mut ::core::ffi::c_void,
    #[doc = " the DHCP client state information for this netif"]
    pub dhcp: *mut dhcp,
    pub dhcps_pcb: *mut udp_pcb,
    pub dhcp_event: dhcp_event_fn,
    pub hostname: *mut ::core::ffi::c_char,
    #[doc = " maximum transfer unit (in bytes) �ýӿ�������������ݰ����ȣ�����1500"]
    pub mtu: u16_t,
    #[doc = " number of bytes used in hwaddr�ýӿ�������\u{5b7}����"]
    pub hwaddr_len: u8_t,
    #[doc = " link level hardware address of this interface �ýӿ�������\u{5b7}"]
    pub hwaddr: [u8_t; 6usize],
    #[doc = " flags (see NETIF_FLAG_ above) �ýӿ�״\u{32c}�������\u{5b6}�"]
    pub flags: u8_t,
    #[doc = " descriptive abbreviation �ýӿڵ�����"]
    pub name: [::core::ffi::c_char; 2usize],
    #[doc = " number of this interface �ýӿڵı��"]
    pub num: u8_t,
    #[doc = " This function could be called to add or delete a entry in the multicast\nfilter table of the ethernet MAC."]
    pub igmp_mac_filter: netif_igmp_mac_filter_fn,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_pcb {
    pub local_ip: ip_addr_t,
    pub remote_ip: ip_addr_t,
    pub so_options: u8_t,
    pub tos: u8_t,
    pub ttl: u8_t,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ip_hdr {
    pub _v_hl_tos: u16_t,
    pub _len: u16_t,
    pub _id: u16_t,
    pub _offset: u16_t,
    pub _ttl: u8_t,
    pub _proto: u8_t,
    pub _chksum: u16_t,
    pub src: ip_addr_p_t,
    pub dest: ip_addr_p_t,
}
pub const icmp_dur_type_ICMP_DUR_NET: icmp_dur_type = 0;
pub const icmp_dur_type_ICMP_DUR_HOST: icmp_dur_type = 1;
pub const icmp_dur_type_ICMP_DUR_PROTO: icmp_dur_type = 2;
pub const icmp_dur_type_ICMP_DUR_PORT: icmp_dur_type = 3;
pub const icmp_dur_type_ICMP_DUR_FRAG: icmp_dur_type = 4;
pub const icmp_dur_type_ICMP_DUR_SR: icmp_dur_type = 5;
pub type icmp_dur_type = ::core::ffi::c_uint;
pub const icmp_te_type_ICMP_TE_TTL: icmp_te_type = 0;
pub const icmp_te_type_ICMP_TE_FRAG: icmp_te_type = 1;
pub type icmp_te_type = ::core::ffi::c_uint;
#[doc = " This is the standard ICMP header only that the u32_t data\n  is splitted to two u16_t like ICMP echo needs it.\n  This header is also used for other ICMP types that do not\n  use the data part.\n  ����ICMP�����������ײ��ṹ��\n  ��������ICMP�����ײ��к\u{734}������ԣ�\n  �ýṹ\u{36c}������������ICMP���ġ�"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct icmp_echo_hdr {
    pub type_: u8_t,
    pub code: u8_t,
    pub chksum: u16_t,
    pub id: u16_t,
    pub seqno: u16_t,
}
#[doc = " Function prototype for tcp accept callback functions. Called when a new\n connection can be accepted on a listening pcb.\n\n @param arg Additional argument to pass to the callback function (@see tcp_arg())\n @param newpcb The new connection pcb\n @param err An error code if there has been an error accepting.\n            Only return ERR_ABRT if you have called tcp_abort from within the\n            callback function!"]
pub type tcp_accept_fn = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, newpcb: *mut tcp_pcb, err: err_t) -> err_t,
>;
#[doc = " Function prototype for tcp receive callback functions. Called when data has\n been received.\n\n @param arg Additional argument to pass to the callback function (@see tcp_arg())\n @param tpcb The connection pcb which received data\n @param p The received data (or NULL when the connection has been closed!)\n @param err An error code if there has been an error receiving\n            Only return ERR_ABRT if you have called tcp_abort from within the\n            callback function!"]
pub type tcp_recv_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::core::ffi::c_void,
        tpcb: *mut tcp_pcb,
        p: *mut pbuf,
        err: err_t,
    ) -> err_t,
>;
#[doc = " Function prototype for tcp sent callback functions. Called when sent data has\n been acknowledged by the remote side. Use it to free corresponding resources.\n This also means that the pcb has now space available to send new data.\n\n @param arg Additional argument to pass to the callback function (@see tcp_arg())\n @param tpcb The connection pcb for which data has been acknowledged\n @param len The amount of bytes acknowledged\n @return ERR_OK: try to send some data by calling tcp_output\n            Only return ERR_ABRT if you have called tcp_abort from within the\n            callback function!"]
pub type tcp_sent_fn = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, tpcb: *mut tcp_pcb, len: u16_t) -> err_t,
>;
#[doc = " Function prototype for tcp poll callback functions. Called periodically as\n specified by @see tcp_poll.\n\n @param arg Additional argument to pass to the callback function (@see tcp_arg())\n @param tpcb tcp pcb\n @return ERR_OK: try to send some data by calling tcp_output\n            Only return ERR_ABRT if you have called tcp_abort from within the\n            callback function!"]
pub type tcp_poll_fn = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, tpcb: *mut tcp_pcb) -> err_t,
>;
#[doc = " Function prototype for tcp error callback functions. Called when the pcb\n receives a RST or is unexpectedly closed for any other reason.\n\n @note The corresponding pcb is already freed when this callback is called!\n\n @param arg Additional argument to pass to the callback function (@see tcp_arg())\n @param err Error code to indicate why the pcb has been closed\n            ERR_ABRT: aborted through tcp_abort or by a TCP timer\n            ERR_RST: the connection was reset by the remote host"]
pub type tcp_err_fn =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, err: err_t)>;
#[doc = " Function prototype for tcp connected callback functions. Called when a pcb\n is connected to the remote side after initiating a connection attempt by\n calling tcp_connect().\n\n @param arg Additional argument to pass to the callback function (@see tcp_arg())\n @param tpcb The connection pcb which is connected\n @param err An unused error code, always ERR_OK currently ;-) TODO!\n            Only return ERR_ABRT if you have called tcp_abort from within the\n            callback function!\n\n @note When a connection attempt fails, the error callback is currently called!"]
pub type tcp_connected_fn = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, tpcb: *mut tcp_pcb, err: err_t) -> err_t,
>;
pub const tcp_state_CLOSED: tcp_state = 0;
pub const tcp_state_LISTEN: tcp_state = 1;
pub const tcp_state_SYN_SENT: tcp_state = 2;
pub const tcp_state_SYN_RCVD: tcp_state = 3;
pub const tcp_state_ESTABLISHED: tcp_state = 4;
pub const tcp_state_FIN_WAIT_1: tcp_state = 5;
pub const tcp_state_FIN_WAIT_2: tcp_state = 6;
pub const tcp_state_CLOSE_WAIT: tcp_state = 7;
pub const tcp_state_CLOSING: tcp_state = 8;
pub const tcp_state_LAST_ACK: tcp_state = 9;
pub const tcp_state_TIME_WAIT: tcp_state = 10;
pub type tcp_state = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_pcb {
    #[doc = " common PCB members"]
    pub local_ip: ip_addr_t,
    #[doc = " common PCB members"]
    pub remote_ip: ip_addr_t,
    #[doc = " common PCB members"]
    pub so_options: u8_t,
    #[doc = " common PCB members"]
    pub tos: u8_t,
    #[doc = " common PCB members"]
    pub ttl: u8_t,
    #[doc = " protocol specific PCB members"]
    pub next: *mut tcp_pcb,
    #[doc = " protocol specific PCB members"]
    pub state: tcp_state,
    #[doc = " protocol specific PCB members"]
    pub prio: u8_t,
    #[doc = " protocol specific PCB members"]
    pub callback_arg: *mut ::core::ffi::c_void,
    #[doc = " protocol specific PCB members"]
    pub accept: tcp_accept_fn,
    #[doc = " protocol specific PCB members"]
    pub local_port: u16_t,
    pub remote_port: u16_t,
    pub flags: u8_t,
    pub rcv_nxt: u32_t,
    pub rcv_wnd: u16_t,
    pub rcv_ann_wnd: u16_t,
    pub rcv_ann_right_edge: u32_t,
    pub tmr: u32_t,
    pub polltmr: u8_t,
    pub pollinterval: u8_t,
    pub rtime: s16_t,
    pub mss: u16_t,
    pub rttest: u32_t,
    pub rtseq: u32_t,
    pub sa: s16_t,
    pub sv: s16_t,
    pub rto: s16_t,
    pub nrtx: u8_t,
    pub lastack: u32_t,
    pub dupacks: u8_t,
    pub cwnd: u16_t,
    pub ssthresh: u16_t,
    pub snd_nxt: u32_t,
    pub snd_wnd: u16_t,
    pub snd_wl1: u32_t,
    pub snd_wl2: u32_t,
    pub snd_lbb: u32_t,
    pub acked: u16_t,
    pub snd_buf: u16_t,
    pub snd_queuelen: u16_t,
    pub unsent_oversize: u16_t,
    pub unsent: *mut tcp_seg,
    pub unacked: *mut tcp_seg,
    pub ooseq: *mut tcp_seg,
    pub refused_data: *mut pbuf,
    pub sent: tcp_sent_fn,
    pub recv: tcp_recv_fn,
    pub connected: tcp_connected_fn,
    pub poll: tcp_poll_fn,
    pub errf: tcp_err_fn,
    pub keep_idle: u32_t,
    pub keep_intvl: u32_t,
    pub keep_cnt: u32_t,
    pub persist_cnt: u32_t,
    pub persist_backoff: u8_t,
    pub keep_cnt_sent: u8_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_pcb_listen {
    pub local_ip: ip_addr_t,
    pub remote_ip: ip_addr_t,
    pub so_options: u8_t,
    pub tos: u8_t,
    pub ttl: u8_t,
    pub next: *mut tcp_pcb_listen,
    pub state: tcp_state,
    pub prio: u8_t,
    pub callback_arg: *mut ::core::ffi::c_void,
    pub accept: tcp_accept_fn,
    pub local_port: u16_t,
}
pub const PT_CHANGE_CIPHER_SPEC: _bindgen_ty_1 = 20;
pub const PT_ALERT_PROTOCOL: _bindgen_ty_1 = 21;
pub const PT_HANDSHAKE_PROTOCOL: _bindgen_ty_1 = 22;
pub const PT_APP_PROTOCOL_DATA: _bindgen_ty_1 = 23;
pub type _bindgen_ty_1 = ::core::ffi::c_uint;
pub const HS_HELLO_REQUEST: _bindgen_ty_2 = 0;
pub const HS_CLIENT_HELLO: _bindgen_ty_2 = 1;
pub const HS_SERVER_HELLO: _bindgen_ty_2 = 2;
pub const HS_CERTIFICATE: _bindgen_ty_2 = 11;
pub const HS_SERVER_KEY_XCHG: _bindgen_ty_2 = 12;
pub const HS_CERT_REQ: _bindgen_ty_2 = 13;
pub const HS_SERVER_HELLO_DONE: _bindgen_ty_2 = 14;
pub const HS_CERT_VERIFY: _bindgen_ty_2 = 15;
pub const HS_CLIENT_KEY_XCHG: _bindgen_ty_2 = 16;
pub const HS_FINISHED: _bindgen_ty_2 = 20;
pub type _bindgen_ty_2 = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cipher_info_t {
    pub cipher: u8,
    pub key_size: u8,
    pub iv_size: u8,
    pub key_block_size: u8,
    pub padding_size: u8,
    pub digest_size: u8,
    pub hmac: hmac_func,
    pub encrypt: crypt_func,
    pub decrypt: crypt_func,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SSLObjLoader {
    pub buf: *mut u8,
    pub len: ::core::ffi::c_int,
}
pub type SSLObjLoader = _SSLObjLoader;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SSL_SESSION {
    pub conn_time: time_t,
    pub session_id: [u8; 32usize],
    pub master_secret: [u8; 48usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SSL_CERT {
    pub buf: *mut u8,
    pub size: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DISPOSABLE_CTX {
    pub md5_ctx: MD5_CTX,
    pub sha1_ctx: SHA1_CTX,
    pub final_finish_mac: [u8; 12usize],
    pub key_block: *mut u8,
    pub master_secret: [u8; 48usize],
    pub client_random: [u8; 32usize],
    pub server_random: [u8; 32usize],
    pub bm_proc_index: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SSL {
    pub flag: u32,
    pub need_bytes: u16,
    pub got_bytes: u16,
    pub record_type: u8,
    pub cipher: u8,
    pub sess_id_size: u8,
    pub version: u8,
    pub client_version: u8,
    pub next_state: sint16_t,
    pub hs_status: sint16_t,
    pub dc: *mut DISPOSABLE_CTX,
    pub SslClient_pcb: *mut tcp_pcb,
    pub reserve: *mut ::core::ffi::c_void,
    pub cipher_info: *const cipher_info_t,
    pub encrypt_ctx: *mut ::core::ffi::c_void,
    pub decrypt_ctx: *mut ::core::ffi::c_void,
    pub bm_all_data: *mut uint8,
    pub bm_data: *mut u8,
    pub bm_index: u16,
    pub bm_read_index: u16,
    pub next: *mut _SSL,
    pub prev: *mut _SSL,
    pub ssl_ctx: *mut _SSL_CTX,
    pub session_index: u16,
    pub session: *mut SSL_SESSION,
    pub session_id: [u8; 32usize],
    pub client_mac: [u8; 20usize],
    pub server_mac: [u8; 20usize],
    pub read_sequence: [u8; 8usize],
    pub write_sequence: [u8; 8usize],
    pub hmac_header: [u8; 5usize],
}
pub type SSL = _SSL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SSL_CTX {
    pub options: u32,
    pub chain_length: u8,
    pub rsa_ctx: *mut RSA_CTX,
    pub head: *mut SSL,
    pub tail: *mut SSL,
    pub certs: [SSL_CERT; 3usize],
    pub num_sessions: u16,
    pub ssl_sessions: *mut *mut SSL_SESSION,
}
pub type SSL_CTX = _SSL_CTX;
pub type SSLCTX = _SSL_CTX;
pub const default_certificate_len: ::core::ffi::c_uint = 475;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::core::ffi::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::core::ffi::c_uint,
    pub __wchb: [::core::ffi::c_char; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::core::ffi::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::core::ffi::c_int,
    pub _IO_read_ptr: *mut ::core::ffi::c_char,
    pub _IO_read_end: *mut ::core::ffi::c_char,
    pub _IO_read_base: *mut ::core::ffi::c_char,
    pub _IO_write_base: *mut ::core::ffi::c_char,
    pub _IO_write_ptr: *mut ::core::ffi::c_char,
    pub _IO_write_end: *mut ::core::ffi::c_char,
    pub _IO_buf_base: *mut ::core::ffi::c_char,
    pub _IO_buf_end: *mut ::core::ffi::c_char,
    pub _IO_save_base: *mut ::core::ffi::c_char,
    pub _IO_backup_base: *mut ::core::ffi::c_char,
    pub _IO_save_end: *mut ::core::ffi::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::core::ffi::c_int,
    pub _flags2: ::core::ffi::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::core::ffi::c_ushort,
    pub _vtable_offset: ::core::ffi::c_schar,
    pub _shortbuf: [::core::ffi::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::core::ffi::c_void,
    pub _prevchain: *mut *mut _IO_FILE,
    pub _mode: ::core::ffi::c_int,
    pub _unused2: [::core::ffi::c_char; 20usize],
}
pub type cookie_read_function_t = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::core::ffi::c_void,
        __buf: *mut ::core::ffi::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::core::ffi::c_void,
        __buf: *const ::core::ffi::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::core::ffi::c_void,
        __pos: *mut __off64_t,
        __w: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
pub type cookie_close_function_t = ::core::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type va_list = __gnuc_va_list;
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
pub const default_private_key_len: ::core::ffi::c_uint = 609;
#[doc = " Callback which is invoked when a hostname is found.\n A function of this type must be implemented by the application using the DNS resolver.\n @param name pointer to the name that was looked up.\n @param ipaddr pointer to an ip_addr_t containing the IP address of the hostname,\n        or NULL if the name could not be found (or on any other error).\n @param callback_arg a user-specified callback argument passed to dns_gethostbyname"]
pub type dns_found_callback = ::core::option::Option<
    unsafe extern "C" fn(
        name: *const ::core::ffi::c_char,
        ipaddr: *mut ip_addr_t,
        callback_arg: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ringbuf_t {
    pub buf: *mut u8,
    pub head: *mut u8,
    pub tail: *mut u8,
    pub size: usize,
}
pub type ringbuf = ringbuf_t;
pub type ringbuf_t_ptr = *mut ringbuf_t;
pub type espconn_handle = *mut ::core::ffi::c_void;
pub type espconn_connect_callback =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void)>;
pub type espconn_reconnect_callback =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, err: sint8)>;
pub const espconn_type_ESPCONN_INVALID: espconn_type = 0;
pub const espconn_type_ESPCONN_TCP: espconn_type = 16;
pub const espconn_type_ESPCONN_UDP: espconn_type = 32;
#[doc = " Protocol family and type of the espconn"]
pub type espconn_type = ::core::ffi::c_uint;
pub const espconn_state_ESPCONN_NONE: espconn_state = 0;
pub const espconn_state_ESPCONN_WAIT: espconn_state = 1;
pub const espconn_state_ESPCONN_LISTEN: espconn_state = 2;
pub const espconn_state_ESPCONN_CONNECT: espconn_state = 3;
pub const espconn_state_ESPCONN_WRITE: espconn_state = 4;
pub const espconn_state_ESPCONN_READ: espconn_state = 5;
pub const espconn_state_ESPCONN_CLOSE: espconn_state = 6;
#[doc = " Current state of the espconn. Non-TCP espconn are always in state ESPCONN_NONE!"]
pub type espconn_state = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _esp_tcp {
    pub remote_port: ::core::ffi::c_int,
    pub local_port: ::core::ffi::c_int,
    pub local_ip: [uint8; 4usize],
    pub remote_ip: [uint8; 4usize],
    pub connect_callback: espconn_connect_callback,
    pub reconnect_callback: espconn_reconnect_callback,
    pub disconnect_callback: espconn_connect_callback,
    pub write_finish_fn: espconn_connect_callback,
}
pub type esp_tcp = _esp_tcp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _esp_udp {
    pub remote_port: ::core::ffi::c_int,
    pub local_port: ::core::ffi::c_int,
    pub local_ip: [uint8; 4usize],
    pub remote_ip: [uint8; 4usize],
}
pub type esp_udp = _esp_udp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _remot_info {
    pub state: espconn_state,
    pub remote_port: ::core::ffi::c_int,
    pub remote_ip: [uint8; 4usize],
}
pub type remot_info = _remot_info;
#[doc = " A callback prototype to inform about events for a espconn"]
pub type espconn_recv_callback = ::core::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::core::ffi::c_void,
        pdata: *mut ::core::ffi::c_char,
        len: ::core::ffi::c_ushort,
    ),
>;
pub type espconn_sent_callback =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void)>;
#[doc = " A espconn descriptor"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct espconn {
    #[doc = " type of the espconn (TCP, UDP)"]
    pub type_: espconn_type,
    #[doc = " current state of the espconn"]
    pub state: espconn_state,
    pub proto: espconn__bindgen_ty_1,
    #[doc = " A callback function that is informed about events for this espconn"]
    pub recv_callback: espconn_recv_callback,
    pub sent_callback: espconn_sent_callback,
    pub link_cnt: uint8,
    pub reverse: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union espconn__bindgen_ty_1 {
    pub tcp: *mut esp_tcp,
    pub udp: *mut esp_udp,
}
pub const espconn_option_ESPCONN_START: espconn_option = 0;
pub const espconn_option_ESPCONN_REUSEADDR: espconn_option = 1;
pub const espconn_option_ESPCONN_NODELAY: espconn_option = 2;
pub const espconn_option_ESPCONN_COPY: espconn_option = 4;
pub const espconn_option_ESPCONN_KEEPALIVE: espconn_option = 8;
pub const espconn_option_ESPCONN_MANUALRECV: espconn_option = 16;
pub const espconn_option_ESPCONN_END: espconn_option = 17;
pub type espconn_option = ::core::ffi::c_uint;
pub const espconn_level_ESPCONN_KEEPIDLE: espconn_level = 0;
pub const espconn_level_ESPCONN_KEEPINTVL: espconn_level = 1;
pub const espconn_level_ESPCONN_KEEPCNT: espconn_level = 2;
pub type espconn_level = ::core::ffi::c_uint;
pub const espconn_mode_ESPCONN_NOMODE: espconn_mode = 0;
pub const espconn_mode_ESPCONN_TCPSERVER_MODE: espconn_mode = 1;
pub const espconn_mode_ESPCONN_TCPCLIENT_MODE: espconn_mode = 2;
pub const espconn_mode_ESPCONN_UDP_MODE: espconn_mode = 3;
pub const espconn_mode_ESPCONN_NUM_MODE: espconn_mode = 4;
pub type espconn_mode = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct espconn_packet {
    pub sent_length: uint16,
    pub snd_buf_size: uint16,
    pub snd_queuelen: uint16,
    pub total_queuelen: uint16,
    pub packseqno: uint32,
    pub packseq_nxt: uint32,
    pub packnum: uint32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _espconn_buf {
    pub payload: *mut uint8,
    pub punsent: *mut uint8,
    pub unsent: uint16,
    pub len: uint16,
    pub tot_len: uint16,
    pub pnext: *mut _espconn_buf,
}
pub type espconn_buf = _espconn_buf;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _comon_pkt {
    pub pcb: *mut ::core::ffi::c_void,
    pub remote_port: ::core::ffi::c_int,
    pub remote_ip: [uint8; 4usize],
    pub local_port: uint32,
    pub local_ip: uint32,
    pub pbuf: *mut espconn_buf,
    pub ptail: *mut espconn_buf,
    pub ptrbuf: *mut uint8,
    pub cntr: uint16,
    pub err: sint8,
    pub timeout: uint32,
    pub recv_check: uint32,
    pub pbuf_num: uint8,
    pub packet_info: espconn_packet,
    pub write_flag: bool_,
    pub espconn_opt: espconn_option,
}
pub type comon_pkt = _comon_pkt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _espconn_msg {
    pub pespconn: *mut espconn,
    pub pcommon: comon_pkt,
    pub count_opt: uint8,
    pub espconn_mode: uint8,
    pub hs_status: sint16_t,
    pub preverse: *mut ::core::ffi::c_void,
    pub pssl: *mut ::core::ffi::c_void,
    pub pnext: *mut _espconn_msg,
    pub recv_hold_flag: uint8,
    pub recv_holded_buf_Len: uint16,
    pub close_flag: uint8,
    pub readbuf: *mut ringbuf,
}
pub type espconn_msg = _espconn_msg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mdns_info {
    pub host_name: *mut ::core::ffi::c_char,
    pub server_name: *mut ::core::ffi::c_char,
    pub server_port: uint16,
    pub ipAddr: ::core::ffi::c_ulong,
    pub txt_data: [*mut ::core::ffi::c_char; 10usize],
}
pub const espconn_sig_SIG_ESPCONN_NONE: espconn_sig = 0;
pub const espconn_sig_SIG_ESPCONN_ERRER: espconn_sig = 1;
pub const espconn_sig_SIG_ESPCONN_LISTEN: espconn_sig = 2;
pub const espconn_sig_SIG_ESPCONN_CONNECT: espconn_sig = 3;
pub const espconn_sig_SIG_ESPCONN_WRITE: espconn_sig = 4;
pub const espconn_sig_SIG_ESPCONN_SEND: espconn_sig = 5;
pub const espconn_sig_SIG_ESPCONN_READ: espconn_sig = 6;
pub const espconn_sig_SIG_ESPCONN_CLOSE: espconn_sig = 7;
pub type espconn_sig = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EspRingBuffer {
    pub buffer: *mut ::core::ffi::c_char,
    pub length: ::core::ffi::c_int,
    pub start: ::core::ffi::c_int,
    pub end: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SSL_RING {
    pub RingBuffer: *mut EspRingBuffer,
    pub RemainLength: uint16,
}
pub type SSL_RING = _SSL_RING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ssl_msg {
    pub ssl_ctx: *mut SSL_CTX,
    pub ssl: *mut SSL,
    pub SSLRing: SSL_RING,
    pub quiet: bool_,
    pub SentFnFlag: bool_,
    pub pkt_length: u16_t,
}
pub type ssl_msg = _ssl_msg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ssl_sector {
    pub sector: uint32,
    pub flag: bool_,
}
pub type ssl_sector = _ssl_sector;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_packet {
    pub pbuffer: *mut uint8,
    pub buffer_size: uint16,
    pub cert_ca_sector: ssl_sector,
    pub cert_req_sector: ssl_sector,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ssl_opt {
    pub server: ssl_packet,
    pub client: ssl_packet,
    pub type_: uint8,
}
pub type ssl_opt = _ssl_opt;
pub const ESPCONN_IDLE: _bindgen_ty_3 = 0;
pub const ESPCONN_CLIENT: _bindgen_ty_3 = 1;
pub const ESPCONN_SERVER: _bindgen_ty_3 = 2;
pub const ESPCONN_BOTH: _bindgen_ty_3 = 3;
pub const ESPCONN_MAX: _bindgen_ty_3 = 4;
pub type _bindgen_ty_3 = ::core::ffi::c_uint;
pub const SIG_ESPCONN_TLS_ERRER: _bindgen_ty_4 = 59;
pub type _bindgen_ty_4 = ::core::ffi::c_uint;
pub const ESPCONN_CERT_REQ: _bindgen_ty_5 = 0;
pub const ESPCONN_CERT_AUTH: _bindgen_ty_5 = 1;
pub type _bindgen_ty_5 = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _file_head {
    pub file_name: [::core::ffi::c_char; 32usize],
    pub file_length: u16,
}
pub type file_head = _file_head;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _file_param {
    pub file_head: file_head,
    pub file_offerset: int32,
}
pub type file_param = _file_param;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udp_pcb {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_seg {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::core::ffi::c_uint,
    pub fp_offset: ::core::ffi::c_uint,
    pub overflow_arg_area: *mut ::core::ffi::c_void,
    pub reg_save_area: *mut ::core::ffi::c_void,
}
extern "C" {
    pub fn AES_set_key(ctx: *mut AES_CTX, key: *const u8, iv: *const u8, mode: AES_MODE);
    pub fn AES_cbc_encrypt(
        ctx: *mut AES_CTX,
        msg: *const u8,
        out: *mut u8,
        length: ::core::ffi::c_int,
    );
    pub fn AES_cbc_decrypt(
        ks: *mut AES_CTX,
        in_: *const u8,
        out: *mut u8,
        length: ::core::ffi::c_int,
    );
    pub fn AES_convert_key(ctx: *mut AES_CTX);
    pub fn RC4_setup(s: *mut RC4_CTX, key: *const u8, length: ::core::ffi::c_int);
    pub fn RC4_crypt(s: *mut RC4_CTX, msg: *const u8, data: *mut u8, length: ::core::ffi::c_int);
    pub fn SHA1_Init(arg1: *mut SHA1_CTX);
    pub fn SHA1_Update(arg1: *mut SHA1_CTX, msg: *const u8, len: ::core::ffi::c_int);
    pub fn SHA1_Final(digest: *mut u8, arg1: *mut SHA1_CTX);
    pub fn SHA256_Init(c: *mut SHA256_CTX);
    pub fn SHA256_Update(arg1: *mut SHA256_CTX, input: *const u8, len: ::core::ffi::c_int);
    pub fn SHA256_Final(digest: *mut u8, arg1: *mut SHA256_CTX);
    pub fn SHA512_Init(c: *mut SHA512_CTX);
    pub fn SHA512_Update(arg1: *mut SHA512_CTX, input: *const u8, len: ::core::ffi::c_int);
    pub fn SHA512_Final(digest: *mut u8, arg1: *mut SHA512_CTX);
    pub fn SHA384_Init(c: *mut SHA384_CTX);
    pub fn SHA384_Update(arg1: *mut SHA384_CTX, input: *const u8, len: ::core::ffi::c_int);
    pub fn SHA384_Final(digest: *mut u8, arg1: *mut SHA384_CTX);
    pub fn MD5_Init(arg1: *mut MD5_CTX);
    pub fn MD5_Update(arg1: *mut MD5_CTX, msg: *const u8, len: ::core::ffi::c_int);
    pub fn MD5_Final(digest: *mut u8, arg1: *mut MD5_CTX);
    #[doc = " HMAC declarations"]
    pub fn ssl_hmac_md5(
        msg: *const u8,
        length: ::core::ffi::c_int,
        key: *const u8,
        key_len: ::core::ffi::c_int,
        digest: *mut u8,
    );
    pub fn ssl_hmac_sha1(
        msg: *const u8,
        length: ::core::ffi::c_int,
        key: *const u8,
        key_len: ::core::ffi::c_int,
        digest: *mut u8,
    );
    pub fn RSA_priv_key_new(
        rsa_ctx: *mut *mut RSA_CTX,
        modulus: *const u8,
        mod_len: ::core::ffi::c_int,
        pub_exp: *const u8,
        pub_len: ::core::ffi::c_int,
        priv_exp: *const u8,
        priv_len: ::core::ffi::c_int,
        p: *const u8,
        p_len: ::core::ffi::c_int,
        q: *const u8,
        q_len: ::core::ffi::c_int,
        dP: *const u8,
        dP_len: ::core::ffi::c_int,
        dQ: *const u8,
        dQ_len: ::core::ffi::c_int,
        qInv: *const u8,
        qInv_len: ::core::ffi::c_int,
    );
    pub fn RSA_pub_key_new(
        rsa_ctx: *mut *mut RSA_CTX,
        modulus: *const u8,
        mod_len: ::core::ffi::c_int,
        pub_exp: *const u8,
        pub_len: ::core::ffi::c_int,
    );
    pub fn RSA_free(ctx: *mut RSA_CTX);
    pub fn RSA_decrypt(
        ctx: *const RSA_CTX,
        in_data: *const u8,
        out_data: *mut u8,
        out_len: ::core::ffi::c_int,
        is_decryption: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn RSA_private(c: *const RSA_CTX, bi_msg: *mut bigint) -> *mut bigint;
    pub fn RSA_sign_verify(
        ctx: *mut BI_CTX,
        sig: *const u8,
        sig_len: ::core::ffi::c_int,
        modulus: *mut bigint,
        pub_exp: *mut bigint,
    ) -> *mut bigint;
    pub fn RSA_public(c: *const RSA_CTX, bi_msg: *mut bigint) -> *mut bigint;
    pub fn RSA_encrypt(
        ctx: *const RSA_CTX,
        in_data: *const u8,
        in_len: u16,
        out_data: *mut u8,
        is_signing: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn RSA_print(ctx: *const RSA_CTX);
    #[doc = " RNG declarations"]
    pub fn RNG_initialize();
    pub fn RNG_custom_init(seed_buf: *const u8, size: ::core::ffi::c_int);
    pub fn RNG_terminate();
    pub fn get_random(num_rand_bytes: ::core::ffi::c_int, rand_data: *mut u8)
        -> ::core::ffi::c_int;
    pub fn get_random_NZ(
        num_rand_bytes: ::core::ffi::c_int,
        rand_data: *mut u8,
    ) -> ::core::ffi::c_int;
    pub fn bi_initialize() -> *mut BI_CTX;
    pub fn bi_terminate(ctx: *mut BI_CTX);
    pub fn bi_permanent(bi: *mut bigint);
    pub fn bi_depermanent(bi: *mut bigint);
    pub fn bi_clear_cache(ctx: *mut BI_CTX);
    pub fn bi_free(ctx: *mut BI_CTX, bi: *mut bigint);
    pub fn bi_copy(bi: *mut bigint) -> *mut bigint;
    pub fn bi_clone(ctx: *mut BI_CTX, bi: *const bigint) -> *mut bigint;
    pub fn bi_export(ctx: *mut BI_CTX, bi: *mut bigint, data: *mut u8, size: ::core::ffi::c_int);
    pub fn bi_import(ctx: *mut BI_CTX, data: *const u8, len: ::core::ffi::c_int) -> *mut bigint;
    pub fn int_to_bi(ctx: *mut BI_CTX, i: comp) -> *mut bigint;
    pub fn bi_add(ctx: *mut BI_CTX, bia: *mut bigint, bib: *mut bigint) -> *mut bigint;
    pub fn bi_subtract(
        ctx: *mut BI_CTX,
        bia: *mut bigint,
        bib: *mut bigint,
        is_negative: *mut ::core::ffi::c_int,
    ) -> *mut bigint;
    pub fn bi_divide(
        ctx: *mut BI_CTX,
        bia: *mut bigint,
        bim: *mut bigint,
        is_mod: ::core::ffi::c_int,
    ) -> *mut bigint;
    pub fn bi_multiply(ctx: *mut BI_CTX, bia: *mut bigint, bib: *mut bigint) -> *mut bigint;
    pub fn bi_mod_power(ctx: *mut BI_CTX, bi: *mut bigint, biexp: *mut bigint) -> *mut bigint;
    pub fn bi_mod_power2(
        ctx: *mut BI_CTX,
        bi: *mut bigint,
        bim: *mut bigint,
        biexp: *mut bigint,
    ) -> *mut bigint;
    pub fn bi_compare(bia: *mut bigint, bib: *mut bigint) -> ::core::ffi::c_int;
    pub fn bi_set_mod(ctx: *mut BI_CTX, bim: *mut bigint, mod_offset: ::core::ffi::c_int);
    pub fn bi_free_mod(ctx: *mut BI_CTX, mod_offset: ::core::ffi::c_int);
    pub fn bi_print(label: *const ::core::ffi::c_char, bi: *mut bigint);
    pub fn bi_str_import(ctx: *mut BI_CTX, data: *const ::core::ffi::c_char) -> *mut bigint;
    pub fn bi_barrett(ctx: *mut BI_CTX, bi: *mut bigint) -> *mut bigint;
    pub fn bi_square(ctx: *mut BI_CTX, bi: *mut bigint) -> *mut bigint;
    pub fn bi_crt(
        ctx: *mut BI_CTX,
        bi: *mut bigint,
        dP: *mut bigint,
        dQ: *mut bigint,
        p: *mut bigint,
        q: *mut bigint,
        qInv: *mut bigint,
    ) -> *mut bigint;
    pub fn memcpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn memmove(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn memccpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn memset(
        __s: *mut ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn memcmp(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
    pub fn __memcmpeq(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: usize,
    ) -> ::core::ffi::c_int;
    pub fn memchr(
        __s: *const ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn strcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
    pub fn strcat(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strncat(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
    pub fn strcmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn strncmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
    pub fn strcoll(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn strxfrm(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
    pub fn strcoll_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __l: locale_t,
    ) -> ::core::ffi::c_int;
    pub fn strxfrm_l(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
    pub fn strdup(__s: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn strndup(
        __string: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
    pub fn strchr(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn strrchr(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn strchrnul(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn strcspn(
        __s: *const ::core::ffi::c_char,
        __reject: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_ulong;
    pub fn strspn(
        __s: *const ::core::ffi::c_char,
        __accept: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_ulong;
    pub fn strpbrk(
        __s: *const ::core::ffi::c_char,
        __accept: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strstr(
        __haystack: *const ::core::ffi::c_char,
        __needle: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strtok(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn __strtok_r(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
        __save_ptr: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strtok_r(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
        __save_ptr: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strcasestr(
        __haystack: *const ::core::ffi::c_char,
        __needle: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn memmem(
        __haystack: *const ::core::ffi::c_void,
        __haystacklen: usize,
        __needle: *const ::core::ffi::c_void,
        __needlelen: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn __mempcpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn mempcpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn strlen(__s: *const ::core::ffi::c_char) -> ::core::ffi::c_ulong;
    pub fn strnlen(__string: *const ::core::ffi::c_char, __maxlen: usize) -> usize;
    pub fn strerror(__errnum: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_char,
        __buflen: usize,
    ) -> ::core::ffi::c_int;
    pub fn strerror_l(__errnum: ::core::ffi::c_int, __l: locale_t) -> *mut ::core::ffi::c_char;
    pub fn bcmp(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
    pub fn bcopy(
        __src: *const ::core::ffi::c_void,
        __dest: *mut ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    );
    pub fn bzero(__s: *mut ::core::ffi::c_void, __n: ::core::ffi::c_ulong);
    pub fn index(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn rindex(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn ffs(__i: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn ffsl(__l: ::core::ffi::c_long) -> ::core::ffi::c_int;
    pub fn ffsll(__ll: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
    pub fn strcasecmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn strncasecmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
    pub fn strcasecmp_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __loc: locale_t,
    ) -> ::core::ffi::c_int;
    pub fn strncasecmp_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::core::ffi::c_int;
    pub fn explicit_bzero(__s: *mut ::core::ffi::c_void, __n: usize);
    pub fn strsep(
        __stringp: *mut *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strsignal(__sig: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
    pub fn __stpcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn stpcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn __stpncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: usize,
    ) -> *mut ::core::ffi::c_char;
    pub fn stpncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
    pub fn strlcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
    pub fn strlcat(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
    pub fn ets_intr_lock();
    pub fn ets_intr_unlock();
    pub fn ets_isr_attach(i: ::core::ffi::c_int, func: ets_isr_t, arg: *mut ::core::ffi::c_void);
    pub fn ets_isr_mask(mask: uint32);
    pub fn ets_isr_unmask(unmask: uint32);
    pub fn NmiTimSetFunc(func: ::core::option::Option<unsafe extern "C" fn()>);
    pub fn ets_bzero(s: *mut ::core::ffi::c_void, n: usize);
    pub fn ets_delay_us(us: u32);
    pub fn ets_install_putc1(
        p: ::core::option::Option<unsafe extern "C" fn(c: ::core::ffi::c_char)>,
    );
    pub fn ets_memcmp(
        str1: *const ::core::ffi::c_void,
        str2: *const ::core::ffi::c_void,
        nbyte: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
    pub fn ets_memcpy(
        dest: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        nbyte: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub fn ets_memmove(
        dest: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        nbyte: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub fn ets_memset(
        dest: *mut ::core::ffi::c_void,
        val: ::core::ffi::c_int,
        nbyte: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub fn ets_strcmp(
        s1: *const ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn ets_strcpy(
        s1: *mut ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn ets_strlen(s: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn ets_strncmp(
        s1: *const ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
        n: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
    pub fn ets_strncpy(
        s1: *mut ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
        n: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_char;
    pub fn ets_strstr(
        s1: *const ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn ets_timer_arm_new(ptimer: *mut ETSTimer, time: u32, repeat_flag: bool_, ms_flag: bool_);
    pub fn ets_timer_disarm(ptimer: *mut ETSTimer);
    pub fn ets_timer_setfn(
        ptimer: *mut ETSTimer,
        pfunction: ETSTimerFunc,
        parg: *mut ::core::ffi::c_void,
    );
    pub fn ets_sprintf(
        str_: *mut ::core::ffi::c_char,
        format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn os_printf_plus(format: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn ets_snprintf(
        str_: *mut ::core::ffi::c_char,
        size: ::core::ffi::c_uint,
        format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn os_random() -> ::core::ffi::c_ulong;
    pub fn os_get_random(buf: *mut ::core::ffi::c_uchar, len: usize) -> ::core::ffi::c_int;
    pub static mut memp_memory_RAW_PCB_base: [u8_t; 0usize];
    pub static mut memp_memory_UDP_PCB_base: [u8_t; 0usize];
    pub static mut memp_memory_TCP_PCB_base: [u8_t; 0usize];
    pub static mut memp_memory_TCP_PCB_LISTEN_base: [u8_t; 0usize];
    pub static mut memp_memory_TCP_SEG_base: [u8_t; 0usize];
    pub static mut memp_memory_SYS_TIMEOUT_base: [u8_t; 0usize];
    pub static mut memp_memory_PBUF_base: [u8_t; 0usize];
    pub static mut memp_memory_PBUF_POOL_base: [u8_t; 0usize];
    pub static ip_addr_any: ip_addr_t;
    pub static ip_addr_broadcast: ip_addr_t;
    pub fn ip4_addr_isbroadcast(addr: u32_t, netif: *const netif) -> u8_t;
    pub fn ip4_addr_netmask_valid(netmask: u32_t) -> u8_t;
    pub fn ipaddr_addr(cp: *const ::core::ffi::c_char) -> u32_t;
    pub fn ipaddr_aton(cp: *const ::core::ffi::c_char, addr: *mut ip_addr_t) -> ::core::ffi::c_int;
    #[doc = " returns ptr to static buffer; not reentrant!"]
    pub fn ipaddr_ntoa(addr: *const ip_addr_t) -> *mut ::core::ffi::c_char;
    pub fn ipaddr_ntoa_r(
        addr: *const ip_addr_t,
        buf: *mut ::core::ffi::c_char,
        buflen: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn clock() -> clock_t;
    pub fn time(__timer: *mut time_t) -> time_t;
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
    pub fn mktime(__tp: *mut tm) -> time_t;
    pub fn strftime(
        __s: *mut ::core::ffi::c_char,
        __maxsize: usize,
        __format: *const ::core::ffi::c_char,
        __tp: *const tm,
    ) -> usize;
    pub fn strftime_l(
        __s: *mut ::core::ffi::c_char,
        __maxsize: usize,
        __format: *const ::core::ffi::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
    pub fn localtime(__timer: *const time_t) -> *mut tm;
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
    pub fn asctime(__tp: *const tm) -> *mut ::core::ffi::c_char;
    pub fn ctime(__timer: *const time_t) -> *mut ::core::ffi::c_char;
    pub fn asctime_r(__tp: *const tm, __buf: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub static mut __tzname: [*mut ::core::ffi::c_char; 2usize];
    pub static mut __daylight: ::core::ffi::c_int;
    pub static mut __timezone: ::core::ffi::c_long;
    pub static mut tzname: [*mut ::core::ffi::c_char; 2usize];
    pub fn tzset();
    pub static mut daylight: ::core::ffi::c_int;
    pub static mut timezone: ::core::ffi::c_long;
    pub fn timegm(__tp: *mut tm) -> time_t;
    pub fn timelocal(__tp: *mut tm) -> time_t;
    pub fn dysize(__year: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::core::ffi::c_int;
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::core::ffi::c_int;
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::core::ffi::c_int;
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::core::ffi::c_int;
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::core::ffi::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::core::ffi::c_int;
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::core::ffi::c_int;
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::core::ffi::c_int;
    pub fn timer_delete(__timerid: timer_t) -> ::core::ffi::c_int;
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::core::ffi::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::core::ffi::c_int;
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::core::ffi::c_int;
    pub fn timer_getoverrun(__timerid: timer_t) -> ::core::ffi::c_int;
    pub fn timespec_get(__ts: *mut timespec, __base: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn sntp_get_timetype() -> bool_;
    pub fn sntp_set_receive_time_size();
    #[doc = " One server address/name can be defined as default if SNTP_SERVER_DNS == 1:\n #define SNTP_SERVER_ADDRESS \"pool.ntp.org\""]
    pub fn sntp_get_current_timestamp() -> uint64;
    pub fn sntp_get_real_time(t: ::core::ffi::c_long) -> *mut ::core::ffi::c_char;
    pub fn sntp_init();
    pub fn sntp_stop();
    pub fn sntp_get_timezone() -> sint8;
    pub fn sntp_set_timezone(timezone: sint8) -> bool_;
    pub fn sntp_setserver(idx: u8_t, addr: *mut ip_addr_t);
    pub fn sntp_getserver(idx: u8_t) -> ip_addr_t;
    pub fn sntp_setservername(idx: u8_t, server: *mut ::core::ffi::c_char);
    pub fn sntp_getservername(idx: u8_t) -> *mut ::core::ffi::c_char;
    pub fn select(
        __nfds: ::core::ffi::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::core::ffi::c_int;
    pub fn pselect(
        __nfds: ::core::ffi::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::core::ffi::c_int;
    pub fn gettimeofday(__tv: *mut timeval, __tz: *mut ::core::ffi::c_void) -> ::core::ffi::c_int;
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone) -> ::core::ffi::c_int;
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval) -> ::core::ffi::c_int;
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval) -> ::core::ffi::c_int;
    pub fn setitimer(
        __which: __itimer_which_t,
        __new: *const itimerval,
        __old: *mut itimerval,
    ) -> ::core::ffi::c_int;
    pub fn utimes(__file: *const ::core::ffi::c_char, __tvp: *const timeval) -> ::core::ffi::c_int;
    pub fn lutimes(__file: *const ::core::ffi::c_char, __tvp: *const timeval)
        -> ::core::ffi::c_int;
    pub fn futimes(__fd: ::core::ffi::c_int, __tvp: *const timeval) -> ::core::ffi::c_int;
    pub fn system_update_rtc(t: time_t, us: u32);
    pub fn sntp_get_rtc_time(us: *mut sint32_t) -> time_t;
    pub fn sntp_update_rtc(sec: time_t, us: u32_t) -> ::core::ffi::c_int;
    pub fn updateTime(ms: uint32);
    pub fn configTime(
        timezone: ::core::ffi::c_int,
        daylightOffset: ::core::ffi::c_int,
        server1: *mut ::core::ffi::c_char,
        server2: *mut ::core::ffi::c_char,
        server3: *mut ::core::ffi::c_char,
        enable: bool_,
    ) -> bool_;
    pub fn millis() -> ::core::ffi::c_ulong;
    pub fn micros() -> ::core::ffi::c_ulong;
    pub fn x509_new(
        cert: *const u8,
        len: *mut ::core::ffi::c_int,
        ctx: *mut *mut X509_CTX,
    ) -> ::core::ffi::c_int;
    pub fn x509_free(x509_ctx: *mut X509_CTX);
    pub fn get_asn1_length(buf: *const u8, offset: *mut ::core::ffi::c_int) -> u32;
    pub fn asn1_get_private_key(
        buf: *const u8,
        len: ::core::ffi::c_int,
        rsa_ctx: *mut *mut RSA_CTX,
    ) -> ::core::ffi::c_int;
    pub fn asn1_next_obj(
        buf: *const u8,
        offset: *mut ::core::ffi::c_int,
        obj_type: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn asn1_skip_obj(
        buf: *const u8,
        offset: *mut ::core::ffi::c_int,
        obj_type: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn asn1_get_int(
        buf: *const u8,
        offset: *mut ::core::ffi::c_int,
        object: *mut *mut u8,
    ) -> ::core::ffi::c_int;
    pub fn asn1_version(
        cert: *const u8,
        offset: *mut ::core::ffi::c_int,
        x509_ctx: *mut X509_CTX,
    ) -> ::core::ffi::c_int;
    pub fn asn1_validity(
        cert: *const u8,
        offset: *mut ::core::ffi::c_int,
        x509_ctx: *mut X509_CTX,
    ) -> ::core::ffi::c_int;
    pub fn asn1_name(
        cert: *const u8,
        offset: *mut ::core::ffi::c_int,
        dn: *mut *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn asn1_public_key(
        cert: *const u8,
        offset: *mut ::core::ffi::c_int,
        x509_ctx: *mut X509_CTX,
    ) -> ::core::ffi::c_int;
    pub fn asn1_signature_type(
        cert: *const u8,
        offset: *mut ::core::ffi::c_int,
        x509_ctx: *mut X509_CTX,
    ) -> ::core::ffi::c_int;
    pub static unsupported_str: *const ::core::ffi::c_char;
    pub fn get_file(filename: *const ::core::ffi::c_char, buf: *mut *mut u8) -> ::core::ffi::c_int;
    pub fn print_blob(
        format: *const ::core::ffi::c_char,
        data: *const u8,
        size: ::core::ffi::c_int,
        ...
    );
    pub fn base64_decode(
        in_: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
        out: *mut u8,
        outlen: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn sys_init();
    #[doc = " Ticks/jiffies since power up."]
    pub fn sys_jiffies() -> u32_t;
    pub fn pvPortMalloc(
        sz: usize,
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
        arg3: bool_,
    ) -> *mut ::core::ffi::c_void;
    pub fn vPortFree(
        p: *mut ::core::ffi::c_void,
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
    );
    pub fn pvPortZalloc(
        sz: usize,
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub fn pvPortRealloc(
        p: *mut ::core::ffi::c_void,
        n: usize,
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub fn pvPortCalloc(
        count: usize,
        size: usize,
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub fn pvPortCallocIram(
        count: usize,
        size: usize,
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub fn pvPortZallocIram(
        sz: usize,
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub fn pbuf_alloc(l: pbuf_layer, length: u16_t, type_: pbuf_type) -> *mut pbuf;
    pub fn pbuf_realloc(p: *mut pbuf, size: u16_t);
    pub fn pbuf_header(p: *mut pbuf, header_size: s16_t) -> u8_t;
    pub fn pbuf_ref(p: *mut pbuf);
    pub fn pbuf_free(p: *mut pbuf) -> u8_t;
    pub fn pbuf_clen(p: *mut pbuf) -> u8_t;
    pub fn pbuf_cat(head: *mut pbuf, tail: *mut pbuf);
    pub fn pbuf_chain(head: *mut pbuf, tail: *mut pbuf);
    pub fn pbuf_dechain(p: *mut pbuf) -> *mut pbuf;
    pub fn pbuf_copy(p_to: *mut pbuf, p_from: *mut pbuf) -> err_t;
    pub fn pbuf_copy_partial(
        p: *mut pbuf,
        dataptr: *mut ::core::ffi::c_void,
        len: u16_t,
        offset: u16_t,
    ) -> u16_t;
    pub fn pbuf_take(buf: *mut pbuf, dataptr: *const ::core::ffi::c_void, len: u16_t) -> err_t;
    pub fn pbuf_coalesce(p: *mut pbuf, layer: pbuf_layer) -> *mut pbuf;
    pub fn pbuf_get_at(p: *mut pbuf, offset: u16_t) -> u8_t;
    pub fn pbuf_memcmp(
        p: *mut pbuf,
        offset: u16_t,
        s2: *const ::core::ffi::c_void,
        n: u16_t,
    ) -> u16_t;
    pub fn pbuf_memfind(
        p: *mut pbuf,
        mem: *const ::core::ffi::c_void,
        mem_len: u16_t,
        start_offset: u16_t,
    ) -> u16_t;
    pub fn pbuf_strstr(p: *mut pbuf, substr: *const ::core::ffi::c_char) -> u16_t;
    #[doc = " The list of network interfaces."]
    pub static mut netif_list: *mut netif;
    #[doc = " The default network interface."]
    pub static mut netif_default: *mut netif;
    pub fn netif_init();
    pub fn netif_add(
        netif: *mut netif,
        ipaddr: *mut ip_addr_t,
        netmask: *mut ip_addr_t,
        gw: *mut ip_addr_t,
        state: *mut ::core::ffi::c_void,
        init: netif_init_fn,
        input: netif_input_fn,
    ) -> *mut netif;
    pub fn netif_set_addr(
        netif: *mut netif,
        ipaddr: *mut ip_addr_t,
        netmask: *mut ip_addr_t,
        gw: *mut ip_addr_t,
    );
    pub fn netif_remove(netif: *mut netif);
    pub fn netif_find(name: *mut ::core::ffi::c_char) -> *mut netif;
    pub fn netif_set_default(netif: *mut netif);
    pub fn netif_set_ipaddr(netif: *mut netif, ipaddr: *mut ip_addr_t);
    pub fn netif_set_netmask(netif: *mut netif, netmask: *mut ip_addr_t);
    pub fn netif_set_gw(netif: *mut netif, gw: *mut ip_addr_t);
    pub fn netif_set_up(netif: *mut netif);
    pub fn netif_set_down(netif: *mut netif);
    pub fn netif_set_link_up(netif: *mut netif);
    pub fn netif_set_link_down(netif: *mut netif);
    #[doc = " The interface that provided the packet for the current callback invocation."]
    pub static mut current_netif: *mut netif;
    #[doc = " Header of the input packet currently being processed."]
    pub static mut current_header: *const ip_hdr;
    #[doc = " Source IP address of current_header"]
    pub static mut current_iphdr_src: ip_addr_t;
    #[doc = " Destination IP address of current_header"]
    pub static mut current_iphdr_dest: ip_addr_t;
    pub fn ip_route(dest: *mut ip_addr_t) -> *mut netif;
    pub fn ip_router(dest: *mut ip_addr_t, source: *mut ip_addr_t) -> *mut netif;
    pub fn ip_input(p: *mut pbuf, inp: *mut netif) -> err_t;
    pub fn ip_output(
        p: *mut pbuf,
        src: *mut ip_addr_t,
        dest: *mut ip_addr_t,
        ttl: u8_t,
        tos: u8_t,
        proto: u8_t,
    ) -> err_t;
    pub fn ip_output_if(
        p: *mut pbuf,
        src: *mut ip_addr_t,
        dest: *mut ip_addr_t,
        ttl: u8_t,
        tos: u8_t,
        proto: u8_t,
        netif: *mut netif,
    ) -> err_t;
    pub fn ip_output_if_opt(
        p: *mut pbuf,
        src: *mut ip_addr_t,
        dest: *mut ip_addr_t,
        ttl: u8_t,
        tos: u8_t,
        proto: u8_t,
        netif: *mut netif,
        ip_options: *mut ::core::ffi::c_void,
        optlen: u16_t,
    ) -> err_t;
    pub fn icmp_input(p: *mut pbuf, inp: *mut netif);
    pub fn icmp_dest_unreach(p: *mut pbuf, t: icmp_dur_type);
    pub fn icmp_time_exceeded(p: *mut pbuf, t: icmp_te_type);
    pub fn tcp_new() -> *mut tcp_pcb;
    pub fn tcp_arg(pcb: *mut tcp_pcb, arg: *mut ::core::ffi::c_void);
    pub fn tcp_accept(pcb: *mut tcp_pcb, accept: tcp_accept_fn);
    pub fn tcp_recv(pcb: *mut tcp_pcb, recv: tcp_recv_fn);
    pub fn tcp_sent(pcb: *mut tcp_pcb, sent: tcp_sent_fn);
    pub fn tcp_poll(pcb: *mut tcp_pcb, poll: tcp_poll_fn, interval: u8_t);
    pub fn tcp_err(pcb: *mut tcp_pcb, err: tcp_err_fn);
    pub fn tcp_recved(pcb: *mut tcp_pcb, len: u16_t);
    pub fn tcp_bind(pcb: *mut tcp_pcb, ipaddr: *mut ip_addr_t, port: u16_t) -> err_t;
    pub fn tcp_connect(
        pcb: *mut tcp_pcb,
        ipaddr: *mut ip_addr_t,
        port: u16_t,
        connected: tcp_connected_fn,
    ) -> err_t;
    pub fn tcp_listen_with_backlog(pcb: *mut tcp_pcb, backlog: u8_t) -> *mut tcp_pcb;
    pub fn tcp_abort(pcb: *mut tcp_pcb);
    pub fn tcp_close(pcb: *mut tcp_pcb) -> err_t;
    pub fn tcp_shutdown(
        pcb: *mut tcp_pcb,
        shut_rx: ::core::ffi::c_int,
        shut_tx: ::core::ffi::c_int,
    ) -> err_t;
    pub fn tcp_write(
        pcb: *mut tcp_pcb,
        dataptr: *const ::core::ffi::c_void,
        len: u16_t,
        apiflags: u8_t,
    ) -> err_t;
    pub fn tcp_setprio(pcb: *mut tcp_pcb, prio: u8_t);
    pub fn tcp_output(pcb: *mut tcp_pcb) -> err_t;
    pub fn tcp_debug_state_str(s: tcp_state) -> *const ::core::ffi::c_char;
    pub static ssl_prot_prefs: [u8; 4usize];
    pub fn ssl_new(ssl_ctx: *mut SSL_CTX, client_fd: ::core::ffi::c_int) -> *mut SSL;
    pub fn ssl_new_context(ssl_ctx: *mut SSL_CTX, SslClient_pcb: *mut tcp_pcb) -> *mut SSL;
    pub fn disposable_new(ssl: *mut SSL);
    pub fn disposable_free(ssl: *mut SSL);
    pub fn send_packet(
        ssl: *mut SSL,
        protocol: u8,
        in_: *const u8,
        length: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn do_svr_handshake(
        ssl: *mut SSL,
        handshake_type: ::core::ffi::c_int,
        buf: *mut u8,
        hs_len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn do_clnt_handshake(
        ssl: *mut SSL,
        handshake_type: ::core::ffi::c_int,
        buf: *mut u8,
        hs_len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn process_finished(
        ssl: *mut SSL,
        buf: *mut u8,
        hs_len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn process_sslv23_client_hello(ssl: *mut SSL) -> ::core::ffi::c_int;
    pub fn send_alert(ssl: *mut SSL, error_code: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn send_finished(ssl: *mut SSL) -> ::core::ffi::c_int;
    pub fn send_certificate(ssl: *mut SSL) -> ::core::ffi::c_int;
    pub fn basic_read(ssl: *mut SSL, in_data: *mut *mut u8) -> ::core::ffi::c_int;
    pub fn send_change_cipher_spec(ssl: *mut SSL) -> ::core::ffi::c_int;
    pub fn finished_digest(ssl: *mut SSL, label: *const ::core::ffi::c_char, digest: *mut u8);
    pub fn generate_master_secret(ssl: *mut SSL, premaster_secret: *const u8);
    pub fn add_packet(ssl: *mut SSL, pkt: *const u8, len: ::core::ffi::c_int);
    pub fn add_cert(
        ssl_ctx: *mut SSL_CTX,
        buf: *const u8,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn add_private_key(ssl_ctx: *mut SSL_CTX, ssl_obj: *mut SSLObjLoader)
        -> ::core::ffi::c_int;
    pub fn ssl_obj_free(ssl_obj: *mut SSLObjLoader);
    pub fn pkcs8_decode(
        ssl_ctx: *mut SSL_CTX,
        ssl_obj: *mut SSLObjLoader,
        password: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn pkcs12_decode(
        ssl_ctx: *mut SSL_CTX,
        ssl_obj: *mut SSLObjLoader,
        password: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn load_key_certs(ssl_ctx: *mut SSL_CTX) -> ::core::ffi::c_int;
    pub fn ssl_session_update(
        max_sessions: ::core::ffi::c_int,
        ssl_sessions: *mut *mut SSL_SESSION,
        ssl: *mut SSL,
        session_id: *const u8,
    ) -> *mut SSL_SESSION;
    pub fn kill_ssl_session(ssl_sessions: *mut *mut SSL_SESSION, ssl: *mut SSL);
    #[doc = " @brief Establish a new client/server context.\n\n This function is called before any client/server SSL connections are made.\n\n Each new connection will use the this context's private key and\n certificate chain. If a different certificate chain is required, then a\n different context needs to be be used.\n\n There are two threading models supported - a single thread with one\n SSL_CTX can support any number of SSL connections - and multiple threads can\n support one SSL_CTX object each (the default). But if a single SSL_CTX\n object uses many SSL objects in individual threads, then the\n CONFIG_SSL_CTX_MUTEXING option needs to be configured.\n\n @param options [in]  Any particular options. At present the options\n supported are:\n - SSL_SERVER_VERIFY_LATER (client only): Don't stop a handshake if the server\n authentication fails. The certificate can be authenticated later with a\n call to ssl_verify_cert().\n - SSL_CLIENT_AUTHENTICATION (server only): Enforce client authentication\n i.e. each handshake will include a \"certificate request\" message from the\n server. Only available if verification has been enabled.\n - SSL_DISPLAY_BYTES (full mode build only): Display the byte sequences\n during the handshake.\n - SSL_DISPLAY_STATES (full mode build only): Display the state changes\n during the handshake.\n - SSL_DISPLAY_CERTS (full mode build only): Display the certificates that\n are passed during a handshake.\n - SSL_DISPLAY_RSA (full mode build only): Display the RSA key details that\n are passed during a handshake.\n - SSL_CONNECT_IN_PARTS (client only): To use a non-blocking version of\n ssl_client_new().\n @param num_sessions [in] The number of sessions to be used for session\n caching. If this value is 0, then there is no session caching. This option\n is not used in skeleton mode.\n @return A client/server context."]
    pub fn ssl_ctx_new(options: u32, num_sessions: ::core::ffi::c_int) -> *mut SSL_CTX;
    #[doc = " @brief Remove a client/server context.\n\n Frees any used resources used by this context. Each connection will be\n sent a \"Close Notify\" alert (if possible).\n @param ssl_ctx [in] The client/server context."]
    pub fn ssl_ctx_free(ssl_ctx: *mut SSL_CTX);
    pub fn sslserver_new(ssl_ctx: *mut SSL_CTX, client_pcb: *mut tcp_pcb) -> *mut SSL;
    pub fn SSLClient_new(
        ssl_ctx: *mut SSL_CTX,
        SslClient_pcb: *mut tcp_pcb,
        session_id: *const u8,
        sess_id_size: u8,
    ) -> *mut SSL;
    #[doc = " @brief Free any used resources on this connection.\n\n A \"Close Notify\" message is sent on this connection (if possible). It is up\n to the application to close the socket or file descriptor.\n @param ssl [in] The ssl object reference."]
    pub fn ssl_free(ssl: *mut SSL);
    #[doc = " @brief Read the SSL data stream.\n If the socket is non-blocking and data is blocked then SSO_OK will be\n returned.\n @param ssl [in] An SSL object reference.\n @param in_data [out] If the read was successful, a pointer to the read\n buffer will be here. Do NOT ever free this memory as this buffer is used in\n sucessive calls. If the call was unsuccessful, this value will be null.\n @return The number of decrypted bytes:\n - if > 0, then the handshaking is complete and we are returning the number\n   of decrypted bytes.\n - SSL_OK if the handshaking stage is successful (but not yet complete).\n - < 0 if an error.\n @see ssl.h for the error code list.\n @note Use in_data before doing any successive ssl calls."]
    pub fn ssl_read(ssl: *mut SSL, in_data: *mut *mut u8) -> ::core::ffi::c_int;
    #[doc = " @brief Write to the SSL data stream.\n if the socket is non-blocking and data is blocked then a check is made\n to ensure that all data is sent (i.e. blocked mode is forced).\n @param ssl [in] An SSL obect reference.\n @param out_data [in] The data to be written\n @param out_len [in] The number of bytes to be written.\n @return The number of bytes sent, or if < 0 if an error.\n @see ssl.h for the error code list."]
    pub fn ssl_write(
        ssl: *mut SSL,
        out_data: *const u8,
        out_len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Find an ssl object based on a file descriptor.\n\n Goes through the list of SSL objects maintained in a client/server context\n to look for a file descriptor match.\n @param ssl_ctx [in] The client/server context.\n @param client_fd [in]  The file descriptor.\n @return A reference to the SSL object. Returns null if the object could not\n be found."]
    pub fn ssl_find(ssl_ctx: *mut SSL_CTX, client_fd: ::core::ffi::c_int) -> *mut SSL;
    #[doc = " @brief Get the session id for a handshake.\n\n This will be a 32 byte sequence and is available after the first\n handshaking messages are sent.\n @param ssl [in] An SSL object reference.\n @return The session id as a 32 byte sequence.\n @note A SSLv23 handshake may have only 16 valid bytes."]
    pub fn ssl_get_session_id(ssl: *const SSL) -> *const u8;
    #[doc = " @brief Get the session id size for a handshake.\n\n This will normally be 32 but could be 0 (no session id) or something else.\n @param ssl [in] An SSL object reference.\n @return The size of the session id."]
    pub fn ssl_get_session_id_size(ssl: *const SSL) -> u8;
    #[doc = " @brief Return the cipher id (in the SSL form).\n @param ssl [in] An SSL object reference.\n @return The cipher id. This will be one of the following:\n - SSL_AES128_SHA (0x2f)\n - SSL_AES256_SHA (0x35)\n - SSL_RC4_128_SHA (0x05)\n - SSL_RC4_128_MD5 (0x04)"]
    pub fn ssl_get_cipher_id(ssl: *const SSL) -> u8;
    #[doc = " @brief Return the status of the handshake.\n @param ssl [in] An SSL object reference.\n @return SSL_OK if the handshake is complete and ok.\n @see ssl.h for the error code list."]
    pub fn ssl_handshake_status(ssl: *const SSL) -> ::core::ffi::c_int;
    #[doc = " @brief Retrieve various parameters about the axTLS engine.\n @param offset [in] The configuration offset. It will be one of the following:\n - SSL_BUILD_MODE The build mode. This will be one of the following:\n   - SSL_BUILD_SERVER_ONLY            (basic server mode)\n   - SSL_BUILD_ENABLE_VERIFICATION    (server can do client authentication)\n   - SSL_BUILD_ENABLE_CLIENT          (client/server capabilties)\n   - SSL_BUILD_FULL_MODE              (client/server with diagnostics)\n   - SSL_BUILD_SKELETON_MODE          (skeleton mode)\n - SSL_MAX_CERT_CFG_OFFSET The maximum number of certificates allowed.\n - SSL_MAX_CA_CERT_CFG_OFFSET The maximum number of CA certificates allowed.\n - SSL_HAS_PEM                        1 if supported\n @return The value of the requested parameter."]
    pub fn ssl_get_config(offset: ::core::ffi::c_int) -> ::core::ffi::c_int;
    #[doc = " @brief Authenticate a received certificate.\n\n This call is usually made by a client after a handshake is complete and the\n context is in SSL_SERVER_VERIFY_LATER mode.\n @param ssl [in] An SSL object reference.\n @return SSL_OK if the certificate is verified."]
    pub fn ssl_verify_cert(ssl: *const SSL) -> ::core::ffi::c_int;
    #[doc = " @brief Retrieve an X.509 distinguished name component.\n\n When a handshake is complete and a certificate has been exchanged, then the\n details of the remote certificate can be retrieved.\n\n This will usually be used by a client to check that the server's common\n name matches the URL.\n\n @param ssl [in] An SSL object reference.\n @param component [in] one of:\n - SSL_X509_CERT_COMMON_NAME\n - SSL_X509_CERT_ORGANIZATION\n - SSL_X509_CERT_ORGANIZATIONAL_NAME\n - SSL_X509_CA_CERT_COMMON_NAME\n - SSL_X509_CA_CERT_ORGANIZATION\n - SSL_X509_CA_CERT_ORGANIZATIONAL_NAME\n @return The appropriate string (or null if not defined)\n @note Verification build mode must be enabled."]
    pub fn ssl_get_cert_dn(
        ssl: *const SSL,
        component: ::core::ffi::c_int,
    ) -> *const ::core::ffi::c_char;
    #[doc = " @brief Retrieve a Subject Alternative DNSName\n\n When a handshake is complete and a certificate has been exchanged, then the\n details of the remote certificate can be retrieved.\n\n This will usually be used by a client to check that the server's DNS\n name matches the URL.\n\n @param ssl [in] An SSL object reference.\n @param dnsindex [in] The index of the DNS name to retrieve.\n @return The appropriate string (or null if not defined)\n @note Verification build mode must be enabled."]
    pub fn ssl_get_cert_subject_alt_dnsname(
        ssl: *const SSL,
        dnsindex: ::core::ffi::c_int,
    ) -> *const ::core::ffi::c_char;
    #[doc = " @brief Force the client to perform its handshake again.\n\n For a client this involves sending another \"client hello\" message.\n For the server is means sending a \"hello request\" message.\n\n This is a blocking call on the client (until the handshake completes).\n\n @param ssl [in] An SSL object reference.\n @return SSL_OK if renegotiation instantiation was ok"]
    pub fn ssl_renegotiate(ssl: *mut SSL) -> ::core::ffi::c_int;
    #[doc = " @brief Process a file that is in binary DER or ASCII PEM format.\n\n These are temporary objects that are used to load private keys,\n certificates etc into memory.\n @param ssl_ctx [in] The client/server context.\n @param obj_type [in] The format of the file. Can be one of:\n - SSL_OBJ_X509_CERT (no password required)\n - SSL_OBJ_X509_CACERT (no password required)\n - SSL_OBJ_RSA_KEY (AES128/AES256 PEM encryption supported)\n - SSL_OBJ_PKCS8 (RC4-128 encrypted data supported)\n - SSL_OBJ_PKCS12 (RC4-128 encrypted data supported)\n\n PEM files are automatically detected (if supported). The object type is\n also detected, and so is not relevant for these types of files.\n @param filename [in] The location of a file in DER/PEM format.\n @param password [in] The password used. Can be null if not required.\n @return SSL_OK if all ok\n @note Not available in skeleton build mode."]
    pub fn ssl_obj_load(
        ssl_ctx: *mut SSL_CTX,
        obj_type: ::core::ffi::c_int,
        filename: *const ::core::ffi::c_char,
        password: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Process binary data.\n\n These are temporary objects that are used to load private keys,\n certificates etc into memory.\n @param ssl_ctx [in] The client/server context.\n @param obj_type [in] The format of the memory data.\n @param data [in] The binary data to be loaded.\n @param len [in] The amount of data to be loaded.\n @param password [in] The password used. Can be null if not required.\n @return SSL_OK if all ok\n @see ssl_obj_load for more details on obj_type."]
    pub fn ssl_obj_memory_load(
        ssl_ctx: *mut SSL_CTX,
        obj_type: ::core::ffi::c_int,
        data: *const u8,
        len: ::core::ffi::c_int,
        password: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Return the axTLS library version as a string."]
    pub fn ssl_version() -> *const ::core::ffi::c_char;
    pub static mut default_certificate: [::core::ffi::c_uchar; 475usize];
    pub static mut stdin: *mut FILE;
    pub static mut stdout: *mut FILE;
    pub static mut stderr: *mut FILE;
    pub fn remove(__filename: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn rename(
        __old: *const ::core::ffi::c_char,
        __new: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn renameat(
        __oldfd: ::core::ffi::c_int,
        __old: *const ::core::ffi::c_char,
        __newfd: ::core::ffi::c_int,
        __new: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn fclose(__stream: *mut FILE) -> ::core::ffi::c_int;
    pub fn tmpfile() -> *mut FILE;
    pub fn tmpnam(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn tmpnam_r(__s: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn tempnam(
        __dir: *const ::core::ffi::c_char,
        __pfx: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn fflush(__stream: *mut FILE) -> ::core::ffi::c_int;
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;
    pub fn fopen(
        __filename: *const ::core::ffi::c_char,
        __modes: *const ::core::ffi::c_char,
    ) -> *mut FILE;
    pub fn freopen(
        __filename: *const ::core::ffi::c_char,
        __modes: *const ::core::ffi::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
    pub fn fdopen(__fd: ::core::ffi::c_int, __modes: *const ::core::ffi::c_char) -> *mut FILE;
    pub fn fopencookie(
        __magic_cookie: *mut ::core::ffi::c_void,
        __modes: *const ::core::ffi::c_char,
        __io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
    pub fn fmemopen(
        __s: *mut ::core::ffi::c_void,
        __len: usize,
        __modes: *const ::core::ffi::c_char,
    ) -> *mut FILE;
    pub fn open_memstream(
        __bufloc: *mut *mut ::core::ffi::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::core::ffi::c_char);
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::core::ffi::c_char,
        __modes: ::core::ffi::c_int,
        __n: usize,
    ) -> ::core::ffi::c_int;
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::core::ffi::c_char, __size: usize);
    pub fn setlinebuf(__stream: *mut FILE);
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn printf(__format: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn sprintf(
        __s: *mut ::core::ffi::c_char,
        __format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
    pub fn vprintf(
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
    pub fn vsprintf(
        __s: *mut ::core::ffi::c_char,
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
    pub fn snprintf(
        __s: *mut ::core::ffi::c_char,
        __maxlen: ::core::ffi::c_ulong,
        __format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn vsnprintf(
        __s: *mut ::core::ffi::c_char,
        __maxlen: ::core::ffi::c_ulong,
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
    pub fn vasprintf(
        __ptr: *mut *mut ::core::ffi::c_char,
        __f: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
    pub fn __asprintf(
        __ptr: *mut *mut ::core::ffi::c_char,
        __fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn asprintf(
        __ptr: *mut *mut ::core::ffi::c_char,
        __fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn vdprintf(
        __fd: ::core::ffi::c_int,
        __fmt: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
    pub fn dprintf(
        __fd: ::core::ffi::c_int,
        __fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn scanf(__format: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn sscanf(
        __s: *const ::core::ffi::c_char,
        __format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::core::ffi::c_char,
        __format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
    pub fn vscanf(
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
    pub fn vsscanf(
        __s: *const ::core::ffi::c_char,
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::core::ffi::c_char,
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
    pub fn fgetc(__stream: *mut FILE) -> ::core::ffi::c_int;
    pub fn getc(__stream: *mut FILE) -> ::core::ffi::c_int;
    pub fn getchar() -> ::core::ffi::c_int;
    pub fn getc_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;
    pub fn getchar_unlocked() -> ::core::ffi::c_int;
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;
    pub fn fputc(__c: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;
    pub fn putc(__c: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;
    pub fn putchar(__c: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn fputc_unlocked(__c: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;
    pub fn putc_unlocked(__c: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;
    pub fn putchar_unlocked(__c: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn getw(__stream: *mut FILE) -> ::core::ffi::c_int;
    pub fn putw(__w: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;
    pub fn fgets(
        __s: *mut ::core::ffi::c_char,
        __n: ::core::ffi::c_int,
        __stream: *mut FILE,
    ) -> *mut ::core::ffi::c_char;
    pub fn __getdelim(
        __lineptr: *mut *mut ::core::ffi::c_char,
        __n: *mut usize,
        __delimiter: ::core::ffi::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
    pub fn getdelim(
        __lineptr: *mut *mut ::core::ffi::c_char,
        __n: *mut usize,
        __delimiter: ::core::ffi::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
    pub fn getline(
        __lineptr: *mut *mut ::core::ffi::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
    pub fn fputs(__s: *const ::core::ffi::c_char, __stream: *mut FILE) -> ::core::ffi::c_int;
    pub fn puts(__s: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn ungetc(__c: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;
    pub fn fread(
        __ptr: *mut ::core::ffi::c_void,
        __size: ::core::ffi::c_ulong,
        __n: ::core::ffi::c_ulong,
        __stream: *mut FILE,
    ) -> ::core::ffi::c_ulong;
    pub fn fwrite(
        __ptr: *const ::core::ffi::c_void,
        __size: ::core::ffi::c_ulong,
        __n: ::core::ffi::c_ulong,
        __s: *mut FILE,
    ) -> ::core::ffi::c_ulong;
    pub fn fread_unlocked(
        __ptr: *mut ::core::ffi::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
    pub fn fwrite_unlocked(
        __ptr: *const ::core::ffi::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::core::ffi::c_long,
        __whence: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn ftell(__stream: *mut FILE) -> ::core::ffi::c_long;
    pub fn rewind(__stream: *mut FILE);
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn ftello(__stream: *mut FILE) -> __off_t;
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::core::ffi::c_int;
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::core::ffi::c_int;
    pub fn clearerr(__stream: *mut FILE);
    pub fn feof(__stream: *mut FILE) -> ::core::ffi::c_int;
    pub fn ferror(__stream: *mut FILE) -> ::core::ffi::c_int;
    pub fn clearerr_unlocked(__stream: *mut FILE);
    pub fn feof_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;
    pub fn perror(__s: *const ::core::ffi::c_char);
    pub fn fileno(__stream: *mut FILE) -> ::core::ffi::c_int;
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;
    pub fn pclose(__stream: *mut FILE) -> ::core::ffi::c_int;
    pub fn popen(
        __command: *const ::core::ffi::c_char,
        __modes: *const ::core::ffi::c_char,
    ) -> *mut FILE;
    pub fn ctermid(__s: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn flockfile(__stream: *mut FILE);
    pub fn ftrylockfile(__stream: *mut FILE) -> ::core::ffi::c_int;
    pub fn funlockfile(__stream: *mut FILE);
    pub fn __uflow(arg1: *mut FILE) -> ::core::ffi::c_int;
    pub fn __overflow(arg1: *mut FILE, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub static mut default_private_key: [::core::ffi::c_uchar; 609usize];
    pub fn dns_init();
    pub fn dns_tmr();
    pub fn dns_setserver(numdns: u8_t, dnsserver: *mut ip_addr_t);
    pub fn dns_getserver(numdns: u8_t) -> ip_addr_t;
    pub fn dns_gethostbyname(
        hostname: *const ::core::ffi::c_char,
        addr: *mut ip_addr_t,
        found: dns_found_callback,
        callback_arg: *mut ::core::ffi::c_void,
    ) -> err_t;
    pub fn ringbuf_new(capacity: usize) -> ringbuf_t_ptr;
    pub fn ringbuf_buffer_size(rb: *const ringbuf_t) -> usize;
    pub fn ringbuf_reset(rb: ringbuf_t_ptr);
    pub fn ringbuf_free(rb: *mut ringbuf_t_ptr);
    pub fn ringbuf_capacity(rb: *const ringbuf_t) -> usize;
    pub fn ringbuf_bytes_free(rb: *const ringbuf_t) -> usize;
    pub fn ringbuf_bytes_used(rb: *const ringbuf_t) -> usize;
    pub fn ringbuf_is_full(rb: *const ringbuf_t) -> ::core::ffi::c_int;
    pub fn ringbuf_is_empty(rb: *const ringbuf_t) -> ::core::ffi::c_int;
    pub fn ringbuf_tail(rb: *const ringbuf_t) -> *const ::core::ffi::c_void;
    pub fn ringbuf_head(rb: *const ringbuf_t) -> *const ::core::ffi::c_void;
    pub fn ringbuf_findchr(rb: *const ringbuf_t, c: ::core::ffi::c_int, offset: usize) -> usize;
    pub fn ringbuf_memset(dst: ringbuf_t_ptr, c: ::core::ffi::c_int, len: usize) -> usize;
    pub fn ringbuf_memcpy_into(
        dst: ringbuf_t_ptr,
        src: *const ::core::ffi::c_void,
        count: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn ringbuf_memcpy_from(
        dst: *mut ::core::ffi::c_void,
        src: ringbuf_t_ptr,
        count: usize,
    ) -> *mut ::core::ffi::c_void;
    #[doc = " FunctionName : espconn_copy_partial\n Description  : reconnect with host\n Parameters   : arg -- Additional argument to pass to the callback function\n Returns      : none"]
    pub fn espconn_copy_partial(pesp_dest: *mut espconn, pesp_source: *mut espconn);
    #[doc = " FunctionName : espconn_copy_partial\n Description  : insert the node to the active connection list\n Parameters   : arg -- Additional argument to pass to the callback function\n Returns      : none"]
    pub fn espconn_list_creat(phead: *mut *mut espconn_msg, pinsert: *mut espconn_msg);
    #[doc = " FunctionName : espconn_list_delete\n Description  : remove the node from the active connection list\n Parameters   : arg -- Additional argument to pass to the callback function\n Returns      : none"]
    pub fn espconn_list_delete(phead: *mut *mut espconn_msg, pdelete: *mut espconn_msg);
    #[doc = " FunctionName : espconn_find_connection\n Description  : Initialize the server: set up a listening PCB and bind it to\n                the defined port\n Parameters   : espconn -- the espconn used to build server\n Returns      : none"]
    pub fn espconn_find_connection(pespconn: *mut espconn, pnode: *mut *mut espconn_msg) -> bool_;
    #[doc = " FunctionName : espconn_get_connection_info\n Description  : used to specify the function that should be called when disconnect\n Parameters   : espconn -- espconn to set the err callback\n                discon_cb -- err callback function to call when err\n Returns      : none"]
    pub fn espconn_get_connection_info(
        pespconn: *mut espconn,
        pcon_info: *mut *mut remot_info,
        typeflags: uint8,
    ) -> sint8;
    #[doc = " FunctionName : espconn_get_packet_info\n Description  : get the packet info with host\n Parameters   : espconn -- the espconn used to disconnect the connection\n \t\t\t\t  infoarg -- the packet info\n Returns      : the errur code"]
    pub fn espconn_get_packet_info(espconn: *mut espconn, infoarg: *mut espconn_packet) -> sint8;
    #[doc = " FunctionName : espconn_connect\n Description  : The function given as the connect\n Parameters   : espconn -- the espconn used to listen the connection\n Returns      : none"]
    pub fn espconn_connect(espconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_disconnect\n Description  : disconnect with host\n Parameters   : espconn -- the espconn used to disconnect the connection\n Returns      : none"]
    pub fn espconn_disconnect(espconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_delete\n Description  : disconnect with host\n Parameters   : espconn -- the espconn used to disconnect the connection\n Returns      : none"]
    pub fn espconn_delete(espconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_accept\n Description  : The function given as the listen\n Parameters   : espconn -- the espconn used to listen the connection\n Returns      : none"]
    pub fn espconn_accept(espconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_create\n Description  : sent data for client or server\n Parameters   : espconn -- espconn to the data transmission\n Returns      : result"]
    pub fn espconn_create(espconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_tcp_get_wnd\n Description  : get the window size of simulatenously active TCP connections\n Parameters   : none\n Returns      : the number of TCP_MSS active TCP connections"]
    pub fn espconn_tcp_get_wnd() -> uint8;
    #[doc = " FunctionName : espconn_tcp_set_max_con\n Description  : set the window size simulatenously active TCP connections\n Parameters   : num -- the number of TCP_MSS\n Returns      : ESPCONN_ARG -- Illegal argument\n \t\t\t\t  ESPCONN_OK  -- No error"]
    pub fn espconn_tcp_set_wnd(num: uint8) -> sint8;
    #[doc = " FunctionName : espconn_tcp_get_max_con\n Description  : get the number of simulatenously active TCP connections\n Parameters   : none\n Returns      : none"]
    pub fn espconn_tcp_get_max_con() -> uint8;
    #[doc = " FunctionName : espconn_tcp_set_max_con\n Description  : set the number of simulatenously active TCP connections\n Parameters   : num -- total number\n Returns      : none"]
    pub fn espconn_tcp_set_max_con(num: uint8) -> sint8;
    #[doc = " FunctionName : espconn_tcp_get_max_retran\n Description  : get the Maximum number of retransmissions of data active TCP connections\n Parameters   : none\n Returns      : the Maximum number of retransmissions"]
    pub fn espconn_tcp_get_max_retran() -> uint8;
    #[doc = " FunctionName : espconn_tcp_set_max_retran\n Description  : set the Maximum number of retransmissions of data active TCP connections\n Parameters   : num -- the Maximum number of retransmissions\n Returns      : result"]
    pub fn espconn_tcp_set_max_retran(num: uint8) -> sint8;
    #[doc = " FunctionName : espconn_tcp_get_max_syn\n Description  : get the Maximum number of retransmissions of SYN segments\n Parameters   : none\n Returns      : the Maximum number of retransmissions"]
    pub fn espconn_tcp_get_max_syn() -> uint8;
    #[doc = " FunctionName : espconn_tcp_set_max_syn\n Description  : set the Maximum number of retransmissions of SYN segments\n Parameters   : num -- the Maximum number of retransmissions\n Returns      : result"]
    pub fn espconn_tcp_set_max_syn(num: uint8) -> sint8;
    #[doc = " FunctionName : espconn_tcp_get_max_con_allow\n Description  : get the count of simulatenously active connections on the server\n Parameters   : espconn -- espconn to get the count\n Returns      : result"]
    pub fn espconn_tcp_get_max_con_allow(espconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_tcp_set_max_con_allow\n Description  : set the count of simulatenously active connections on the server\n Parameters   : espconn -- espconn to set the count\n Returns      : result"]
    pub fn espconn_tcp_set_max_con_allow(espconn: *mut espconn, num: uint8) -> sint8;
    #[doc = " FunctionName : espconn_tcp_set_buf_count\n Description  : set the total number of espconn_buf on the unsent lists\n Parameters   : espconn -- espconn to set the count\n \t\t\t\t  num -- the total number of espconn_buf\n Returns      : result"]
    pub fn espconn_tcp_set_buf_count(espconn: *mut espconn, num: uint8) -> sint8;
    #[doc = " FunctionName : espconn_regist_time\n Description  : used to specify the time that should be called when don't recv data\n Parameters   : espconn -- the espconn used to the connection\n \t\t\t\t  interval -- the timer when don't recv data\n Returns      : none"]
    pub fn espconn_regist_time(espconn: *mut espconn, interval: uint32, type_flag: uint8) -> sint8;
    #[doc = " FunctionName : espconn_regist_sentcb\n Description  : Used to specify the function that should be called when data\n \t\t\t\t  has been successfully delivered to the remote host.\n Parameters   : struct espconn *espconn -- espconn to set the sent callback\n \t\t\t\t  espconn_sent_callback sent_cb -- sent callback function to\n \t\t\t\t  call for this espconn when data is successfully sent\n Returns      : none"]
    pub fn espconn_regist_sentcb(espconn: *mut espconn, sent_cb: espconn_sent_callback) -> sint8;
    #[doc = " FunctionName : espconn_regist_sentcb\n Description  : Used to specify the function that should be called when data\n                has been successfully delivered to the remote host.\n Parameters   : espconn -- espconn to set the sent callback\n                sent_cb -- sent callback function to call for this espconn\n                when data is successfully sent\n Returns      : none"]
    pub fn espconn_regist_write_finish(
        espconn: *mut espconn,
        write_finish_fn: espconn_connect_callback,
    ) -> sint8;
    #[doc = " FunctionName : espconn_sent\n Description  : sent data for client or server\n Parameters   : espconn -- espconn to set for client or server\n \t\t\t\t  psent -- data to send\n                length -- length of data to send\n Returns      : none"]
    pub fn espconn_sent(espconn: *mut espconn, psent: *mut uint8, length: uint16) -> sint8;
    #[doc = " FunctionName : espconn_regist_connectcb\n Description  : used to specify the function that should be called when\n \t\t\t\t  connects to host.\n Parameters   : espconn -- espconn to set the connect callback\n \t\t\t\t  connect_cb -- connected callback function to call when connected\n Returns      : none"]
    pub fn espconn_regist_connectcb(
        espconn: *mut espconn,
        connect_cb: espconn_connect_callback,
    ) -> sint8;
    #[doc = " FunctionName : espconn_regist_recvcb\n Description  : used to specify the function that should be called when recv\n \t\t\t\t  data from host.\n Parameters   : espconn -- espconn to set the recv callback\n \t\t\t\t  recv_cb -- recv callback function to call when recv data\n Returns      : none"]
    pub fn espconn_regist_recvcb(espconn: *mut espconn, recv_cb: espconn_recv_callback) -> sint8;
    #[doc = " FunctionName : espconn_regist_reconcb\n Description  : used to specify the function that should be called when connection\n \t\t\t\t  because of err disconnect.\n Parameters   : espconn -- espconn to set the err callback\n \t\t\t\t  recon_cb -- err callback function to call when err\n Returns      : none"]
    pub fn espconn_regist_reconcb(
        espconn: *mut espconn,
        recon_cb: espconn_reconnect_callback,
    ) -> sint8;
    #[doc = " FunctionName : espconn_regist_disconcb\n Description  : used to specify the function that should be called when disconnect\n Parameters   : espconn -- espconn to set the err callback\n                discon_cb -- err callback function to call when err\n Returns      : none"]
    pub fn espconn_regist_disconcb(
        espconn: *mut espconn,
        discon_cb: espconn_connect_callback,
    ) -> sint8;
    #[doc = " FunctionName : espconn_port\n Description  : access port value for client so that we don't end up bouncing\n                all connections at the same time .\n Parameters   : none\n Returns      : access port value"]
    pub fn espconn_port() -> uint32;
    #[doc = " FunctionName : espconn_set_opt\n Description  : access port value for client so that we don't end up bouncing\n                all connections at the same time .\n Parameters   : none\n Returns      : access port value"]
    pub fn espconn_set_opt(espconn: *mut espconn, opt: uint8) -> sint8;
    #[doc = " FunctionName : espconn_set_keepalive\n Description  : access level value for connection so that we set the value for\n \t\t\t\t  keep alive\n Parameters   : espconn -- the espconn used to set the connection\n \t\t\t\t  level -- the connection's level\n \t\t\t\t  value -- the value of time(s)\n Returns      : access port value"]
    pub fn espconn_set_keepalive(
        espconn: *mut espconn,
        level: uint8,
        optarg: *mut ::core::ffi::c_void,
    ) -> sint8;
    #[doc = " FunctionName : espconn_get_keepalive\n Description  : access level value for connection so that we get the value for\n \t\t\t\t  keep alive\n Parameters   : espconn -- the espconn used to get the connection\n \t\t\t\t  level -- the connection's level\n Returns      : access keep alive value"]
    pub fn espconn_get_keepalive(
        espconn: *mut espconn,
        level: uint8,
        optarg: *mut ::core::ffi::c_void,
    ) -> sint8;
    #[doc = " FunctionName : espconn_gethostbyname\n Description  : Resolve a hostname (string) into an IP address.\n Parameters   : pespconn -- espconn to resolve a hostname\n                hostname -- the hostname that is to be queried\n                addr -- pointer to a ip_addr_t where to store the address if\n                        it is already cached in the dns_table (only valid if\n                        ESPCONN_OK is returned!)\n                found -- a callback function to be called on success, failure\n                         or timeout (only if ERR_INPROGRESS is returned!)\n Returns      : err_t return code\n                - ESPCONN_OK if hostname is a valid IP address string or the host\n                  name is already in the local names table.\n                - ESPCONN_INPROGRESS enqueue a request to be sent to the DNS server\n                  for resolution if no errors are present.\n                - ESPCONN_ARG: dns client not initialized or invalid hostname"]
    pub fn espconn_gethostbyname(
        pespconn: *mut espconn,
        name: *const ::core::ffi::c_char,
        addr: *mut ip_addr_t,
        found: dns_found_callback,
    ) -> err_t;
    #[doc = " FunctionName : espconn_igmp_join\n Description  : join a multicast group\n Parameters   : host_ip -- the ip address of udp server\n \t\t\t\t  multicast_ip -- multicast ip given by user\n Returns      : none"]
    pub fn espconn_igmp_join(host_ip: *mut ip_addr_t, multicast_ip: *mut ip_addr_t) -> sint8;
    #[doc = " FunctionName : espconn_igmp_leave\n Description  : leave a multicast group\n Parameters   : host_ip -- the ip address of udp server\n \t\t\t\t  multicast_ip -- multicast ip given by user\n Returns      : none"]
    pub fn espconn_igmp_leave(host_ip: *mut ip_addr_t, multicast_ip: *mut ip_addr_t) -> sint8;
    #[doc = " FunctionName : espconn_mdns_init\n Description  : register a device with mdns\n Parameters   : ipAddr -- the ip address of device\n \t\t\t\t  hostname -- the hostname of device\n Returns      : none"]
    pub fn espconn_mdns_init(info: *mut mdns_info);
    #[doc = " FunctionName : espconn_mdns_init\n Description  : close mdns socket\n Parameters   : void\n Returns      : none"]
    pub fn espconn_mdns_close();
    #[doc = " FunctionName : mdns_server_register\n Description  : register a server and join a multicast group\n Parameters   : none\n Returns      : none"]
    pub fn espconn_mdns_server_register();
    #[doc = " FunctionName : mdns_server_register\n Description  : unregister server and leave multicast group\n Parameters   : none\n Returns      : none"]
    pub fn espconn_mdns_server_unregister();
    #[doc = " FunctionName : espconn_mdns_get_servername\n Description  : get server name\n Parameters   : none\n Returns      : server name"]
    pub fn espconn_mdns_get_servername() -> *mut ::core::ffi::c_char;
    #[doc = " FunctionName : espconn_mdns_get_servername\n Description  : set server name\n Parameters   : server name\n Returns      : none"]
    pub fn espconn_mdns_set_servername(name: *const ::core::ffi::c_char);
    #[doc = " FunctionName : espconn_mdns_set_hostname\n Description  : set host name\n Parameters   : host name\n Returns      : none"]
    pub fn espconn_mdns_set_hostname(name: *mut ::core::ffi::c_char);
    #[doc = " FunctionName : espconn_mdns_init\n Description  : get host name\n Parameters   : void\n Returns      : hostname"]
    pub fn espconn_mdns_get_hostname() -> *mut ::core::ffi::c_char;
    #[doc = " FunctionName : espconn_mdns_disable\n Description  : join a multicast group\n Parameters   : host_ip -- the ip address of udp server\n \t\t\t\t  multicast_ip -- multicast ip given by user\n Returns      : none"]
    pub fn espconn_mdns_disable();
    #[doc = " FunctionName : espconn_mdns_enable\n Description  : enable mdns\n Parameters   : void\n Returns      : none"]
    pub fn espconn_mdns_enable();
    #[doc = " FunctionName : espconn_dns_setserver\n Description  : Initialize one of the DNS servers.\n Parameters   : numdns -- the index of the DNS server to set must\n \t\t\t\t  be < DNS_MAX_SERVERS = 2\n \t\t\t      dnsserver -- IP address of the DNS server to set\n  Returns     : none"]
    pub fn espconn_dns_setserver(numdns: u8_t, dnsserver: *mut ip_addr_t);
    #[doc = " FunctionName : espconn_dns_getserver\n Description  : get dns server.\n Parameters   : numdns -- the index of the DNS server ,must\n \t\t\t\t  be < DNS_MAX_SERVERS = 2\n  Returns     : dnsserver -- struct ip_addr_t"]
    pub fn espconn_dns_getserver(numdns: u8_t) -> ip_addr_t;
    pub fn EspRingBuffer_full(buffer: *mut EspRingBuffer) -> ::core::ffi::c_int;
    pub fn EspRingBuffer_empty(buffer: *mut EspRingBuffer) -> ::core::ffi::c_int;
    pub fn EspRingBuffer_available_data(buffer: *mut EspRingBuffer) -> ::core::ffi::c_int;
    pub fn EspRingBuffer_available_space(buffer: *mut EspRingBuffer) -> ::core::ffi::c_int;
    pub static mut ssl_option: ssl_opt;
    #[doc = " FunctionName : sslserver_start\n Description  : Initialize the server: set up a listen PCB and bind it to\n                the defined port\n Parameters   : espconn -- the espconn used to build client\n Returns      : none"]
    pub fn espconn_ssl_server(espconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_ssl_client\n Description  : Initialize the client: set up a connect PCB and bind it to\n                the defined port\n Parameters   : espconn -- the espconn used to build client\n Returns      : none"]
    pub fn espconn_ssl_client(espconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_ssl_write\n Description  : sent data for client or server\n Parameters   : void *arg -- client or server to send\n \t\t\t\t  uint8* psent -- Data to send\n                uint16 length -- Length of data to send\n Returns      : none"]
    pub fn espconn_ssl_sent(arg: *mut ::core::ffi::c_void, psent: *mut uint8, length: uint16);
    #[doc = " FunctionName : espconn_ssl_disconnect\n Description  : A new incoming connection has been disconnected.\n Parameters   : espconn -- the espconn used to disconnect with host\n Returns      : none"]
    pub fn espconn_ssl_disconnect(pdis: *mut espconn_msg);
    #[doc = " FunctionName : espconn_secure_get_size\n Description  : get buffer size for client or server\n Parameters   : level -- set for client or server\n\t\t\t\t  1: client,2:server,3:client and server\n Returns      : buffer size for client or server"]
    pub fn espconn_secure_get_size(level: uint8) -> sint16;
    #[doc = " FunctionName : espconn_encry_connect\n Description  : The function given as connection\n Parameters   : espconn -- the espconn used to connect with the host\n Returns      : none"]
    pub fn espconn_secure_connect(espconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_encry_disconnect\n Description  : The function given as the disconnection\n Parameters   : espconn -- the espconn used to disconnect with the host\n Returns      : none"]
    pub fn espconn_secure_disconnect(espconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_encry_sent\n Description  : sent data for client or server\n Parameters   : espconn -- espconn to set for client or server\n \t\t\t\t  psent -- data to send\n                length -- length of data to send\n Returns      : none"]
    pub fn espconn_secure_sent(espconn: *mut espconn, psent: *mut uint8, length: uint16) -> sint8;
    #[doc = " FunctionName : espconn_secure_accept\n Description  : The function given as the listen\n Parameters   : espconn -- the espconn used to listen the connection\n Returns      : none"]
    pub fn espconn_secure_accept(espconn: *mut espconn) -> sint8;
}
