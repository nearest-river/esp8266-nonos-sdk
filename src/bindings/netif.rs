/* automatically generated by rust-bindgen 0.71.1 */

#[doc = r" If Bindgen could only determine the size and alignment of a"]
#[doc = r" type, it is represented like this."]
#[derive(PartialEq, Copy, Clone, Debug, Hash)]
#[repr(C)]
pub struct __BindgenOpaqueArray<T: Copy, const N: usize>(pub [T; N]);
impl<T: Copy + Default, const N: usize> Default for __BindgenOpaqueArray<T, N> {
    fn default() -> Self {
        Self([<T as Default>::default(); N])
    }
}
pub const ESP_SYSTEM_APP: u32 = 1;
pub const SYS_LIGHTWEIGHT_PROT: u32 = 0;
pub const NO_SYS: u32 = 1;
pub const NO_SYS_NO_TIMERS: u32 = 0;
pub const MEM_LIBC_MALLOC: u32 = 1;
pub const MEMP_MEM_MALLOC: u32 = 1;
pub const MEM_ALIGNMENT: u32 = 4;
pub const MEM_SIZE: u32 = 16000;
pub const MEMP_SEPARATE_POOLS: u32 = 1;
pub const MEMP_OVERFLOW_CHECK: u32 = 0;
pub const MEMP_SANITY_CHECK: u32 = 1;
pub const MEM_USE_POOLS: u32 = 0;
pub const MEM_USE_POOLS_TRY_BIGGER_POOL: u32 = 0;
pub const MEMP_USE_CUSTOM_POOLS: u32 = 0;
pub const LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT: u32 = 0;
pub const MEMP_NUM_PBUF: u32 = 10;
pub const MEMP_NUM_RAW_PCB: u32 = 4;
pub const MEMP_NUM_UDP_PCB: u32 = 4;
pub const MEMP_NUM_TCP_PCB_LISTEN: u32 = 2;
pub const MEMP_NUM_TCP_SEG: u32 = 16;
pub const MEMP_NUM_REASSDATA: u32 = 0;
pub const MEMP_NUM_FRAG_PBUF: u32 = 0;
pub const MEMP_NUM_ARP_QUEUE: u32 = 10;
pub const MEMP_NUM_IGMP_GROUP: u32 = 8;
pub const MEMP_NUM_SYS_TIMEOUT: u32 = 8;
pub const MEMP_NUM_NETBUF: u32 = 0;
pub const MEMP_NUM_NETCONN: u32 = 0;
pub const MEMP_NUM_TCPIP_MSG_API: u32 = 4;
pub const MEMP_NUM_TCPIP_MSG_INPKT: u32 = 4;
pub const MEMP_NUM_SNMP_NODE: u32 = 0;
pub const MEMP_NUM_SNMP_ROOTNODE: u32 = 0;
pub const MEMP_NUM_SNMP_VARBIND: u32 = 0;
pub const MEMP_NUM_SNMP_VALUE: u32 = 0;
pub const MEMP_NUM_NETDB: u32 = 0;
pub const MEMP_NUM_LOCALHOSTLIST: u32 = 0;
pub const MEMP_NUM_PPPOE_INTERFACES: u32 = 0;
pub const PBUF_POOL_SIZE: u32 = 10;
pub const LWIP_ARP: u32 = 1;
pub const ARP_TABLE_SIZE: u32 = 10;
pub const ARP_QUEUEING: u32 = 1;
pub const ETHARP_TRUST_IP_MAC: u32 = 0;
pub const ETHARP_SUPPORT_VLAN: u32 = 0;
pub const ETH_PAD_SIZE: u32 = 0;
pub const ETHARP_SUPPORT_STATIC_ENTRIES: u32 = 0;
pub const IP_FORWARD: u32 = 0;
pub const IP_OPTIONS_ALLOWED: u32 = 1;
pub const IP_REASSEMBLY: u32 = 0;
pub const IP_FRAG: u32 = 0;
pub const IP_REASS_MAXAGE: u32 = 3;
pub const IP_REASS_MAX_PBUFS: u32 = 10;
pub const IP_FRAG_USES_STATIC_BUF: u32 = 1;
pub const IP_FRAG_MAX_MTU: u32 = 1500;
pub const IP_DEFAULT_TTL: u32 = 128;
pub const IP_SOF_BROADCAST: u32 = 0;
pub const IP_SOF_BROADCAST_RECV: u32 = 0;
pub const LWIP_ICMP: u32 = 1;
pub const ICMP_TTL: u32 = 128;
pub const LWIP_BROADCAST_PING: u32 = 0;
pub const LWIP_MULTICAST_PING: u32 = 0;
pub const LWIP_RAW: u32 = 1;
pub const RAW_TTL: u32 = 128;
pub const LWIP_DHCP: u32 = 1;
pub const LWIP_AUTOIP: u32 = 0;
pub const LWIP_DHCP_AUTOIP_COOP: u32 = 0;
pub const LWIP_DHCP_AUTOIP_COOP_TRIES: u32 = 9;
pub const LWIP_SNMP: u32 = 0;
pub const SNMP_CONCURRENT_REQUESTS: u32 = 0;
pub const SNMP_TRAP_DESTINATIONS: u32 = 0;
pub const SNMP_PRIVATE_MIB: u32 = 0;
pub const SNMP_SAFE_REQUESTS: u32 = 0;
pub const SNMP_MAX_OCTET_STRING_LEN: u32 = 127;
pub const SNMP_MAX_TREE_DEPTH: u32 = 15;
pub const LWIP_IGMP: u32 = 1;
pub const LWIP_MDNS: u32 = 1;
pub const LWIP_DNS: u32 = 1;
pub const DNS_TABLE_SIZE: u32 = 4;
pub const DNS_MAX_NAME_LENGTH: u32 = 256;
pub const DNS_MAX_SERVERS: u32 = 2;
pub const DNS_DOES_NAME_CHECK: u32 = 1;
pub const DNS_MSG_SIZE: u32 = 512;
pub const DNS_LOCAL_HOSTLIST: u32 = 0;
pub const DNS_LOCAL_HOSTLIST_IS_DYNAMIC: u32 = 0;
pub const LWIP_UDP: u32 = 1;
pub const LWIP_UDPLITE: u32 = 0;
pub const UDP_TTL: u32 = 128;
pub const LWIP_NETBUF_RECVINFO: u32 = 0;
pub const LWIP_TCP: u32 = 1;
pub const TCP_TTL: u32 = 128;
pub const TCP_MAXRTO: u32 = 10;
pub const TCP_MINRTO: u32 = 2;
pub const TCP_QUEUE_OOSEQ: u32 = 1;
pub const TCP_MSS: u32 = 1460;
pub const TCP_CALCULATE_EFF_SEND_MSS: u32 = 1;
pub const TCP_SND_BUF: u32 = 2920;
pub const TCP_SND_QUEUELEN: u32 = 8;
pub const TCP_SNDLOWAT: u32 = 1460;
pub const TCP_LISTEN_BACKLOG: u32 = 0;
pub const TCP_DEFAULT_LISTEN_BACKLOG: u32 = 255;
pub const TCP_OVERSIZE: u32 = 1460;
pub const LWIP_TCP_TIMESTAMPS: u32 = 0;
pub const LWIP_EVENT_API: u32 = 0;
pub const LWIP_CALLBACK_API: u32 = 1;
pub const PBUF_LINK_HLEN: u32 = 14;
pub const LWIP_NETIF_HOSTNAME: u32 = 1;
pub const LWIP_NETIF_API: u32 = 0;
pub const LWIP_NETIF_STATUS_CALLBACK: u32 = 0;
pub const LWIP_NETIF_LINK_CALLBACK: u32 = 0;
pub const LWIP_NETIF_HWADDRHINT: u32 = 0;
pub const LWIP_NETIF_LOOPBACK: u32 = 0;
pub const LWIP_LOOPBACK_MAX_PBUFS: u32 = 0;
pub const LWIP_NETIF_TX_SINGLE_PBUF: u32 = 1;
pub const LWIP_HAVE_LOOPIF: u32 = 0;
pub const LWIP_HAVE_SLIPIF: u32 = 0;
pub const TCPIP_THREAD_NAME: &[u8; 13] = b"tcpip_thread\0";
pub const TCPIP_THREAD_STACKSIZE: u32 = 0;
pub const TCPIP_THREAD_PRIO: u32 = 1;
pub const TCPIP_MBOX_SIZE: u32 = 0;
pub const SLIPIF_THREAD_NAME: &[u8; 12] = b"slipif_loop\0";
pub const SLIPIF_THREAD_STACKSIZE: u32 = 0;
pub const SLIPIF_THREAD_PRIO: u32 = 1;
pub const PPP_THREAD_NAME: &[u8; 15] = b"pppInputThread\0";
pub const PPP_THREAD_STACKSIZE: u32 = 0;
pub const PPP_THREAD_PRIO: u32 = 1;
pub const DEFAULT_THREAD_NAME: &[u8; 5] = b"lwIP\0";
pub const DEFAULT_THREAD_STACKSIZE: u32 = 0;
pub const DEFAULT_THREAD_PRIO: u32 = 1;
pub const DEFAULT_RAW_RECVMBOX_SIZE: u32 = 0;
pub const DEFAULT_UDP_RECVMBOX_SIZE: u32 = 0;
pub const DEFAULT_TCP_RECVMBOX_SIZE: u32 = 0;
pub const DEFAULT_ACCEPTMBOX_SIZE: u32 = 0;
pub const LWIP_TCPIP_CORE_LOCKING: u32 = 0;
pub const LWIP_TCPIP_CORE_LOCKING_INPUT: u32 = 0;
pub const LWIP_NETCONN: u32 = 0;
pub const LWIP_TCPIP_TIMEOUT: u32 = 1;
pub const LWIP_SOCKET: u32 = 0;
pub const LWIP_COMPAT_SOCKETS: u32 = 0;
pub const LWIP_POSIX_SOCKETS_IO_NAMES: u32 = 0;
pub const LWIP_TCP_KEEPALIVE: u32 = 1;
pub const LWIP_SO_RCVTIMEO: u32 = 0;
pub const LWIP_SO_RCVBUF: u32 = 0;
pub const SO_REUSE: u32 = 0;
pub const SO_REUSE_RXTOALL: u32 = 0;
pub const LWIP_STATS: u32 = 0;
pub const ETHARP_STATS: u32 = 0;
pub const LINK_STATS: u32 = 0;
pub const IP_STATS: u32 = 0;
pub const IPFRAG_STATS: u32 = 0;
pub const ICMP_STATS: u32 = 0;
pub const IGMP_STATS: u32 = 0;
pub const UDP_STATS: u32 = 0;
pub const TCP_STATS: u32 = 0;
pub const MEM_STATS: u32 = 0;
pub const MEMP_STATS: u32 = 0;
pub const SYS_STATS: u32 = 0;
pub const LWIP_STATS_DISPLAY: u32 = 0;
pub const PPP_SUPPORT: u32 = 0;
pub const PPPOE_SUPPORT: u32 = 0;
pub const PPPOS_SUPPORT: u32 = 0;
pub const CHECKSUM_GEN_IP: u32 = 1;
pub const CHECKSUM_GEN_UDP: u32 = 1;
pub const CHECKSUM_GEN_TCP: u32 = 1;
pub const CHECKSUM_CHECK_IP: u32 = 1;
pub const CHECKSUM_CHECK_UDP: u32 = 1;
pub const CHECKSUM_CHECK_TCP: u32 = 1;
pub const LWIP_CHECKSUM_ON_COPY: u32 = 0;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const BIT31: u32 = 2147483648;
pub const BIT30: u32 = 1073741824;
pub const BIT29: u32 = 536870912;
pub const BIT28: u32 = 268435456;
pub const BIT27: u32 = 134217728;
pub const BIT26: u32 = 67108864;
pub const BIT25: u32 = 33554432;
pub const BIT24: u32 = 16777216;
pub const BIT23: u32 = 8388608;
pub const BIT22: u32 = 4194304;
pub const BIT21: u32 = 2097152;
pub const BIT20: u32 = 1048576;
pub const BIT19: u32 = 524288;
pub const BIT18: u32 = 262144;
pub const BIT17: u32 = 131072;
pub const BIT16: u32 = 65536;
pub const BIT15: u32 = 32768;
pub const BIT14: u32 = 16384;
pub const BIT13: u32 = 8192;
pub const BIT12: u32 = 4096;
pub const BIT11: u32 = 2048;
pub const BIT10: u32 = 1024;
pub const BIT9: u32 = 512;
pub const BIT8: u32 = 256;
pub const BIT7: u32 = 128;
pub const BIT6: u32 = 64;
pub const BIT5: u32 = 32;
pub const BIT4: u32 = 16;
pub const BIT3: u32 = 8;
pub const BIT2: u32 = 4;
pub const BIT1: u32 = 2;
pub const BIT0: u32 = 1;
pub const APB_CLK_FREQ: u32 = 80000000;
pub const UART_CLK_FREQ: u32 = 80000000;
pub const TIMER_CLK_FREQ: u32 = 312500;
pub const PERIPHS_DPORT_BASEADDR: u32 = 1072693248;
pub const PERIPHS_GPIO_BASEADDR: u32 = 1610613504;
pub const PERIPHS_TIMER_BASEDDR: u32 = 1610614272;
pub const PERIPHS_RTC_BASEADDR: u32 = 1610614528;
pub const PERIPHS_IO_MUX: u32 = 1610614784;
pub const EDGE_INT_ENABLE_REG: u32 = 1072693252;
pub const GPIO_OUT_ADDRESS: u32 = 0;
pub const GPIO_OUT_W1TS_ADDRESS: u32 = 4;
pub const GPIO_OUT_W1TC_ADDRESS: u32 = 8;
pub const GPIO_ENABLE_ADDRESS: u32 = 12;
pub const GPIO_ENABLE_W1TS_ADDRESS: u32 = 16;
pub const GPIO_ENABLE_W1TC_ADDRESS: u32 = 20;
pub const GPIO_OUT_W1TC_DATA_MASK: u32 = 65535;
pub const GPIO_IN_ADDRESS: u32 = 24;
pub const GPIO_STATUS_ADDRESS: u32 = 28;
pub const GPIO_STATUS_W1TS_ADDRESS: u32 = 32;
pub const GPIO_STATUS_W1TC_ADDRESS: u32 = 36;
pub const GPIO_STATUS_INTERRUPT_MASK: u32 = 65535;
pub const GPIO_RTC_CALIB_SYNC: u32 = 1610613612;
pub const RTC_CALIB_START: u32 = 2147483648;
pub const RTC_PERIOD_NUM_MASK: u32 = 1023;
pub const GPIO_RTC_CALIB_VALUE: u32 = 1610613616;
pub const RTC_CALIB_RDY_S: u32 = 31;
pub const RTC_CALIB_VALUE_MASK: u32 = 1048575;
pub const GPIO_PIN0_ADDRESS: u32 = 40;
pub const GPIO_ID_PIN0: u32 = 0;
pub const GPIO_ID_NONE: u32 = 4294967295;
pub const GPIO_PIN_COUNT: u32 = 16;
pub const GPIO_PIN_CONFIG_MSB: u32 = 12;
pub const GPIO_PIN_CONFIG_LSB: u32 = 11;
pub const GPIO_PIN_CONFIG_MASK: u32 = 6144;
pub const GPIO_WAKEUP_ENABLE: u32 = 1;
pub const GPIO_WAKEUP_DISABLE: i32 = -2;
pub const GPIO_PIN_WAKEUP_ENABLE_MSB: u32 = 10;
pub const GPIO_PIN_WAKEUP_ENABLE_LSB: u32 = 10;
pub const GPIO_PIN_WAKEUP_ENABLE_MASK: u32 = 1024;
pub const GPIO_PIN_INT_TYPE_MASK: u32 = 896;
pub const GPIO_PIN_INT_TYPE_MSB: u32 = 9;
pub const GPIO_PIN_INT_TYPE_LSB: u32 = 7;
pub const GPIO_PAD_DRIVER_ENABLE: u32 = 1;
pub const GPIO_PAD_DRIVER_DISABLE: i32 = -2;
pub const GPIO_PIN_PAD_DRIVER_MSB: u32 = 2;
pub const GPIO_PIN_PAD_DRIVER_LSB: u32 = 2;
pub const GPIO_PIN_PAD_DRIVER_MASK: u32 = 4;
pub const GPIO_AS_PIN_SOURCE: u32 = 0;
pub const SIGMA_AS_PIN_SOURCE: i32 = -1;
pub const GPIO_PIN_SOURCE_MSB: u32 = 0;
pub const GPIO_PIN_SOURCE_LSB: u32 = 0;
pub const GPIO_PIN_SOURCE_MASK: u32 = 1;
pub const FRC1_LOAD_ADDRESS: u32 = 0;
pub const FRC1_COUNT_ADDRESS: u32 = 4;
pub const FRC1_CTRL_ADDRESS: u32 = 8;
pub const FRC1_INT_ADDRESS: u32 = 12;
pub const FRC1_INT_CLR_MASK: u32 = 1;
pub const FRC2_COUNT_ADDRESS: u32 = 36;
pub const REG_RTC_BASE: u32 = 1610614528;
pub const RTC_STORE0: u32 = 1610614576;
pub const RTC_STORE1: u32 = 1610614580;
pub const RTC_STORE2: u32 = 1610614584;
pub const RTC_STORE3: u32 = 1610614588;
pub const RTC_GPIO_OUT: u32 = 1610614632;
pub const RTC_GPIO_ENABLE: u32 = 1610614644;
pub const RTC_GPIO_IN_DATA: u32 = 1610614668;
pub const RTC_GPIO_CONF: u32 = 1610614672;
pub const PAD_XPD_DCDC_CONF: u32 = 1610614688;
pub const PERIPHS_IO_MUX_FUNC: u32 = 19;
pub const PERIPHS_IO_MUX_FUNC_S: u32 = 4;
pub const PERIPHS_IO_MUX_PULLUP: u32 = 128;
pub const PERIPHS_IO_MUX_PULLUP2: u32 = 64;
pub const PERIPHS_IO_MUX_SLEEP_PULLUP: u32 = 8;
pub const PERIPHS_IO_MUX_SLEEP_PULLUP2: u32 = 4;
pub const PERIPHS_IO_MUX_SLEEP_OE: u32 = 2;
pub const PERIPHS_IO_MUX_OE: u32 = 1;
pub const PERIPHS_IO_MUX_CONF_U: u32 = 1610614784;
pub const SPI0_CLK_EQU_SYS_CLK: u32 = 256;
pub const SPI1_CLK_EQU_SYS_CLK: u32 = 512;
pub const PERIPHS_IO_MUX_MTDI_U: u32 = 1610614788;
pub const FUNC_GPIO12: u32 = 3;
pub const PERIPHS_IO_MUX_MTCK_U: u32 = 1610614792;
pub const FUNC_GPIO13: u32 = 3;
pub const PERIPHS_IO_MUX_MTMS_U: u32 = 1610614796;
pub const FUNC_GPIO14: u32 = 3;
pub const PERIPHS_IO_MUX_MTDO_U: u32 = 1610614800;
pub const FUNC_GPIO15: u32 = 3;
pub const FUNC_U0RTS: u32 = 4;
pub const PERIPHS_IO_MUX_U0RXD_U: u32 = 1610614804;
pub const FUNC_GPIO3: u32 = 3;
pub const PERIPHS_IO_MUX_U0TXD_U: u32 = 1610614808;
pub const FUNC_U0TXD: u32 = 0;
pub const FUNC_GPIO1: u32 = 3;
pub const PERIPHS_IO_MUX_SD_CLK_U: u32 = 1610614812;
pub const FUNC_SDCLK: u32 = 0;
pub const FUNC_SPICLK: u32 = 1;
pub const PERIPHS_IO_MUX_SD_DATA0_U: u32 = 1610614816;
pub const FUNC_SDDATA0: u32 = 0;
pub const FUNC_SPIQ: u32 = 1;
pub const FUNC_U1TXD: u32 = 4;
pub const PERIPHS_IO_MUX_SD_DATA1_U: u32 = 1610614820;
pub const FUNC_SDDATA1: u32 = 0;
pub const FUNC_SPID: u32 = 1;
pub const FUNC_U1RXD: u32 = 4;
pub const FUNC_SDDATA1_U1RXD: u32 = 7;
pub const PERIPHS_IO_MUX_SD_DATA2_U: u32 = 1610614824;
pub const FUNC_SDDATA2: u32 = 0;
pub const FUNC_SPIHD: u32 = 1;
pub const FUNC_GPIO9: u32 = 3;
pub const PERIPHS_IO_MUX_SD_DATA3_U: u32 = 1610614828;
pub const FUNC_SDDATA3: u32 = 0;
pub const FUNC_SPIWP: u32 = 1;
pub const FUNC_GPIO10: u32 = 3;
pub const PERIPHS_IO_MUX_SD_CMD_U: u32 = 1610614832;
pub const FUNC_SDCMD: u32 = 0;
pub const FUNC_SPICS0: u32 = 1;
pub const PERIPHS_IO_MUX_GPIO0_U: u32 = 1610614836;
pub const FUNC_GPIO0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO2_U: u32 = 1610614840;
pub const FUNC_GPIO2: u32 = 0;
pub const FUNC_U1TXD_BK: u32 = 2;
pub const FUNC_U0TXD_BK: u32 = 4;
pub const PERIPHS_IO_MUX_GPIO4_U: u32 = 1610614844;
pub const FUNC_GPIO4: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO5_U: u32 = 1610614848;
pub const FUNC_GPIO5: u32 = 0;
pub const ETS_SDIO_INUM: u32 = 1;
pub const ETS_SPI_INUM: u32 = 2;
pub const ETS_GPIO_INUM: u32 = 4;
pub const ETS_UART_INUM: u32 = 5;
pub const ETS_UART1_INUM: u32 = 5;
pub const ETS_FRC_TIMER1_INUM: u32 = 9;
pub const _STRING_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC23: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_TIME_BITS64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C23_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 40;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const EFAULT: u32 = 14;
pub const BYTE_ORDER: u32 = 1234;
pub const S16_F: &[u8; 2] = b"d\0";
pub const U16_F: &[u8; 2] = b"d\0";
pub const X16_F: &[u8; 2] = b"x\0";
pub const S32_F: &[u8; 2] = b"d\0";
pub const U32_F: &[u8; 2] = b"d\0";
pub const X32_F: &[u8; 2] = b"x\0";
pub const LWIP_PLATFORM_BYTESWAP: u32 = 1;
pub const SZT_F: &[u8; 2] = b"d\0";
pub const X8_F: &[u8; 4] = b"02x\0";
pub const LWIP_DBG_LEVEL_ALL: u32 = 0;
pub const LWIP_DBG_LEVEL_OFF: u32 = 0;
pub const LWIP_DBG_LEVEL_WARNING: u32 = 1;
pub const LWIP_DBG_LEVEL_SERIOUS: u32 = 2;
pub const LWIP_DBG_LEVEL_SEVERE: u32 = 3;
pub const LWIP_DBG_MASK_LEVEL: u32 = 3;
pub const LWIP_DBG_ON: u32 = 128;
pub const LWIP_DBG_OFF: u32 = 0;
pub const LWIP_DBG_TRACE: u32 = 64;
pub const LWIP_DBG_STATE: u32 = 32;
pub const LWIP_DBG_FRESH: u32 = 16;
pub const LWIP_DBG_HALT: u32 = 8;
pub const ERR_OK: u32 = 0;
pub const ERR_MEM: i32 = -1;
pub const ERR_BUF: i32 = -2;
pub const ERR_TIMEOUT: i32 = -3;
pub const ERR_RTE: i32 = -4;
pub const ERR_INPROGRESS: i32 = -5;
pub const ERR_VAL: i32 = -6;
pub const ERR_WOULDBLOCK: i32 = -7;
pub const ERR_ABRT: i32 = -8;
pub const ERR_RST: i32 = -9;
pub const ERR_CLSD: i32 = -10;
pub const ERR_CONN: i32 = -11;
pub const ERR_ARG: i32 = -12;
pub const ERR_USE: i32 = -13;
pub const ERR_IF: i32 = -14;
pub const ERR_ISCONN: i32 = -15;
pub const PBUF_TRANSPORT_HLEN: u32 = 20;
pub const PBUF_IP_HLEN: u32 = 20;
pub const PBUF_FLAG_PUSH: u32 = 1;
pub const PBUF_FLAG_IS_CUSTOM: u32 = 2;
pub const PBUF_FLAG_MCASTLOOP: u32 = 4;
pub const IP_CLASSA_NET: u32 = 4278190080;
pub const IP_CLASSA_NSHIFT: u32 = 24;
pub const IP_CLASSA_HOST: u32 = 16777215;
pub const IP_CLASSA_MAX: u32 = 128;
pub const IP_CLASSB_NET: u32 = 4294901760;
pub const IP_CLASSB_NSHIFT: u32 = 16;
pub const IP_CLASSB_HOST: u32 = 65535;
pub const IP_CLASSB_MAX: u32 = 65536;
pub const IP_CLASSC_NET: u32 = 4294967040;
pub const IP_CLASSC_NSHIFT: u32 = 8;
pub const IP_CLASSC_HOST: u32 = 255;
pub const IP_CLASSD_NET: u32 = 4026531840;
pub const IP_CLASSD_NSHIFT: u32 = 28;
pub const IP_CLASSD_HOST: u32 = 268435455;
pub const IP_LOOPBACKNET: u32 = 127;
pub const IPSTR: &[u8; 12] = b"%d.%d.%d.%d\0";
pub const NETIF_MAX_HWADDR_LEN: u32 = 6;
pub const NETIF_FLAG_UP: u32 = 1;
pub const NETIF_FLAG_BROADCAST: u32 = 2;
pub const NETIF_FLAG_POINTTOPOINT: u32 = 4;
pub const NETIF_FLAG_DHCP: u32 = 8;
pub const NETIF_FLAG_LINK_UP: u32 = 16;
pub const NETIF_FLAG_ETHARP: u32 = 32;
pub const NETIF_FLAG_ETHERNET: u32 = 64;
pub const NETIF_FLAG_IGMP: u32 = 128;
pub const IP_OPTIONS_SEND: u32 = 1;
pub const IP_HLEN: u32 = 20;
pub const IP_PROTO_ICMP: u32 = 1;
pub const IP_PROTO_IGMP: u32 = 2;
pub const IP_PROTO_UDP: u32 = 17;
pub const IP_PROTO_UDPLITE: u32 = 136;
pub const IP_PROTO_TCP: u32 = 6;
pub const IP_RF: u32 = 32768;
pub const IP_DF: u32 = 16384;
pub const IP_MF: u32 = 8192;
pub const IP_OFFMASK: u32 = 8191;
pub const ETHARP_HWADDR_LEN: u32 = 6;
pub const SIZEOF_ETH_HDR: u32 = 14;
pub const SIZEOF_ETHARP_HDR: u32 = 28;
pub const SIZEOF_ETHARP_MINSIZE: u32 = 46;
pub const SIZEOF_ETHARP_PACKET: u32 = 42;
pub const SIZEOF_ETHARP_WITHPAD: u32 = 60;
pub const ARP_TMR_INTERVAL: u32 = 5000;
pub const ETHTYPE_ARP: u32 = 2054;
pub const ETHTYPE_IP: u32 = 2048;
pub const ETHTYPE_VLAN: u32 = 33024;
pub const ETHTYPE_PPPOEDISC: u32 = 34915;
pub const ETHTYPE_PPPOE: u32 = 34916;
pub const ETHTYPE_PAE: u32 = 34958;
pub const ARP_REQUEST: u32 = 1;
pub const ARP_REPLY: u32 = 2;
pub const LWIP_ARP_FILTER_NETIF: u32 = 0;
pub const LLC_ISFRAMELEN: u32 = 4;
pub const LLC_UFRAMELEN: u32 = 3;
pub const LLC_FRMRLEN: u32 = 7;
pub const LLC_SNAPFRAMELEN: u32 = 8;
pub const LLC_UI: u32 = 3;
pub const LLC_UI_P: u32 = 19;
pub const LLC_DISC: u32 = 67;
pub const LLC_DISC_P: u32 = 83;
pub const LLC_UA: u32 = 99;
pub const LLC_UA_P: u32 = 115;
pub const LLC_TEST: u32 = 227;
pub const LLC_TEST_P: u32 = 243;
pub const LLC_FRMR: u32 = 135;
pub const LLC_FRMR_P: u32 = 151;
pub const LLC_DM: u32 = 15;
pub const LLC_DM_P: u32 = 31;
pub const LLC_XID: u32 = 175;
pub const LLC_XID_P: u32 = 191;
pub const LLC_SABME: u32 = 111;
pub const LLC_SABME_P: u32 = 127;
pub const LLC_RR: u32 = 1;
pub const LLC_RNR: u32 = 5;
pub const LLC_REJ: u32 = 9;
pub const LLC_INFO: u32 = 0;
pub const LLC_8021D_LSAP: u32 = 66;
pub const LLC_X25_LSAP: u32 = 126;
pub const LLC_SNAP_LSAP: u32 = 170;
pub const LLC_ISO_LSAP: u32 = 254;
pub const RFC1042_LEN: u32 = 6;
pub const ETHERTYPE_AARP: u32 = 33011;
pub const ETHERTYPE_IPX: u32 = 33079;
pub const LWIP_IF0_PRIO: u32 = 28;
pub const LWIP_IF1_PRIO: u32 = 29;
pub type sint8_t = ::core::ffi::c_schar;
pub type sint16_t = ::core::ffi::c_short;
pub type sint32_t = ::core::ffi::c_int;
pub type sint64_t = ::core::ffi::c_longlong;
pub type u_int64_t = ::core::ffi::c_ulonglong;
pub type real32_t = f32;
pub type real64_t = f64;
pub type uint8 = ::core::ffi::c_uchar;
pub type u8_ = ::core::ffi::c_uchar;
pub type sint8 = ::core::ffi::c_schar;
pub type int8 = ::core::ffi::c_schar;
pub type s8 = ::core::ffi::c_schar;
pub type uint16 = ::core::ffi::c_ushort;
pub type u16_ = ::core::ffi::c_ushort;
pub type sint16 = ::core::ffi::c_short;
pub type s16 = ::core::ffi::c_short;
pub type uint32 = ::core::ffi::c_uint;
pub type u_int = ::core::ffi::c_uint;
pub type u32_ = ::core::ffi::c_uint;
pub type sint32 = ::core::ffi::c_int;
pub type s32 = ::core::ffi::c_int;
pub type int32 = ::core::ffi::c_int;
pub type sint64 = ::core::ffi::c_longlong;
pub type uint64 = ::core::ffi::c_ulonglong;
pub type u64_ = ::core::ffi::c_ulonglong;
pub type real32 = f32;
pub type real64 = f64;
pub const STATUS_OK: STATUS = 0;
pub const STATUS_FAIL: STATUS = 1;
pub const STATUS_PENDING: STATUS = 2;
pub const STATUS_BUSY: STATUS = 3;
pub const STATUS_CANCEL: STATUS = 4;
pub type STATUS = ::core::ffi::c_uint;
pub type bool_ = ::core::ffi::c_uchar;
pub type ETSSignal = u32;
pub type ETSParam = u32;
pub type ETSEvent = ETSEventTag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ETSEventTag {
    pub sig: ETSSignal,
    pub par: ETSParam,
}
pub type ETSTask = ::core::option::Option<unsafe extern "C" fn(e: *mut ETSEvent)>;
pub type ETSHandle = u32;
pub type ETSTimerFunc =
    ::core::option::Option<unsafe extern "C" fn(timer_arg: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETSTIMER_ {
    pub timer_next: *mut _ETSTIMER_,
    pub timer_expire: u32,
    pub timer_period: u32,
    pub timer_func: ETSTimerFunc,
    pub timer_arg: *mut ::core::ffi::c_void,
}
pub type ETSTimer = _ETSTIMER_;
pub type ets_isr_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::core::ffi::c_ushort,
    pub __ctype_tolower: *const ::core::ffi::c_int,
    pub __ctype_toupper: *const ::core::ffi::c_int,
    pub __names: [*const ::core::ffi::c_char; 13usize],
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
pub type u8_t = ::core::ffi::c_uchar;
pub type s8_t = ::core::ffi::c_schar;
pub type u16_t = ::core::ffi::c_ushort;
pub type s16_t = ::core::ffi::c_short;
pub type u32_t = ::core::ffi::c_ulong;
pub type s32_t = ::core::ffi::c_long;
pub type mem_ptr_t = ::core::ffi::c_ulong;
pub type err_t = s32_t;
pub const pbuf_layer_PBUF_TRANSPORT: pbuf_layer = 0;
pub const pbuf_layer_PBUF_IP: pbuf_layer = 1;
pub const pbuf_layer_PBUF_LINK: pbuf_layer = 2;
pub const pbuf_layer_PBUF_RAW: pbuf_layer = 3;
pub type pbuf_layer = ::core::ffi::c_uint;
pub const pbuf_type_PBUF_RAM: pbuf_type = 0;
pub const pbuf_type_PBUF_ROM: pbuf_type = 1;
pub const pbuf_type_PBUF_REF: pbuf_type = 2;
pub const pbuf_type_PBUF_POOL: pbuf_type = 3;
pub type pbuf_type = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pbuf {
    #[doc = " next pbuf in singly linked pbuf chain"]
    pub next: *mut pbuf,
    #[doc = " pointer to the actual data in the buffer"]
    pub payload: *mut ::core::ffi::c_void,
    #[doc = " total length of this buffer and all next buffers in chain\n belonging to the same packet.\n\n For non-queue packet chains this is the invariant:\n p->tot_len == p->len + (p->next? p->next->tot_len: 0)"]
    pub tot_len: u16_t,
    #[doc = " length of this buffer"]
    pub len: u16_t,
    #[doc = " pbuf_type as u8_t instead of enum to save space"]
    pub type_: u8_t,
    #[doc = " misc flags"]
    pub flags: u8_t,
    #[doc = " the reference count always equals the number of pointers\n that refer to this pbuf. This can be pointers from an application,\n the stack itself, or pbuf->next pointers from a chain."]
    pub ref_: u16_t,
    pub eb: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_addr {
    pub addr: u32_t,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ip_addr_packed {
    pub addr: u32_t,
}
#[doc = " ip_addr_t uses a struct for convenience only, so that the same defines can\n operate both on ip_addr_t as well as on ip_addr_p_t."]
pub type ip_addr_t = ip_addr;
pub type ip_addr_p_t = ip_addr_packed;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ip_addr2 {
    pub addrw: [u16_t; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_info {
    pub ip: ip_addr,
    pub netmask: ip_addr,
    pub gw: ip_addr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dhcp {
    _unused: [u8; 0],
}
#[doc = " Function prototype for netif init functions. Set up flags and output/linkoutput\n callback functions in this function.\n\n @param netif The netif to initialize"]
pub type netif_init_fn = ::core::option::Option<unsafe extern "C" fn(netif: *mut netif) -> err_t>;
#[doc = " Function prototype for netif->input functions. This function is saved as 'input'\n callback function in the netif struct. Call it when a packet has been received.\n\n @param p The received packet, copied into a pbuf\n @param inp The netif which received the packet"]
pub type netif_input_fn =
    ::core::option::Option<unsafe extern "C" fn(p: *mut pbuf, inp: *mut netif) -> err_t>;
#[doc = " Function prototype for netif->output functions. Called by lwIP when a packet\n shall be sent. For ethernet netif, set this to 'etharp_output' and set\n 'linkoutput'.\n\n @param netif The netif which shall send a packet\n @param p The packet to send (p->payload points to IP header)\n @param ipaddr The IP address to which the packet shall be sent"]
pub type netif_output_fn = ::core::option::Option<
    unsafe extern "C" fn(netif: *mut netif, p: *mut pbuf, ipaddr: *mut ip_addr_t) -> err_t,
>;
#[doc = " Function prototype for netif->linkoutput functions. Only used for ethernet\n netifs. This function is called by ARP when a packet shall be sent.\n\n @param netif The netif which shall send a packet\n @param p The packet to send (raw ethernet packet)"]
pub type netif_linkoutput_fn =
    ::core::option::Option<unsafe extern "C" fn(netif: *mut netif, p: *mut pbuf) -> err_t>;
#[doc = " Function prototype for netif status- or link-callback functions."]
pub type netif_status_callback_fn = ::core::option::Option<unsafe extern "C" fn(netif: *mut netif)>;
#[doc = " Function prototype for netif igmp_mac_filter functions"]
pub type netif_igmp_mac_filter_fn = ::core::option::Option<
    unsafe extern "C" fn(netif: *mut netif, group: *mut ip_addr_t, action: u8_t) -> err_t,
>;
pub type dhcp_event_fn = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " Generic data structure used for all lwIP network interfaces.\n  The following fields should be filled in by the initialization\n  function for the device driver: hwaddr_len, hwaddr[], mtu, flags"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netif {
    #[doc = " pointer to next in linked list"]
    pub next: *mut netif,
    #[doc = " IP address configuration in network byte order"]
    pub ip_addr: ip_addr_t,
    pub netmask: ip_addr_t,
    pub gw: ip_addr_t,
    #[doc = " This function is called by the network device driver\n  to pass a packet up the TCP/IP stack. ��IP���������ݰ�"]
    pub input: netif_input_fn,
    #[doc = " This function is called by the IP module when it wants\n  to send a packet on the interface. This function typically\n  first resolves the hardware address, then sends the packet. ����IP���ݰ�"]
    pub output: netif_output_fn,
    #[doc = " This function is called by the ARP module when it wants\n  to send a packet on the interface. This function outputs\n  the pbuf as-is on the link medium. �ײ����ݰ�����"]
    pub linkoutput: netif_linkoutput_fn,
    #[doc = " This field can be set by the device driver and could point\n  to state information for the device. ���������\u{5b6}Σ�����\u{5b8}��ײ��豸�����Ϣ"]
    pub state: *mut ::core::ffi::c_void,
    #[doc = " the DHCP client state information for this netif"]
    pub dhcp: *mut dhcp,
    pub dhcps_pcb: *mut udp_pcb,
    pub dhcp_event: dhcp_event_fn,
    pub hostname: *mut ::core::ffi::c_char,
    #[doc = " maximum transfer unit (in bytes) �ýӿ�������������ݰ����ȣ�����1500"]
    pub mtu: u16_t,
    #[doc = " number of bytes used in hwaddr�ýӿ�������\u{5b7}����"]
    pub hwaddr_len: u8_t,
    #[doc = " link level hardware address of this interface �ýӿ�������\u{5b7}"]
    pub hwaddr: [u8_t; 6usize],
    #[doc = " flags (see NETIF_FLAG_ above) �ýӿ�״\u{32c}�������\u{5b6}�"]
    pub flags: u8_t,
    #[doc = " descriptive abbreviation �ýӿڵ�����"]
    pub name: [::core::ffi::c_char; 2usize],
    #[doc = " number of this interface �ýӿڵı��"]
    pub num: u8_t,
    #[doc = " This function could be called to add or delete a entry in the multicast\nfilter table of the ethernet MAC."]
    pub igmp_mac_filter: netif_igmp_mac_filter_fn,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_pcb {
    pub local_ip: ip_addr_t,
    pub remote_ip: ip_addr_t,
    pub so_options: u8_t,
    pub tos: u8_t,
    pub ttl: u8_t,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ip_hdr {
    pub _v_hl_tos: u16_t,
    pub _len: u16_t,
    pub _id: u16_t,
    pub _offset: u16_t,
    pub _ttl: u8_t,
    pub _proto: u8_t,
    pub _chksum: u16_t,
    pub src: ip_addr_p_t,
    pub dest: ip_addr_p_t,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct eth_addr {
    pub addr: [u8_t; 6usize],
}
#[doc = " Ethernet header"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct eth_hdr {
    pub dest: eth_addr,
    pub src: eth_addr,
    pub type_: u16_t,
}
#[doc = " the ARP message, see RFC 826 (\"Packet format\")"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct etharp_hdr {
    pub hwtype: u16_t,
    pub proto: u16_t,
    pub hwlen: u8_t,
    pub protolen: u8_t,
    pub opcode: u16_t,
    pub shwaddr: eth_addr,
    pub sipaddr: ip_addr2,
    pub dhwaddr: eth_addr,
    pub dipaddr: ip_addr2,
}
#[doc = " struct for queueing outgoing packets for unknown address\n defined here to be accessed by memp.h"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct etharp_q_entry {
    pub next: *mut etharp_q_entry,
    pub p: *mut pbuf,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct llc {
    pub llc_dsap: u8,
    pub llc_ssap: u8,
    pub llc_un: llc__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union llc__bindgen_ty_1 {
    pub type_u: llc__bindgen_ty_1__bindgen_ty_1,
    pub type_i: llc__bindgen_ty_1__bindgen_ty_2,
    pub type_s: llc__bindgen_ty_1__bindgen_ty_3,
    pub type_frmr: llc__bindgen_ty_1__bindgen_ty_4,
    pub type_snap: llc__bindgen_ty_1__bindgen_ty_5,
    pub type_raw: llc__bindgen_ty_1__bindgen_ty_6,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct llc__bindgen_ty_1__bindgen_ty_1 {
    pub control: u8,
    pub format_id: u8,
    pub class: u8,
    pub window_x2: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct llc__bindgen_ty_1__bindgen_ty_2 {
    pub num_snd_x2: u8,
    pub num_rcv_x2: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct llc__bindgen_ty_1__bindgen_ty_3 {
    pub control: u8,
    pub num_rcv_x2: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct llc__bindgen_ty_1__bindgen_ty_4 {
    pub control: u8,
    pub frmr_rej_pdu0: u8,
    pub frmr_rej_pdu1: u8,
    pub frmr_control: u8,
    pub frmr_control_ext: u8,
    pub frmr_cause: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct llc__bindgen_ty_1__bindgen_ty_5 {
    pub control: u8,
    pub org_code: [u8; 3usize],
    pub ether_type: u16,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct llc__bindgen_ty_1__bindgen_ty_6 {
    pub control: u8,
    pub control_ext: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct frmrinfo {
    pub frmr_rej_pdu0: u8,
    pub frmr_rej_pdu1: u8,
    pub frmr_control: u8,
    pub frmr_control_ext: u8,
    pub frmr_cause: u8,
}
pub const SIG_LWIP_RX: _bindgen_ty_1 = 0;
pub type _bindgen_ty_1 = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udp_pcb {
    pub _address: u8,
}
extern "C" {
    pub fn ets_intr_lock();
    pub fn ets_intr_unlock();
    pub fn ets_isr_attach(i: ::core::ffi::c_int, func: ets_isr_t, arg: *mut ::core::ffi::c_void);
    pub fn ets_isr_mask(mask: uint32);
    pub fn ets_isr_unmask(unmask: uint32);
    pub fn NmiTimSetFunc(func: ::core::option::Option<unsafe extern "C" fn()>);
    pub fn memcpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn memmove(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn memccpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn memset(
        __s: *mut ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn memcmp(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
    pub fn __memcmpeq(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: usize,
    ) -> ::core::ffi::c_int;
    pub fn memchr(
        __s: *const ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn strcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
    pub fn strcat(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strncat(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
    pub fn strcmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn strncmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
    pub fn strcoll(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn strxfrm(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
    pub fn strcoll_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __l: locale_t,
    ) -> ::core::ffi::c_int;
    pub fn strxfrm_l(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
    pub fn strdup(__s: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn strndup(
        __string: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
    pub fn strchr(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn strrchr(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn strchrnul(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn strcspn(
        __s: *const ::core::ffi::c_char,
        __reject: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_ulong;
    pub fn strspn(
        __s: *const ::core::ffi::c_char,
        __accept: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_ulong;
    pub fn strpbrk(
        __s: *const ::core::ffi::c_char,
        __accept: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strstr(
        __haystack: *const ::core::ffi::c_char,
        __needle: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strtok(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn __strtok_r(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
        __save_ptr: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strtok_r(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
        __save_ptr: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strcasestr(
        __haystack: *const ::core::ffi::c_char,
        __needle: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn memmem(
        __haystack: *const ::core::ffi::c_void,
        __haystacklen: usize,
        __needle: *const ::core::ffi::c_void,
        __needlelen: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn __mempcpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn mempcpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn strlen(__s: *const ::core::ffi::c_char) -> ::core::ffi::c_ulong;
    pub fn strnlen(__string: *const ::core::ffi::c_char, __maxlen: usize) -> usize;
    pub fn strerror(__errnum: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_char,
        __buflen: usize,
    ) -> ::core::ffi::c_int;
    pub fn strerror_l(__errnum: ::core::ffi::c_int, __l: locale_t) -> *mut ::core::ffi::c_char;
    pub fn bcmp(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
    pub fn bcopy(
        __src: *const ::core::ffi::c_void,
        __dest: *mut ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    );
    pub fn bzero(__s: *mut ::core::ffi::c_void, __n: ::core::ffi::c_ulong);
    pub fn index(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn rindex(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn ffs(__i: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn ffsl(__l: ::core::ffi::c_long) -> ::core::ffi::c_int;
    pub fn ffsll(__ll: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
    pub fn strcasecmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn strncasecmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
    pub fn strcasecmp_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __loc: locale_t,
    ) -> ::core::ffi::c_int;
    pub fn strncasecmp_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::core::ffi::c_int;
    pub fn explicit_bzero(__s: *mut ::core::ffi::c_void, __n: usize);
    pub fn strsep(
        __stringp: *mut *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strsignal(__sig: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
    pub fn __stpcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn stpcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn __stpncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: usize,
    ) -> *mut ::core::ffi::c_char;
    pub fn stpncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
    pub fn strlcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
    pub fn strlcat(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
    pub fn ets_bzero(s: *mut ::core::ffi::c_void, n: usize);
    pub fn ets_delay_us(us: u32);
    pub fn ets_install_putc1(
        p: ::core::option::Option<unsafe extern "C" fn(c: ::core::ffi::c_char)>,
    );
    pub fn ets_memcmp(
        str1: *const ::core::ffi::c_void,
        str2: *const ::core::ffi::c_void,
        nbyte: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
    pub fn ets_memcpy(
        dest: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        nbyte: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub fn ets_memmove(
        dest: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        nbyte: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub fn ets_memset(
        dest: *mut ::core::ffi::c_void,
        val: ::core::ffi::c_int,
        nbyte: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub fn ets_strcmp(
        s1: *const ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn ets_strcpy(
        s1: *mut ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn ets_strlen(s: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn ets_strncmp(
        s1: *const ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
        n: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
    pub fn ets_strncpy(
        s1: *mut ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
        n: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_char;
    pub fn ets_strstr(
        s1: *const ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn ets_timer_arm_new(ptimer: *mut ETSTimer, time: u32, repeat_flag: bool_, ms_flag: bool_);
    pub fn ets_timer_disarm(ptimer: *mut ETSTimer);
    pub fn ets_timer_setfn(
        ptimer: *mut ETSTimer,
        pfunction: ETSTimerFunc,
        parg: *mut ::core::ffi::c_void,
    );
    pub fn ets_sprintf(
        str_: *mut ::core::ffi::c_char,
        format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn os_printf_plus(format: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn ets_snprintf(
        str_: *mut ::core::ffi::c_char,
        size: ::core::ffi::c_uint,
        format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn os_random() -> ::core::ffi::c_ulong;
    pub fn os_get_random(buf: *mut ::core::ffi::c_uchar, len: usize) -> ::core::ffi::c_int;
    pub static mut memp_memory_RAW_PCB_base: [u8_t; 0usize];
    pub static mut memp_memory_UDP_PCB_base: [u8_t; 0usize];
    pub static mut memp_memory_TCP_PCB_base: [u8_t; 0usize];
    pub static mut memp_memory_TCP_PCB_LISTEN_base: [u8_t; 0usize];
    pub static mut memp_memory_TCP_SEG_base: [u8_t; 0usize];
    pub static mut memp_memory_SYS_TIMEOUT_base: [u8_t; 0usize];
    pub static mut memp_memory_PBUF_base: [u8_t; 0usize];
    pub static mut memp_memory_PBUF_POOL_base: [u8_t; 0usize];
    pub fn pbuf_alloc(l: pbuf_layer, length: u16_t, type_: pbuf_type) -> *mut pbuf;
    pub fn pbuf_realloc(p: *mut pbuf, size: u16_t);
    pub fn pbuf_header(p: *mut pbuf, header_size: s16_t) -> u8_t;
    pub fn pbuf_ref(p: *mut pbuf);
    pub fn pbuf_free(p: *mut pbuf) -> u8_t;
    pub fn pbuf_clen(p: *mut pbuf) -> u8_t;
    pub fn pbuf_cat(head: *mut pbuf, tail: *mut pbuf);
    pub fn pbuf_chain(head: *mut pbuf, tail: *mut pbuf);
    pub fn pbuf_dechain(p: *mut pbuf) -> *mut pbuf;
    pub fn pbuf_copy(p_to: *mut pbuf, p_from: *mut pbuf) -> err_t;
    pub fn pbuf_copy_partial(
        p: *mut pbuf,
        dataptr: *mut ::core::ffi::c_void,
        len: u16_t,
        offset: u16_t,
    ) -> u16_t;
    pub fn pbuf_take(buf: *mut pbuf, dataptr: *const ::core::ffi::c_void, len: u16_t) -> err_t;
    pub fn pbuf_coalesce(p: *mut pbuf, layer: pbuf_layer) -> *mut pbuf;
    pub fn pbuf_get_at(p: *mut pbuf, offset: u16_t) -> u8_t;
    pub fn pbuf_memcmp(
        p: *mut pbuf,
        offset: u16_t,
        s2: *const ::core::ffi::c_void,
        n: u16_t,
    ) -> u16_t;
    pub fn pbuf_memfind(
        p: *mut pbuf,
        mem: *const ::core::ffi::c_void,
        mem_len: u16_t,
        start_offset: u16_t,
    ) -> u16_t;
    pub fn pbuf_strstr(p: *mut pbuf, substr: *const ::core::ffi::c_char) -> u16_t;
    pub static ip_addr_any: ip_addr_t;
    pub static ip_addr_broadcast: ip_addr_t;
    pub fn ip4_addr_isbroadcast(addr: u32_t, netif: *const netif) -> u8_t;
    pub fn ip4_addr_netmask_valid(netmask: u32_t) -> u8_t;
    pub fn ipaddr_addr(cp: *const ::core::ffi::c_char) -> u32_t;
    pub fn ipaddr_aton(cp: *const ::core::ffi::c_char, addr: *mut ip_addr_t) -> ::core::ffi::c_int;
    #[doc = " returns ptr to static buffer; not reentrant!"]
    pub fn ipaddr_ntoa(addr: *const ip_addr_t) -> *mut ::core::ffi::c_char;
    pub fn ipaddr_ntoa_r(
        addr: *const ip_addr_t,
        buf: *mut ::core::ffi::c_char,
        buflen: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    #[doc = " The list of network interfaces."]
    pub static mut netif_list: *mut netif;
    #[doc = " The default network interface."]
    pub static mut netif_default: *mut netif;
    pub fn netif_init();
    pub fn netif_add(
        netif: *mut netif,
        ipaddr: *mut ip_addr_t,
        netmask: *mut ip_addr_t,
        gw: *mut ip_addr_t,
        state: *mut ::core::ffi::c_void,
        init: netif_init_fn,
        input: netif_input_fn,
    ) -> *mut netif;
    pub fn netif_set_addr(
        netif: *mut netif,
        ipaddr: *mut ip_addr_t,
        netmask: *mut ip_addr_t,
        gw: *mut ip_addr_t,
    );
    pub fn netif_remove(netif: *mut netif);
    pub fn netif_find(name: *mut ::core::ffi::c_char) -> *mut netif;
    pub fn netif_set_default(netif: *mut netif);
    pub fn netif_set_ipaddr(netif: *mut netif, ipaddr: *mut ip_addr_t);
    pub fn netif_set_netmask(netif: *mut netif, netmask: *mut ip_addr_t);
    pub fn netif_set_gw(netif: *mut netif, gw: *mut ip_addr_t);
    pub fn netif_set_up(netif: *mut netif);
    pub fn netif_set_down(netif: *mut netif);
    pub fn netif_set_link_up(netif: *mut netif);
    pub fn netif_set_link_down(netif: *mut netif);
    #[doc = " The interface that provided the packet for the current callback invocation."]
    pub static mut current_netif: *mut netif;
    #[doc = " Header of the input packet currently being processed."]
    pub static mut current_header: *const ip_hdr;
    #[doc = " Source IP address of current_header"]
    pub static mut current_iphdr_src: ip_addr_t;
    #[doc = " Destination IP address of current_header"]
    pub static mut current_iphdr_dest: ip_addr_t;
    pub fn ip_route(dest: *mut ip_addr_t) -> *mut netif;
    pub fn ip_router(dest: *mut ip_addr_t, source: *mut ip_addr_t) -> *mut netif;
    pub fn ip_input(p: *mut pbuf, inp: *mut netif) -> err_t;
    pub fn ip_output(
        p: *mut pbuf,
        src: *mut ip_addr_t,
        dest: *mut ip_addr_t,
        ttl: u8_t,
        tos: u8_t,
        proto: u8_t,
    ) -> err_t;
    pub fn ip_output_if(
        p: *mut pbuf,
        src: *mut ip_addr_t,
        dest: *mut ip_addr_t,
        ttl: u8_t,
        tos: u8_t,
        proto: u8_t,
        netif: *mut netif,
    ) -> err_t;
    pub fn ip_output_if_opt(
        p: *mut pbuf,
        src: *mut ip_addr_t,
        dest: *mut ip_addr_t,
        ttl: u8_t,
        tos: u8_t,
        proto: u8_t,
        netif: *mut netif,
        ip_options: *mut ::core::ffi::c_void,
        optlen: u16_t,
    ) -> err_t;
    pub fn etharp_tmr();
    pub fn etharp_find_addr(
        netif: *mut netif,
        ipaddr: *mut ip_addr_t,
        eth_ret: *mut *mut eth_addr,
        ip_ret: *mut *mut ip_addr_t,
    ) -> s8_t;
    pub fn etharp_output(netif: *mut netif, q: *mut pbuf, ipaddr: *mut ip_addr_t) -> err_t;
    pub fn etharp_query(netif: *mut netif, ipaddr: *mut ip_addr_t, q: *mut pbuf) -> err_t;
    pub fn etharp_request(netif: *mut netif, ipaddr: *mut ip_addr_t) -> err_t;
    pub fn etharp_cleanup_netif(netif: *mut netif);
    pub fn ethernet_input(p: *mut pbuf, netif: *mut netif) -> err_t;
    pub static ethbroadcast: eth_addr;
    pub static ethzero: eth_addr;
    pub fn eagle_lwip_if_alloc(
        conn: *mut __BindgenOpaqueArray<u8, 0usize>,
        macaddr: *const uint8,
        info: *mut ip_info,
    ) -> *mut netif;
    pub fn eagle_lwip_getif(index: uint8) -> *mut netif;
    pub fn ieee80211_output_pbuf(ifp: *mut netif, pb: *mut pbuf) -> sint8;
}
