/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }
}
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const ESP_SDK_VERSION_MAJOR: u32 = 3;
pub const ESP_SDK_VERSION_MINOR: u32 = 0;
pub const ESP_SDK_VERSION_PATCH: u32 = 4;
pub const ESP_SDK_VERSION_NUMBER: u32 = 196612;
pub const ESP_SDK_VERSION_STRING: &[u8; 6] = b"3.0.4\0";
pub const SPI_FLASH_SEC_SIZE: u32 = 4096;
pub const LIMIT_ERASE_SIZE: u32 = 65536;
pub const USER_BIN1: u32 = 0;
pub const USER_BIN2: u32 = 1;
pub const UPGRADE_FLAG_IDLE: u32 = 0;
pub const UPGRADE_FLAG_START: u32 = 1;
pub const UPGRADE_FLAG_FINISH: u32 = 2;
pub const UPGRADE_FW_BIN1: u32 = 0;
pub const UPGRADE_FW_BIN2: u32 = 1;
pub const BIT31: u32 = 2147483648;
pub const BIT30: u32 = 1073741824;
pub const BIT29: u32 = 536870912;
pub const BIT28: u32 = 268435456;
pub const BIT27: u32 = 134217728;
pub const BIT26: u32 = 67108864;
pub const BIT25: u32 = 33554432;
pub const BIT24: u32 = 16777216;
pub const BIT23: u32 = 8388608;
pub const BIT22: u32 = 4194304;
pub const BIT21: u32 = 2097152;
pub const BIT20: u32 = 1048576;
pub const BIT19: u32 = 524288;
pub const BIT18: u32 = 262144;
pub const BIT17: u32 = 131072;
pub const BIT16: u32 = 65536;
pub const BIT15: u32 = 32768;
pub const BIT14: u32 = 16384;
pub const BIT13: u32 = 8192;
pub const BIT12: u32 = 4096;
pub const BIT11: u32 = 2048;
pub const BIT10: u32 = 1024;
pub const BIT9: u32 = 512;
pub const BIT8: u32 = 256;
pub const BIT7: u32 = 128;
pub const BIT6: u32 = 64;
pub const BIT5: u32 = 32;
pub const BIT4: u32 = 16;
pub const BIT3: u32 = 8;
pub const BIT2: u32 = 4;
pub const BIT1: u32 = 2;
pub const BIT0: u32 = 1;
pub const APB_CLK_FREQ: u32 = 80000000;
pub const UART_CLK_FREQ: u32 = 80000000;
pub const TIMER_CLK_FREQ: u32 = 312500;
pub const PERIPHS_DPORT_BASEADDR: u32 = 1072693248;
pub const PERIPHS_GPIO_BASEADDR: u32 = 1610613504;
pub const PERIPHS_TIMER_BASEDDR: u32 = 1610614272;
pub const PERIPHS_RTC_BASEADDR: u32 = 1610614528;
pub const PERIPHS_IO_MUX: u32 = 1610614784;
pub const EDGE_INT_ENABLE_REG: u32 = 1072693252;
pub const GPIO_OUT_ADDRESS: u32 = 0;
pub const GPIO_OUT_W1TS_ADDRESS: u32 = 4;
pub const GPIO_OUT_W1TC_ADDRESS: u32 = 8;
pub const GPIO_ENABLE_ADDRESS: u32 = 12;
pub const GPIO_ENABLE_W1TS_ADDRESS: u32 = 16;
pub const GPIO_ENABLE_W1TC_ADDRESS: u32 = 20;
pub const GPIO_OUT_W1TC_DATA_MASK: u32 = 65535;
pub const GPIO_IN_ADDRESS: u32 = 24;
pub const GPIO_STATUS_ADDRESS: u32 = 28;
pub const GPIO_STATUS_W1TS_ADDRESS: u32 = 32;
pub const GPIO_STATUS_W1TC_ADDRESS: u32 = 36;
pub const GPIO_STATUS_INTERRUPT_MASK: u32 = 65535;
pub const GPIO_RTC_CALIB_SYNC: u32 = 1610613612;
pub const RTC_CALIB_START: u32 = 2147483648;
pub const RTC_PERIOD_NUM_MASK: u32 = 1023;
pub const GPIO_RTC_CALIB_VALUE: u32 = 1610613616;
pub const RTC_CALIB_RDY_S: u32 = 31;
pub const RTC_CALIB_VALUE_MASK: u32 = 1048575;
pub const GPIO_PIN0_ADDRESS: u32 = 40;
pub const GPIO_ID_PIN0: u32 = 0;
pub const GPIO_ID_NONE: u32 = 4294967295;
pub const GPIO_PIN_COUNT: u32 = 16;
pub const GPIO_PIN_CONFIG_MSB: u32 = 12;
pub const GPIO_PIN_CONFIG_LSB: u32 = 11;
pub const GPIO_PIN_CONFIG_MASK: u32 = 6144;
pub const GPIO_WAKEUP_ENABLE: u32 = 1;
pub const GPIO_WAKEUP_DISABLE: i32 = -2;
pub const GPIO_PIN_WAKEUP_ENABLE_MSB: u32 = 10;
pub const GPIO_PIN_WAKEUP_ENABLE_LSB: u32 = 10;
pub const GPIO_PIN_WAKEUP_ENABLE_MASK: u32 = 1024;
pub const GPIO_PIN_INT_TYPE_MASK: u32 = 896;
pub const GPIO_PIN_INT_TYPE_MSB: u32 = 9;
pub const GPIO_PIN_INT_TYPE_LSB: u32 = 7;
pub const GPIO_PAD_DRIVER_ENABLE: u32 = 1;
pub const GPIO_PAD_DRIVER_DISABLE: i32 = -2;
pub const GPIO_PIN_PAD_DRIVER_MSB: u32 = 2;
pub const GPIO_PIN_PAD_DRIVER_LSB: u32 = 2;
pub const GPIO_PIN_PAD_DRIVER_MASK: u32 = 4;
pub const GPIO_AS_PIN_SOURCE: u32 = 0;
pub const SIGMA_AS_PIN_SOURCE: i32 = -1;
pub const GPIO_PIN_SOURCE_MSB: u32 = 0;
pub const GPIO_PIN_SOURCE_LSB: u32 = 0;
pub const GPIO_PIN_SOURCE_MASK: u32 = 1;
pub const FRC1_LOAD_ADDRESS: u32 = 0;
pub const FRC1_COUNT_ADDRESS: u32 = 4;
pub const FRC1_CTRL_ADDRESS: u32 = 8;
pub const FRC1_INT_ADDRESS: u32 = 12;
pub const FRC1_INT_CLR_MASK: u32 = 1;
pub const FRC2_COUNT_ADDRESS: u32 = 36;
pub const REG_RTC_BASE: u32 = 1610614528;
pub const RTC_STORE0: u32 = 1610614576;
pub const RTC_STORE1: u32 = 1610614580;
pub const RTC_STORE2: u32 = 1610614584;
pub const RTC_STORE3: u32 = 1610614588;
pub const RTC_GPIO_OUT: u32 = 1610614632;
pub const RTC_GPIO_ENABLE: u32 = 1610614644;
pub const RTC_GPIO_IN_DATA: u32 = 1610614668;
pub const RTC_GPIO_CONF: u32 = 1610614672;
pub const PAD_XPD_DCDC_CONF: u32 = 1610614688;
pub const PERIPHS_IO_MUX_FUNC: u32 = 19;
pub const PERIPHS_IO_MUX_FUNC_S: u32 = 4;
pub const PERIPHS_IO_MUX_PULLUP: u32 = 128;
pub const PERIPHS_IO_MUX_PULLUP2: u32 = 64;
pub const PERIPHS_IO_MUX_SLEEP_PULLUP: u32 = 8;
pub const PERIPHS_IO_MUX_SLEEP_PULLUP2: u32 = 4;
pub const PERIPHS_IO_MUX_SLEEP_OE: u32 = 2;
pub const PERIPHS_IO_MUX_OE: u32 = 1;
pub const PERIPHS_IO_MUX_CONF_U: u32 = 1610614784;
pub const SPI0_CLK_EQU_SYS_CLK: u32 = 256;
pub const SPI1_CLK_EQU_SYS_CLK: u32 = 512;
pub const PERIPHS_IO_MUX_MTDI_U: u32 = 1610614788;
pub const FUNC_GPIO12: u32 = 3;
pub const PERIPHS_IO_MUX_MTCK_U: u32 = 1610614792;
pub const FUNC_GPIO13: u32 = 3;
pub const PERIPHS_IO_MUX_MTMS_U: u32 = 1610614796;
pub const FUNC_GPIO14: u32 = 3;
pub const PERIPHS_IO_MUX_MTDO_U: u32 = 1610614800;
pub const FUNC_GPIO15: u32 = 3;
pub const FUNC_U0RTS: u32 = 4;
pub const PERIPHS_IO_MUX_U0RXD_U: u32 = 1610614804;
pub const FUNC_GPIO3: u32 = 3;
pub const PERIPHS_IO_MUX_U0TXD_U: u32 = 1610614808;
pub const FUNC_U0TXD: u32 = 0;
pub const FUNC_GPIO1: u32 = 3;
pub const PERIPHS_IO_MUX_SD_CLK_U: u32 = 1610614812;
pub const FUNC_SDCLK: u32 = 0;
pub const FUNC_SPICLK: u32 = 1;
pub const PERIPHS_IO_MUX_SD_DATA0_U: u32 = 1610614816;
pub const FUNC_SDDATA0: u32 = 0;
pub const FUNC_SPIQ: u32 = 1;
pub const FUNC_U1TXD: u32 = 4;
pub const PERIPHS_IO_MUX_SD_DATA1_U: u32 = 1610614820;
pub const FUNC_SDDATA1: u32 = 0;
pub const FUNC_SPID: u32 = 1;
pub const FUNC_U1RXD: u32 = 4;
pub const FUNC_SDDATA1_U1RXD: u32 = 7;
pub const PERIPHS_IO_MUX_SD_DATA2_U: u32 = 1610614824;
pub const FUNC_SDDATA2: u32 = 0;
pub const FUNC_SPIHD: u32 = 1;
pub const FUNC_GPIO9: u32 = 3;
pub const PERIPHS_IO_MUX_SD_DATA3_U: u32 = 1610614828;
pub const FUNC_SDDATA3: u32 = 0;
pub const FUNC_SPIWP: u32 = 1;
pub const FUNC_GPIO10: u32 = 3;
pub const PERIPHS_IO_MUX_SD_CMD_U: u32 = 1610614832;
pub const FUNC_SDCMD: u32 = 0;
pub const FUNC_SPICS0: u32 = 1;
pub const PERIPHS_IO_MUX_GPIO0_U: u32 = 1610614836;
pub const FUNC_GPIO0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO2_U: u32 = 1610614840;
pub const FUNC_GPIO2: u32 = 0;
pub const FUNC_U1TXD_BK: u32 = 2;
pub const FUNC_U0TXD_BK: u32 = 4;
pub const PERIPHS_IO_MUX_GPIO4_U: u32 = 1610614844;
pub const FUNC_GPIO4: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO5_U: u32 = 1610614848;
pub const FUNC_GPIO5: u32 = 0;
pub const IPSTR: &[u8; 12] = b"%d.%d.%d.%d\0";
pub const ESPCONN_OK: u32 = 0;
pub const ESPCONN_MEM: i32 = -1;
pub const ESPCONN_TIMEOUT: i32 = -3;
pub const ESPCONN_RTE: i32 = -4;
pub const ESPCONN_INPROGRESS: i32 = -5;
pub const ESPCONN_MAXNUM: i32 = -7;
pub const ESPCONN_ABRT: i32 = -8;
pub const ESPCONN_RST: i32 = -9;
pub const ESPCONN_CLSD: i32 = -10;
pub const ESPCONN_CONN: i32 = -11;
pub const ESPCONN_ARG: i32 = -12;
pub const ESPCONN_IF: i32 = -14;
pub const ESPCONN_ISCONN: i32 = -15;
pub const ESPCONN_HANDSHAKE: i32 = -28;
pub const ESPCONN_SSL_INVALID_DATA: i32 = -61;
pub const ETS_SDIO_INUM: u32 = 1;
pub const ETS_SPI_INUM: u32 = 2;
pub const ETS_GPIO_INUM: u32 = 4;
pub const ETS_UART_INUM: u32 = 5;
pub const ETS_UART1_INUM: u32 = 5;
pub const ETS_FRC_TIMER1_INUM: u32 = 9;
pub const PWM_CHANNEL_NUM_MAX: u32 = 8;
pub const _STRING_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC23: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_TIME_BITS64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C23_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 40;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const MEMLEAK_DEBUG_ENABLE: u32 = 0;
pub const MACSTR: &[u8; 30] = b"%02x:%02x:%02x:%02x:%02x:%02x\0";
pub const SYS_BOOT_ENHANCE_MODE: u32 = 0;
pub const SYS_BOOT_NORMAL_MODE: u32 = 1;
pub const SYS_BOOT_NORMAL_BIN: u32 = 0;
pub const SYS_BOOT_TEST_BIN: u32 = 1;
pub const SYS_CPU_80MHZ: u32 = 80;
pub const SYS_CPU_160MHZ: u32 = 160;
pub const NULL_MODE: u32 = 0;
pub const STATION_MODE: u32 = 1;
pub const SOFTAP_MODE: u32 = 2;
pub const STATIONAP_MODE: u32 = 3;
pub const STATION_IF: u32 = 0;
pub const SOFTAP_IF: u32 = 1;
pub const FIXED_RATE_MASK_NONE: u32 = 0;
pub const FIXED_RATE_MASK_STA: u32 = 1;
pub const FIXED_RATE_MASK_AP: u32 = 2;
pub const FIXED_RATE_MASK_ALL: u32 = 3;
pub const RC_LIMIT_11B: u32 = 0;
pub const RC_LIMIT_11G: u32 = 1;
pub const RC_LIMIT_11N: u32 = 2;
pub const RC_LIMIT_P2P_11G: u32 = 3;
pub const RC_LIMIT_P2P_11N: u32 = 4;
pub const RC_LIMIT_NUM: u32 = 5;
pub const LIMIT_RATE_MASK_NONE: u32 = 0;
pub const LIMIT_RATE_MASK_STA: u32 = 1;
pub const LIMIT_RATE_MASK_AP: u32 = 2;
pub const LIMIT_RATE_MASK_ALL: u32 = 3;
pub const ESP_SYSTEM_APP: u32 = 1;
pub const SYS_LIGHTWEIGHT_PROT: u32 = 0;
pub const NO_SYS: u32 = 1;
pub const NO_SYS_NO_TIMERS: u32 = 0;
pub const MEM_LIBC_MALLOC: u32 = 1;
pub const MEMP_MEM_MALLOC: u32 = 1;
pub const MEM_ALIGNMENT: u32 = 4;
pub const MEM_SIZE: u32 = 16000;
pub const MEMP_SEPARATE_POOLS: u32 = 1;
pub const MEMP_OVERFLOW_CHECK: u32 = 0;
pub const MEMP_SANITY_CHECK: u32 = 1;
pub const MEM_USE_POOLS: u32 = 0;
pub const MEM_USE_POOLS_TRY_BIGGER_POOL: u32 = 0;
pub const MEMP_USE_CUSTOM_POOLS: u32 = 0;
pub const LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT: u32 = 0;
pub const MEMP_NUM_PBUF: u32 = 10;
pub const MEMP_NUM_RAW_PCB: u32 = 4;
pub const MEMP_NUM_UDP_PCB: u32 = 4;
pub const MEMP_NUM_TCP_PCB_LISTEN: u32 = 2;
pub const MEMP_NUM_TCP_SEG: u32 = 16;
pub const MEMP_NUM_REASSDATA: u32 = 0;
pub const MEMP_NUM_FRAG_PBUF: u32 = 0;
pub const MEMP_NUM_ARP_QUEUE: u32 = 10;
pub const MEMP_NUM_IGMP_GROUP: u32 = 8;
pub const MEMP_NUM_SYS_TIMEOUT: u32 = 8;
pub const MEMP_NUM_NETBUF: u32 = 0;
pub const MEMP_NUM_NETCONN: u32 = 0;
pub const MEMP_NUM_TCPIP_MSG_API: u32 = 4;
pub const MEMP_NUM_TCPIP_MSG_INPKT: u32 = 4;
pub const MEMP_NUM_SNMP_NODE: u32 = 0;
pub const MEMP_NUM_SNMP_ROOTNODE: u32 = 0;
pub const MEMP_NUM_SNMP_VARBIND: u32 = 0;
pub const MEMP_NUM_SNMP_VALUE: u32 = 0;
pub const MEMP_NUM_NETDB: u32 = 0;
pub const MEMP_NUM_LOCALHOSTLIST: u32 = 0;
pub const MEMP_NUM_PPPOE_INTERFACES: u32 = 0;
pub const PBUF_POOL_SIZE: u32 = 10;
pub const LWIP_ARP: u32 = 1;
pub const ARP_TABLE_SIZE: u32 = 10;
pub const ARP_QUEUEING: u32 = 1;
pub const ETHARP_TRUST_IP_MAC: u32 = 0;
pub const ETHARP_SUPPORT_VLAN: u32 = 0;
pub const ETH_PAD_SIZE: u32 = 0;
pub const ETHARP_SUPPORT_STATIC_ENTRIES: u32 = 0;
pub const IP_FORWARD: u32 = 0;
pub const IP_OPTIONS_ALLOWED: u32 = 1;
pub const IP_REASSEMBLY: u32 = 0;
pub const IP_FRAG: u32 = 0;
pub const IP_REASS_MAXAGE: u32 = 3;
pub const IP_REASS_MAX_PBUFS: u32 = 10;
pub const IP_FRAG_USES_STATIC_BUF: u32 = 1;
pub const IP_FRAG_MAX_MTU: u32 = 1500;
pub const IP_DEFAULT_TTL: u32 = 128;
pub const IP_SOF_BROADCAST: u32 = 0;
pub const IP_SOF_BROADCAST_RECV: u32 = 0;
pub const LWIP_ICMP: u32 = 1;
pub const ICMP_TTL: u32 = 128;
pub const LWIP_BROADCAST_PING: u32 = 0;
pub const LWIP_MULTICAST_PING: u32 = 0;
pub const LWIP_RAW: u32 = 1;
pub const RAW_TTL: u32 = 128;
pub const LWIP_DHCP: u32 = 1;
pub const LWIP_AUTOIP: u32 = 0;
pub const LWIP_DHCP_AUTOIP_COOP: u32 = 0;
pub const LWIP_DHCP_AUTOIP_COOP_TRIES: u32 = 9;
pub const LWIP_SNMP: u32 = 0;
pub const SNMP_CONCURRENT_REQUESTS: u32 = 0;
pub const SNMP_TRAP_DESTINATIONS: u32 = 0;
pub const SNMP_PRIVATE_MIB: u32 = 0;
pub const SNMP_SAFE_REQUESTS: u32 = 0;
pub const SNMP_MAX_OCTET_STRING_LEN: u32 = 127;
pub const SNMP_MAX_TREE_DEPTH: u32 = 15;
pub const LWIP_IGMP: u32 = 1;
pub const LWIP_MDNS: u32 = 1;
pub const LWIP_DNS: u32 = 1;
pub const DNS_TABLE_SIZE: u32 = 4;
pub const DNS_MAX_NAME_LENGTH: u32 = 256;
pub const DNS_MAX_SERVERS: u32 = 2;
pub const DNS_DOES_NAME_CHECK: u32 = 1;
pub const DNS_MSG_SIZE: u32 = 512;
pub const DNS_LOCAL_HOSTLIST: u32 = 0;
pub const DNS_LOCAL_HOSTLIST_IS_DYNAMIC: u32 = 0;
pub const LWIP_UDP: u32 = 1;
pub const LWIP_UDPLITE: u32 = 0;
pub const UDP_TTL: u32 = 128;
pub const LWIP_NETBUF_RECVINFO: u32 = 0;
pub const LWIP_TCP: u32 = 1;
pub const TCP_TTL: u32 = 128;
pub const TCP_MAXRTO: u32 = 10;
pub const TCP_MINRTO: u32 = 2;
pub const TCP_QUEUE_OOSEQ: u32 = 1;
pub const TCP_MSS: u32 = 1460;
pub const TCP_CALCULATE_EFF_SEND_MSS: u32 = 1;
pub const TCP_SND_BUF: u32 = 2920;
pub const TCP_SND_QUEUELEN: u32 = 8;
pub const TCP_SNDLOWAT: u32 = 1460;
pub const TCP_LISTEN_BACKLOG: u32 = 0;
pub const TCP_DEFAULT_LISTEN_BACKLOG: u32 = 255;
pub const TCP_OVERSIZE: u32 = 1460;
pub const LWIP_TCP_TIMESTAMPS: u32 = 0;
pub const LWIP_EVENT_API: u32 = 0;
pub const LWIP_CALLBACK_API: u32 = 1;
pub const PBUF_LINK_HLEN: u32 = 14;
pub const LWIP_NETIF_HOSTNAME: u32 = 1;
pub const LWIP_NETIF_API: u32 = 0;
pub const LWIP_NETIF_STATUS_CALLBACK: u32 = 0;
pub const LWIP_NETIF_LINK_CALLBACK: u32 = 0;
pub const LWIP_NETIF_HWADDRHINT: u32 = 0;
pub const LWIP_NETIF_LOOPBACK: u32 = 0;
pub const LWIP_LOOPBACK_MAX_PBUFS: u32 = 0;
pub const LWIP_NETIF_TX_SINGLE_PBUF: u32 = 1;
pub const LWIP_HAVE_LOOPIF: u32 = 0;
pub const LWIP_HAVE_SLIPIF: u32 = 0;
pub const TCPIP_THREAD_NAME: &[u8; 13] = b"tcpip_thread\0";
pub const TCPIP_THREAD_STACKSIZE: u32 = 0;
pub const TCPIP_THREAD_PRIO: u32 = 1;
pub const TCPIP_MBOX_SIZE: u32 = 0;
pub const SLIPIF_THREAD_NAME: &[u8; 12] = b"slipif_loop\0";
pub const SLIPIF_THREAD_STACKSIZE: u32 = 0;
pub const SLIPIF_THREAD_PRIO: u32 = 1;
pub const PPP_THREAD_NAME: &[u8; 15] = b"pppInputThread\0";
pub const PPP_THREAD_STACKSIZE: u32 = 0;
pub const PPP_THREAD_PRIO: u32 = 1;
pub const DEFAULT_THREAD_NAME: &[u8; 5] = b"lwIP\0";
pub const DEFAULT_THREAD_STACKSIZE: u32 = 0;
pub const DEFAULT_THREAD_PRIO: u32 = 1;
pub const DEFAULT_RAW_RECVMBOX_SIZE: u32 = 0;
pub const DEFAULT_UDP_RECVMBOX_SIZE: u32 = 0;
pub const DEFAULT_TCP_RECVMBOX_SIZE: u32 = 0;
pub const DEFAULT_ACCEPTMBOX_SIZE: u32 = 0;
pub const LWIP_TCPIP_CORE_LOCKING: u32 = 0;
pub const LWIP_TCPIP_CORE_LOCKING_INPUT: u32 = 0;
pub const LWIP_NETCONN: u32 = 0;
pub const LWIP_TCPIP_TIMEOUT: u32 = 1;
pub const LWIP_SOCKET: u32 = 0;
pub const LWIP_COMPAT_SOCKETS: u32 = 0;
pub const LWIP_POSIX_SOCKETS_IO_NAMES: u32 = 0;
pub const LWIP_TCP_KEEPALIVE: u32 = 1;
pub const LWIP_SO_RCVTIMEO: u32 = 0;
pub const LWIP_SO_RCVBUF: u32 = 0;
pub const SO_REUSE: u32 = 0;
pub const SO_REUSE_RXTOALL: u32 = 0;
pub const LWIP_STATS: u32 = 0;
pub const ETHARP_STATS: u32 = 0;
pub const LINK_STATS: u32 = 0;
pub const IP_STATS: u32 = 0;
pub const IPFRAG_STATS: u32 = 0;
pub const ICMP_STATS: u32 = 0;
pub const IGMP_STATS: u32 = 0;
pub const UDP_STATS: u32 = 0;
pub const TCP_STATS: u32 = 0;
pub const MEM_STATS: u32 = 0;
pub const MEMP_STATS: u32 = 0;
pub const SYS_STATS: u32 = 0;
pub const LWIP_STATS_DISPLAY: u32 = 0;
pub const PPP_SUPPORT: u32 = 0;
pub const PPPOE_SUPPORT: u32 = 0;
pub const PPPOS_SUPPORT: u32 = 0;
pub const CHECKSUM_GEN_IP: u32 = 1;
pub const CHECKSUM_GEN_UDP: u32 = 1;
pub const CHECKSUM_GEN_TCP: u32 = 1;
pub const CHECKSUM_CHECK_IP: u32 = 1;
pub const CHECKSUM_CHECK_UDP: u32 = 1;
pub const CHECKSUM_CHECK_TCP: u32 = 1;
pub const LWIP_CHECKSUM_ON_COPY: u32 = 0;
pub type sint8_t = ::core::ffi::c_schar;
pub type sint16_t = ::core::ffi::c_short;
pub type sint32_t = ::core::ffi::c_int;
pub type sint64_t = ::core::ffi::c_longlong;
pub type u_int64_t = ::core::ffi::c_ulonglong;
pub type real32_t = f32;
pub type real64_t = f64;
pub type uint8 = ::core::ffi::c_uchar;
pub type u8_ = ::core::ffi::c_uchar;
pub type sint8 = ::core::ffi::c_schar;
pub type int8 = ::core::ffi::c_schar;
pub type s8 = ::core::ffi::c_schar;
pub type uint16 = ::core::ffi::c_ushort;
pub type u16_ = ::core::ffi::c_ushort;
pub type sint16 = ::core::ffi::c_short;
pub type s16 = ::core::ffi::c_short;
pub type uint32 = ::core::ffi::c_uint;
pub type u_int = ::core::ffi::c_uint;
pub type u32_ = ::core::ffi::c_uint;
pub type sint32 = ::core::ffi::c_int;
pub type s32 = ::core::ffi::c_int;
pub type int32 = ::core::ffi::c_int;
pub type sint64 = ::core::ffi::c_longlong;
pub type uint64 = ::core::ffi::c_ulonglong;
pub type u64_ = ::core::ffi::c_ulonglong;
pub type real32 = f32;
pub type real64 = f64;
pub const STATUS_OK: STATUS = 0;
pub const STATUS_FAIL: STATUS = 1;
pub const STATUS_PENDING: STATUS = 2;
pub const STATUS_BUSY: STATUS = 3;
pub const STATUS_CANCEL: STATUS = 4;
pub type STATUS = ::core::ffi::c_uint;
pub type bool_ = ::core::ffi::c_uchar;
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_DISABLE: GPIO_INT_TYPE = 0;
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_POSEDGE: GPIO_INT_TYPE = 1;
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_NEGEDGE: GPIO_INT_TYPE = 2;
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_ANYEDGE: GPIO_INT_TYPE = 3;
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_LOLEVEL: GPIO_INT_TYPE = 4;
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_HILEVEL: GPIO_INT_TYPE = 5;
pub type GPIO_INT_TYPE = ::core::ffi::c_uint;
pub type gpio_intr_handler_fn_t =
    ::core::option::Option<unsafe extern "C" fn(intr_mask: uint32, arg: *mut ::core::ffi::c_void)>;
pub type upgrade_states_check_callback =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct upgrade_server_info {
    pub ip: [uint8; 4usize],
    pub port: uint16,
    pub upgrade_flag: uint8,
    pub pre_version: [uint8; 16usize],
    pub upgrade_version: [uint8; 16usize],
    pub check_times: uint32,
    pub url: *mut uint8,
    pub check_cb: upgrade_states_check_callback,
    pub pespconn: *mut espconn,
}
pub const SP_ST_t_SP_ST_STA_FINISH: SP_ST_t = 0;
pub const SP_ST_t_SP_ST_AP_FINISH: SP_ST_t = 0;
pub const SP_ST_t_SP_ST_AP_RECV_NEG: SP_ST_t = 1;
pub const SP_ST_t_SP_ST_STA_AP_REFUSE_NEG: SP_ST_t = 2;
pub const SP_ST_t_SP_ST_WAIT_TIMEOUT: SP_ST_t = 3;
pub const SP_ST_t_SP_ST_SEND_ERROR: SP_ST_t = 4;
pub const SP_ST_t_SP_ST_KEY_INSTALL_ERR: SP_ST_t = 5;
pub const SP_ST_t_SP_ST_KEY_OVERLAP_ERR: SP_ST_t = 6;
pub const SP_ST_t_SP_ST_OP_ERROR: SP_ST_t = 7;
pub const SP_ST_t_SP_ST_UNKNOWN_ERROR: SP_ST_t = 8;
pub const SP_ST_t_SP_ST_MAX: SP_ST_t = 9;
pub type SP_ST_t = ::core::ffi::c_uint;
pub type simple_pair_status_cb_t =
    ::core::option::Option<unsafe extern "C" fn(sa: *mut u8_, status: u8_)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_addr {
    pub addr: uint32,
}
pub type ip_addr_t = ip_addr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_info {
    pub ip: ip_addr,
    pub netmask: ip_addr,
    pub gw: ip_addr,
}
pub type err_t = sint8;
pub type espconn_handle = *mut ::core::ffi::c_void;
pub type espconn_connect_callback =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void)>;
pub type espconn_reconnect_callback =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, err: sint8)>;
pub const espconn_type_ESPCONN_INVALID: espconn_type = 0;
pub const espconn_type_ESPCONN_TCP: espconn_type = 16;
pub const espconn_type_ESPCONN_UDP: espconn_type = 32;
#[doc = " Protocol family and type of the espconn"]
pub type espconn_type = ::core::ffi::c_uint;
pub const espconn_state_ESPCONN_NONE: espconn_state = 0;
pub const espconn_state_ESPCONN_WAIT: espconn_state = 1;
pub const espconn_state_ESPCONN_LISTEN: espconn_state = 2;
pub const espconn_state_ESPCONN_CONNECT: espconn_state = 3;
pub const espconn_state_ESPCONN_WRITE: espconn_state = 4;
pub const espconn_state_ESPCONN_READ: espconn_state = 5;
pub const espconn_state_ESPCONN_CLOSE: espconn_state = 6;
#[doc = " Current state of the espconn. Non-TCP espconn are always in state ESPCONN_NONE!"]
pub type espconn_state = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _esp_tcp {
    pub remote_port: ::core::ffi::c_int,
    pub local_port: ::core::ffi::c_int,
    pub local_ip: [uint8; 4usize],
    pub remote_ip: [uint8; 4usize],
    pub connect_callback: espconn_connect_callback,
    pub reconnect_callback: espconn_reconnect_callback,
    pub disconnect_callback: espconn_connect_callback,
    pub write_finish_fn: espconn_connect_callback,
}
pub type esp_tcp = _esp_tcp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _esp_udp {
    pub remote_port: ::core::ffi::c_int,
    pub local_port: ::core::ffi::c_int,
    pub local_ip: [uint8; 4usize],
    pub remote_ip: [uint8; 4usize],
}
pub type esp_udp = _esp_udp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _remot_info {
    pub state: espconn_state,
    pub remote_port: ::core::ffi::c_int,
    pub remote_ip: [uint8; 4usize],
}
pub type remot_info = _remot_info;
#[doc = " A callback prototype to inform about events for a espconn"]
pub type espconn_recv_callback = ::core::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::core::ffi::c_void,
        pdata: *mut ::core::ffi::c_char,
        len: ::core::ffi::c_ushort,
    ),
>;
pub type espconn_sent_callback =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void)>;
#[doc = " A espconn descriptor"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct espconn {
    #[doc = " type of the espconn (TCP, UDP)"]
    pub type_: espconn_type,
    #[doc = " current state of the espconn"]
    pub state: espconn_state,
    pub proto: espconn__bindgen_ty_1,
    #[doc = " A callback function that is informed about events for this espconn"]
    pub recv_callback: espconn_recv_callback,
    pub sent_callback: espconn_sent_callback,
    pub link_cnt: uint8,
    pub reverse: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union espconn__bindgen_ty_1 {
    pub tcp: *mut esp_tcp,
    pub udp: *mut esp_udp,
}
pub const espconn_option_ESPCONN_START: espconn_option = 0;
pub const espconn_option_ESPCONN_REUSEADDR: espconn_option = 1;
pub const espconn_option_ESPCONN_NODELAY: espconn_option = 2;
pub const espconn_option_ESPCONN_COPY: espconn_option = 4;
pub const espconn_option_ESPCONN_KEEPALIVE: espconn_option = 8;
pub const espconn_option_ESPCONN_MANUALRECV: espconn_option = 16;
pub const espconn_option_ESPCONN_END: espconn_option = 17;
pub type espconn_option = ::core::ffi::c_uint;
pub const espconn_level_ESPCONN_KEEPIDLE: espconn_level = 0;
pub const espconn_level_ESPCONN_KEEPINTVL: espconn_level = 1;
pub const espconn_level_ESPCONN_KEEPCNT: espconn_level = 2;
pub type espconn_level = ::core::ffi::c_uint;
pub const ESPCONN_IDLE: _bindgen_ty_1 = 0;
pub const ESPCONN_CLIENT: _bindgen_ty_1 = 1;
pub const ESPCONN_SERVER: _bindgen_ty_1 = 2;
pub const ESPCONN_BOTH: _bindgen_ty_1 = 3;
pub const ESPCONN_MAX: _bindgen_ty_1 = 4;
pub type _bindgen_ty_1 = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct espconn_packet {
    pub sent_length: uint16,
    pub snd_buf_size: uint16,
    pub snd_queuelen: uint16,
    pub total_queuelen: uint16,
    pub packseqno: uint32,
    pub packseq_nxt: uint32,
    pub packnum: uint32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mdns_info {
    pub host_name: *mut ::core::ffi::c_char,
    pub server_name: *mut ::core::ffi::c_char,
    pub server_port: uint16,
    pub ipAddr: ::core::ffi::c_ulong,
    pub txt_data: [*mut ::core::ffi::c_char; 10usize],
}
#[doc = " TypedefName : dns_found_callback\n Description : Callback which is invoked when a hostname is found.\n Parameters  : name -- pointer to the name that was looked up.\n               ipaddr -- pointer to an ip_addr_t containing the IP address of\n               the hostname, or NULL if the name could not be found (or on any\n               other error).\n               callback_arg -- a user-specified callback argument passed to\n               dns_gethostbyname"]
pub type dns_found_callback = ::core::option::Option<
    unsafe extern "C" fn(
        name: *const ::core::ffi::c_char,
        ipaddr: *mut ip_addr_t,
        callback_arg: *mut ::core::ffi::c_void,
    ),
>;
pub type os_time_t = ::core::ffi::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct os_time {
    pub sec: os_time_t,
    pub usec: os_time_t,
}
pub type get_time_func_t =
    ::core::option::Option<unsafe extern "C" fn(t: *mut os_time) -> ::core::ffi::c_int>;
pub type airkiss_memset_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ptr: *mut ::core::ffi::c_void,
        value: ::core::ffi::c_int,
        num: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void,
>;
pub type airkiss_memcpy_fn = ::core::option::Option<
    unsafe extern "C" fn(
        dst: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        num: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void,
>;
pub type airkiss_memcmp_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ptr1: *const ::core::ffi::c_void,
        ptr2: *const ::core::ffi::c_void,
        num: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int,
>;
pub type airkiss_printf_fn = ::core::option::Option<
    unsafe extern "C" fn(format: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct airkiss_config_t {
    pub memset: airkiss_memset_fn,
    pub memcpy: airkiss_memcpy_fn,
    pub memcmp: airkiss_memcmp_fn,
    pub printf: airkiss_printf_fn,
}
pub const airkiss_lan_ret_t_AIRKISS_LAN_ERR_OVERFLOW: airkiss_lan_ret_t = -5;
pub const airkiss_lan_ret_t_AIRKISS_LAN_ERR_CMD: airkiss_lan_ret_t = -4;
pub const airkiss_lan_ret_t_AIRKISS_LAN_ERR_PAKE: airkiss_lan_ret_t = -3;
pub const airkiss_lan_ret_t_AIRKISS_LAN_ERR_PARA: airkiss_lan_ret_t = -2;
pub const airkiss_lan_ret_t_AIRKISS_LAN_ERR_PKG: airkiss_lan_ret_t = -1;
pub const airkiss_lan_ret_t_AIRKISS_LAN_CONTINUE: airkiss_lan_ret_t = 0;
pub const airkiss_lan_ret_t_AIRKISS_LAN_SSDP_REQ: airkiss_lan_ret_t = 1;
pub const airkiss_lan_ret_t_AIRKISS_LAN_PAKE_READY: airkiss_lan_ret_t = 2;
pub type airkiss_lan_ret_t = ::core::ffi::c_int;
pub const airkiss_lan_cmdid_t_AIRKISS_LAN_SSDP_REQ_CMD: airkiss_lan_cmdid_t = 1;
pub const airkiss_lan_cmdid_t_AIRKISS_LAN_SSDP_RESP_CMD: airkiss_lan_cmdid_t = 4097;
pub const airkiss_lan_cmdid_t_AIRKISS_LAN_SSDP_NOTIFY_CMD: airkiss_lan_cmdid_t = 4098;
pub type airkiss_lan_cmdid_t = ::core::ffi::c_uint;
pub const sc_status_SC_STATUS_WAIT: sc_status = 0;
pub const sc_status_SC_STATUS_FIND_CHANNEL: sc_status = 1;
pub const sc_status_SC_STATUS_GETTING_SSID_PSWD: sc_status = 2;
pub const sc_status_SC_STATUS_LINK: sc_status = 3;
pub const sc_status_SC_STATUS_LINK_OVER: sc_status = 4;
pub type sc_status = ::core::ffi::c_uint;
pub const sc_type_SC_TYPE_ESPTOUCH: sc_type = 0;
pub const sc_type_SC_TYPE_AIRKISS: sc_type = 1;
pub const sc_type_SC_TYPE_ESPTOUCH_AIRKISS: sc_type = 2;
pub type sc_type = ::core::ffi::c_uint;
pub type sc_callback_t = ::core::option::Option<
    unsafe extern "C" fn(status: sc_status, pdata: *mut ::core::ffi::c_void),
>;
pub type ETSSignal = u32;
pub type ETSParam = u32;
pub type ETSEvent = ETSEventTag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ETSEventTag {
    pub sig: ETSSignal,
    pub par: ETSParam,
}
pub type ETSTask = ::core::option::Option<unsafe extern "C" fn(e: *mut ETSEvent)>;
pub type ETSHandle = u32;
pub type ETSTimerFunc =
    ::core::option::Option<unsafe extern "C" fn(timer_arg: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETSTIMER_ {
    pub timer_next: *mut _ETSTIMER_,
    pub timer_expire: u32,
    pub timer_period: u32,
    pub timer_func: ETSTimerFunc,
    pub timer_arg: *mut ::core::ffi::c_void,
}
pub type ETSTimer = _ETSTIMER_;
pub type ets_isr_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
pub const esp_now_role_ESP_NOW_ROLE_IDLE: esp_now_role = 0;
pub const esp_now_role_ESP_NOW_ROLE_CONTROLLER: esp_now_role = 1;
pub const esp_now_role_ESP_NOW_ROLE_SLAVE: esp_now_role = 2;
pub const esp_now_role_ESP_NOW_ROLE_COMBO: esp_now_role = 3;
pub const esp_now_role_ESP_NOW_ROLE_MAX: esp_now_role = 4;
pub type esp_now_role = ::core::ffi::c_uint;
pub type esp_now_recv_cb_t =
    ::core::option::Option<unsafe extern "C" fn(mac_addr: *mut u8_, data: *mut u8_, len: u8_)>;
pub type esp_now_send_cb_t =
    ::core::option::Option<unsafe extern "C" fn(mac_addr: *mut u8_, status: u8_)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pwm_param {
    pub period: uint32,
    pub freq: uint32,
    pub duty: [uint32; 8usize],
}
pub const default_certificate_len: ::core::ffi::c_uint = 843;
pub const SpiFlashOpResult_SPI_FLASH_RESULT_OK: SpiFlashOpResult = 0;
pub const SpiFlashOpResult_SPI_FLASH_RESULT_ERR: SpiFlashOpResult = 1;
pub const SpiFlashOpResult_SPI_FLASH_RESULT_TIMEOUT: SpiFlashOpResult = 2;
pub type SpiFlashOpResult = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SpiFlashChip {
    pub deviceId: uint32,
    pub chip_size: uint32,
    pub block_size: uint32,
    pub sector_size: uint32,
    pub page_size: uint32,
    pub status_mask: uint32,
}
pub type user_spi_flash_read = ::core::option::Option<
    unsafe extern "C" fn(
        spi: *mut SpiFlashChip,
        src_addr: uint32,
        des_addr: *mut uint32,
        size: uint32,
    ) -> SpiFlashOpResult,
>;
pub type ping_recv_function = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, pdata: *mut ::core::ffi::c_void),
>;
pub type ping_sent_function = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, pdata: *mut ::core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ping_option {
    pub count: uint32,
    pub ip: uint32,
    pub coarse_time: uint32,
    pub recv_function: ping_recv_function,
    pub sent_function: ping_sent_function,
    pub reverse: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ping_resp {
    pub total_count: uint32,
    pub resp_time: uint32,
    pub seqno: uint32,
    pub timeout_count: uint32,
    pub bytes: uint32,
    pub total_bytes: uint32,
    pub total_time: uint32,
    pub ping_err: sint8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct at_funcationType {
    pub at_cmdName: *mut ::core::ffi::c_char,
    pub at_cmdLen: i8,
    pub at_testCmd: ::core::option::Option<unsafe extern "C" fn(id: u8)>,
    pub at_queryCmd: ::core::option::Option<unsafe extern "C" fn(id: u8)>,
    pub at_setupCmd:
        ::core::option::Option<unsafe extern "C" fn(id: u8, pPara: *mut ::core::ffi::c_char)>,
    pub at_exeCmd: ::core::option::Option<unsafe extern "C" fn(id: u8)>,
}
pub type at_custom_uart_rx_intr =
    ::core::option::Option<unsafe extern "C" fn(data: *mut uint8, len: int32)>;
pub type at_custom_response_func_type =
    ::core::option::Option<unsafe extern "C" fn(str_: *const ::core::ffi::c_char)>;
pub type at_fake_uart_tx_func_type =
    ::core::option::Option<unsafe extern "C" fn(data: *const uint8, length: uint32)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::core::ffi::c_ushort,
    pub __ctype_tolower: *const ::core::ffi::c_int,
    pub __ctype_toupper: *const ::core::ffi::c_int,
    pub __names: [*const ::core::ffi::c_char; 13usize],
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
pub const default_private_key_len: ::core::ffi::c_uint = 916;
pub type wchar_t = ::core::ffi::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::core::ffi::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
pub const rst_reason_REASON_DEFAULT_RST: rst_reason = 0;
pub const rst_reason_REASON_WDT_RST: rst_reason = 1;
pub const rst_reason_REASON_EXCEPTION_RST: rst_reason = 2;
pub const rst_reason_REASON_SOFT_WDT_RST: rst_reason = 3;
pub const rst_reason_REASON_SOFT_RESTART: rst_reason = 4;
pub const rst_reason_REASON_DEEP_SLEEP_AWAKE: rst_reason = 5;
pub const rst_reason_REASON_EXT_SYS_RST: rst_reason = 6;
pub type rst_reason = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rst_info {
    pub reason: uint32,
    pub exccause: uint32,
    pub epc1: uint32,
    pub epc2: uint32,
    pub epc3: uint32,
    pub excvaddr: uint32,
    pub depc: uint32,
}
pub const USER_TASK_PRIO_0: _bindgen_ty_2 = 0;
pub const USER_TASK_PRIO_1: _bindgen_ty_2 = 1;
pub const USER_TASK_PRIO_2: _bindgen_ty_2 = 2;
pub const USER_TASK_PRIO_MAX: _bindgen_ty_2 = 3;
pub type _bindgen_ty_2 = ::core::ffi::c_uint;
pub type init_done_cb_t = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = "<  Flash size : 4Mbits. Map : 256KBytes + 256KBytes"]
pub const flash_size_map_FLASH_SIZE_4M_MAP_256_256: flash_size_map = 0;
#[doc = "<  Flash size : 2Mbits. Map : 256KBytes"]
pub const flash_size_map_FLASH_SIZE_2M: flash_size_map = 1;
#[doc = "<  Flash size : 8Mbits. Map : 512KBytes + 512KBytes"]
pub const flash_size_map_FLASH_SIZE_8M_MAP_512_512: flash_size_map = 2;
#[doc = "<  Flash size : 16Mbits. Map : 512KBytes + 512KBytes"]
pub const flash_size_map_FLASH_SIZE_16M_MAP_512_512: flash_size_map = 3;
#[doc = "<  Flash size : 32Mbits. Map : 512KBytes + 512KBytes"]
pub const flash_size_map_FLASH_SIZE_32M_MAP_512_512: flash_size_map = 4;
#[doc = "<  Flash size : 16Mbits. Map : 1024KBytes + 1024KBytes"]
pub const flash_size_map_FLASH_SIZE_16M_MAP_1024_1024: flash_size_map = 5;
#[doc = "<  Flash size : 32Mbits. Map : 1024KBytes + 1024KBytes"]
pub const flash_size_map_FLASH_SIZE_32M_MAP_1024_1024: flash_size_map = 6;
#[doc = "<  attention: don't support now ,just compatible for nodemcu;\nFlash size : 32Mbits. Map : 2048KBytes + 2048KBytes"]
pub const flash_size_map_FLASH_SIZE_32M_MAP_2048_2048: flash_size_map = 7;
#[doc = "<  Flash size : 64Mbits. Map : 1024KBytes + 1024KBytes"]
pub const flash_size_map_FLASH_SIZE_64M_MAP_1024_1024: flash_size_map = 8;
#[doc = "<  Flash size : 128Mbits. Map : 1024KBytes + 1024KBytes"]
pub const flash_size_map_FLASH_SIZE_128M_MAP_1024_1024: flash_size_map = 9;
pub type flash_size_map = ::core::ffi::c_uint;
pub const _auth_mode_AUTH_OPEN: _auth_mode = 0;
pub const _auth_mode_AUTH_WEP: _auth_mode = 1;
pub const _auth_mode_AUTH_WPA_PSK: _auth_mode = 2;
pub const _auth_mode_AUTH_WPA2_PSK: _auth_mode = 3;
pub const _auth_mode_AUTH_WPA_WPA2_PSK: _auth_mode = 4;
pub const _auth_mode_AUTH_MAX: _auth_mode = 5;
pub type _auth_mode = ::core::ffi::c_uint;
pub use self::_auth_mode as AUTH_MODE;
pub const _cipher_type_CIPHER_NONE: _cipher_type = 0;
pub const _cipher_type_CIPHER_WEP40: _cipher_type = 1;
pub const _cipher_type_CIPHER_WEP104: _cipher_type = 2;
pub const _cipher_type_CIPHER_TKIP: _cipher_type = 3;
pub const _cipher_type_CIPHER_CCMP: _cipher_type = 4;
pub const _cipher_type_CIPHER_TKIP_CCMP: _cipher_type = 5;
pub const _cipher_type_CIPHER_UNKNOWN: _cipher_type = 6;
pub type _cipher_type = ::core::ffi::c_uint;
pub use self::_cipher_type as CIPHER_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bss_info {
    pub next: bss_info__bindgen_ty_1,
    pub bssid: [uint8; 6usize],
    pub ssid: [uint8; 32usize],
    pub ssid_len: uint8,
    pub channel: uint8,
    pub rssi: sint8,
    pub authmode: AUTH_MODE,
    pub is_hidden: uint8,
    pub freq_offset: sint16,
    pub freqcal_val: sint16,
    pub esp_mesh_ie: *mut uint8,
    pub simple_pair: uint8,
    pub pairwise_cipher: CIPHER_TYPE,
    pub group_cipher: CIPHER_TYPE,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bss_info__bindgen_ty_1 {
    pub stqe_next: *mut bss_info,
}
impl bss_info {
    #[inline]
    pub fn phy_11b(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11b(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn phy_11b_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_phy_11b_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn phy_11g(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11g(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn phy_11g_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_phy_11g_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn phy_11n(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11n(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn phy_11n_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_phy_11n_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wps(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wps(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wps_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wps_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                28u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                28u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        phy_11b: u32,
        phy_11g: u32,
        phy_11n: u32,
        wps: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let phy_11b: u32 = unsafe { ::core::mem::transmute(phy_11b) };
            phy_11b as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let phy_11g: u32 = unsafe { ::core::mem::transmute(phy_11g) };
            phy_11g as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let phy_11n: u32 = unsafe { ::core::mem::transmute(phy_11n) };
            phy_11n as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let wps: u32 = unsafe { ::core::mem::transmute(wps) };
            wps as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _scaninfo {
    pub pbss: *mut _scaninfo__bindgen_ty_1,
    pub pespconn: *mut espconn,
    pub totalpage: uint8,
    pub pagenum: uint8,
    pub page_sn: uint8,
    pub data_cnt: uint8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _scaninfo__bindgen_ty_1 {
    pub stqh_first: *mut bss_info,
    pub stqh_last: *mut *mut bss_info,
}
pub type scaninfo = _scaninfo;
pub type scan_done_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, status: STATUS)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_fast_scan_threshold_t {
    pub rssi: int8,
    pub authmode: AUTH_MODE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct station_config {
    pub ssid: [uint8; 32usize],
    pub password: [uint8; 64usize],
    pub channel: uint8,
    pub bssid_set: uint8,
    pub bssid: [uint8; 6usize],
    pub threshold: wifi_fast_scan_threshold_t,
    pub open_and_wep_mode_disable: bool_,
    pub all_channel_scan: bool_,
}
#[doc = "< active scan"]
pub const wifi_scan_type_t_WIFI_SCAN_TYPE_ACTIVE: wifi_scan_type_t = 0;
#[doc = "< passive scan"]
pub const wifi_scan_type_t_WIFI_SCAN_TYPE_PASSIVE: wifi_scan_type_t = 1;
pub type wifi_scan_type_t = ::core::ffi::c_uint;
#[doc = " @brief Range of active scan times per channel"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_active_scan_time_t {
    #[doc = "< minimum active scan time per channel, units: millisecond"]
    pub min: u32,
    #[doc = "< maximum active scan time per channel, units: millisecond, values above 1500ms may\ncause station to disconnect from AP and are not recommended."]
    pub max: u32,
}
#[doc = " @brief Aggregate of active & passive scan time per channel"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union wifi_scan_time_t {
    #[doc = "< active scan time per channel, units: millisecond."]
    pub active: wifi_active_scan_time_t,
    #[doc = "< passive scan time per channel, units: millisecond, values above 1500ms may\ncause station to disconnect from AP and are not recommended."]
    pub passive: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct scan_config {
    pub ssid: *mut uint8,
    pub bssid: *mut uint8,
    pub channel: uint8,
    pub show_hidden: uint8,
    pub scan_type: wifi_scan_type_t,
    pub scan_time: wifi_scan_time_t,
}
pub const STATION_IDLE: _bindgen_ty_3 = 0;
pub const STATION_CONNECTING: _bindgen_ty_3 = 1;
pub const STATION_WRONG_PASSWORD: _bindgen_ty_3 = 2;
pub const STATION_NO_AP_FOUND: _bindgen_ty_3 = 3;
pub const STATION_CONNECT_FAIL: _bindgen_ty_3 = 4;
pub const STATION_GOT_IP: _bindgen_ty_3 = 5;
pub type _bindgen_ty_3 = ::core::ffi::c_uint;
pub const dhcp_status_DHCP_STOPPED: dhcp_status = 0;
pub const dhcp_status_DHCP_STARTED: dhcp_status = 1;
pub type dhcp_status = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct softap_config {
    pub ssid: [uint8; 32usize],
    pub password: [uint8; 64usize],
    pub ssid_len: uint8,
    pub channel: uint8,
    pub authmode: AUTH_MODE,
    pub ssid_hidden: uint8,
    pub max_connection: uint8,
    pub beacon_interval: uint16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct station_info {
    pub next: station_info__bindgen_ty_1,
    pub bssid: [uint8; 6usize],
    pub ip: ip_addr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct station_info__bindgen_ty_1 {
    pub stqe_next: *mut station_info,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dhcps_lease {
    pub enable: bool_,
    pub start_ip: ip_addr,
    pub end_ip: ip_addr,
}
pub const dhcps_offer_option_OFFER_START: dhcps_offer_option = 0;
pub const dhcps_offer_option_OFFER_ROUTER: dhcps_offer_option = 1;
pub const dhcps_offer_option_OFFER_END: dhcps_offer_option = 2;
pub type dhcps_offer_option = ::core::ffi::c_uint;
pub type wifi_promiscuous_cb_t =
    ::core::option::Option<unsafe extern "C" fn(buf: *mut uint8, len: uint16)>;
pub const phy_mode_PHY_MODE_11B: phy_mode = 1;
pub const phy_mode_PHY_MODE_11G: phy_mode = 2;
pub const phy_mode_PHY_MODE_11N: phy_mode = 3;
pub type phy_mode = ::core::ffi::c_uint;
pub const sleep_type_NONE_SLEEP_T: sleep_type = 0;
pub const sleep_type_LIGHT_SLEEP_T: sleep_type = 1;
pub const sleep_type_MODEM_SLEEP_T: sleep_type = 2;
pub type sleep_type = ::core::ffi::c_uint;
pub const sleep_level_MIN_SLEEP_T: sleep_level = 0;
pub const sleep_level_MAX_SLEEP_T: sleep_level = 1;
pub type sleep_level = ::core::ffi::c_uint;
pub type fpm_wakeup_cb = ::core::option::Option<unsafe extern "C" fn()>;
pub const EVENT_STAMODE_CONNECTED: _bindgen_ty_4 = 0;
pub const EVENT_STAMODE_DISCONNECTED: _bindgen_ty_4 = 1;
pub const EVENT_STAMODE_AUTHMODE_CHANGE: _bindgen_ty_4 = 2;
pub const EVENT_STAMODE_GOT_IP: _bindgen_ty_4 = 3;
pub const EVENT_STAMODE_DHCP_TIMEOUT: _bindgen_ty_4 = 4;
pub const EVENT_SOFTAPMODE_STACONNECTED: _bindgen_ty_4 = 5;
pub const EVENT_SOFTAPMODE_STADISCONNECTED: _bindgen_ty_4 = 6;
pub const EVENT_SOFTAPMODE_PROBEREQRECVED: _bindgen_ty_4 = 7;
pub const EVENT_OPMODE_CHANGED: _bindgen_ty_4 = 8;
pub const EVENT_SOFTAPMODE_DISTRIBUTE_STA_IP: _bindgen_ty_4 = 9;
pub const EVENT_MAX: _bindgen_ty_4 = 10;
pub type _bindgen_ty_4 = ::core::ffi::c_uint;
pub const REASON_UNSPECIFIED: _bindgen_ty_5 = 1;
pub const REASON_AUTH_EXPIRE: _bindgen_ty_5 = 2;
pub const REASON_AUTH_LEAVE: _bindgen_ty_5 = 3;
pub const REASON_ASSOC_EXPIRE: _bindgen_ty_5 = 4;
pub const REASON_ASSOC_TOOMANY: _bindgen_ty_5 = 5;
pub const REASON_NOT_AUTHED: _bindgen_ty_5 = 6;
pub const REASON_NOT_ASSOCED: _bindgen_ty_5 = 7;
pub const REASON_ASSOC_LEAVE: _bindgen_ty_5 = 8;
pub const REASON_ASSOC_NOT_AUTHED: _bindgen_ty_5 = 9;
pub const REASON_DISASSOC_PWRCAP_BAD: _bindgen_ty_5 = 10;
pub const REASON_DISASSOC_SUPCHAN_BAD: _bindgen_ty_5 = 11;
pub const REASON_IE_INVALID: _bindgen_ty_5 = 13;
pub const REASON_MIC_FAILURE: _bindgen_ty_5 = 14;
pub const REASON_4WAY_HANDSHAKE_TIMEOUT: _bindgen_ty_5 = 15;
pub const REASON_GROUP_KEY_UPDATE_TIMEOUT: _bindgen_ty_5 = 16;
pub const REASON_IE_IN_4WAY_DIFFERS: _bindgen_ty_5 = 17;
pub const REASON_GROUP_CIPHER_INVALID: _bindgen_ty_5 = 18;
pub const REASON_PAIRWISE_CIPHER_INVALID: _bindgen_ty_5 = 19;
pub const REASON_AKMP_INVALID: _bindgen_ty_5 = 20;
pub const REASON_UNSUPP_RSN_IE_VERSION: _bindgen_ty_5 = 21;
pub const REASON_INVALID_RSN_IE_CAP: _bindgen_ty_5 = 22;
pub const REASON_802_1X_AUTH_FAILED: _bindgen_ty_5 = 23;
pub const REASON_CIPHER_SUITE_REJECTED: _bindgen_ty_5 = 24;
pub const REASON_BEACON_TIMEOUT: _bindgen_ty_5 = 200;
pub const REASON_NO_AP_FOUND: _bindgen_ty_5 = 201;
pub const REASON_AUTH_FAIL: _bindgen_ty_5 = 202;
pub const REASON_ASSOC_FAIL: _bindgen_ty_5 = 203;
pub const REASON_HANDSHAKE_TIMEOUT: _bindgen_ty_5 = 204;
pub type _bindgen_ty_5 = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Event_StaMode_Connected_t {
    pub ssid: [uint8; 32usize],
    pub ssid_len: uint8,
    pub bssid: [uint8; 6usize],
    pub channel: uint8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Event_StaMode_Disconnected_t {
    pub ssid: [uint8; 32usize],
    pub ssid_len: uint8,
    pub bssid: [uint8; 6usize],
    pub reason: uint8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Event_StaMode_AuthMode_Change_t {
    pub old_mode: uint8,
    pub new_mode: uint8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Event_StaMode_Got_IP_t {
    pub ip: ip_addr,
    pub mask: ip_addr,
    pub gw: ip_addr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Event_SoftAPMode_StaConnected_t {
    pub mac: [uint8; 6usize],
    pub aid: uint8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Event_SoftAPMode_Distribute_Sta_IP_t {
    pub mac: [uint8; 6usize],
    pub ip: ip_addr,
    pub aid: uint8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Event_SoftAPMode_StaDisconnected_t {
    pub mac: [uint8; 6usize],
    pub aid: uint8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Event_SoftAPMode_ProbeReqRecved_t {
    pub rssi: ::core::ffi::c_int,
    pub mac: [uint8; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Event_OpMode_Change_t {
    pub old_opmode: uint8,
    pub new_opmode: uint8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Event_Info_u {
    pub connected: Event_StaMode_Connected_t,
    pub disconnected: Event_StaMode_Disconnected_t,
    pub auth_change: Event_StaMode_AuthMode_Change_t,
    pub got_ip: Event_StaMode_Got_IP_t,
    pub sta_connected: Event_SoftAPMode_StaConnected_t,
    pub distribute_sta_ip: Event_SoftAPMode_Distribute_Sta_IP_t,
    pub sta_disconnected: Event_SoftAPMode_StaDisconnected_t,
    pub ap_probereqrecved: Event_SoftAPMode_ProbeReqRecved_t,
    pub opmode_changed: Event_OpMode_Change_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _esp_event {
    pub event: uint32,
    pub event_info: Event_Info_u,
}
pub type System_Event_t = _esp_event;
pub type wifi_event_handler_cb_t =
    ::core::option::Option<unsafe extern "C" fn(event: *mut System_Event_t)>;
pub const wps_type_WPS_TYPE_DISABLE: wps_type = 0;
pub const wps_type_WPS_TYPE_PBC: wps_type = 1;
pub const wps_type_WPS_TYPE_PIN: wps_type = 2;
pub const wps_type_WPS_TYPE_DISPLAY: wps_type = 3;
pub const wps_type_WPS_TYPE_MAX: wps_type = 4;
pub type wps_type = ::core::ffi::c_uint;
pub use self::wps_type as WPS_TYPE_t;
pub const wps_cb_status_WPS_CB_ST_SUCCESS: wps_cb_status = 0;
pub const wps_cb_status_WPS_CB_ST_FAILED: wps_cb_status = 1;
pub const wps_cb_status_WPS_CB_ST_TIMEOUT: wps_cb_status = 2;
pub const wps_cb_status_WPS_CB_ST_WEP: wps_cb_status = 3;
pub type wps_cb_status = ::core::ffi::c_uint;
pub type wps_st_cb_t = ::core::option::Option<unsafe extern "C" fn(status: ::core::ffi::c_int)>;
pub type freedom_outside_cb_t = ::core::option::Option<unsafe extern "C" fn(status: uint8)>;
pub type rfid_locp_cb_t = ::core::option::Option<
    unsafe extern "C" fn(frm: *mut uint8, len: ::core::ffi::c_int, rssi: ::core::ffi::c_int),
>;
pub const FIXED_RATE_PHY_RATE_48: FIXED_RATE = 8;
pub const FIXED_RATE_PHY_RATE_24: FIXED_RATE = 9;
pub const FIXED_RATE_PHY_RATE_12: FIXED_RATE = 10;
pub const FIXED_RATE_PHY_RATE_6: FIXED_RATE = 11;
pub const FIXED_RATE_PHY_RATE_54: FIXED_RATE = 12;
pub const FIXED_RATE_PHY_RATE_36: FIXED_RATE = 13;
pub const FIXED_RATE_PHY_RATE_18: FIXED_RATE = 14;
pub const FIXED_RATE_PHY_RATE_9: FIXED_RATE = 15;
pub type FIXED_RATE = ::core::ffi::c_uint;
pub const support_rate_RATE_11B5M: support_rate = 0;
pub const support_rate_RATE_11B11M: support_rate = 1;
pub const support_rate_RATE_11B1M: support_rate = 2;
pub const support_rate_RATE_11B2M: support_rate = 3;
pub const support_rate_RATE_11G6M: support_rate = 4;
pub const support_rate_RATE_11G12M: support_rate = 5;
pub const support_rate_RATE_11G24M: support_rate = 6;
pub const support_rate_RATE_11G48M: support_rate = 7;
pub const support_rate_RATE_11G54M: support_rate = 8;
pub const support_rate_RATE_11G9M: support_rate = 9;
pub const support_rate_RATE_11G18M: support_rate = 10;
pub const support_rate_RATE_11G36M: support_rate = 11;
pub type support_rate = ::core::ffi::c_uint;
pub const RATE_11B_ID_RATE_11B_B11M: RATE_11B_ID = 0;
pub const RATE_11B_ID_RATE_11B_B5M: RATE_11B_ID = 1;
pub const RATE_11B_ID_RATE_11B_B2M: RATE_11B_ID = 2;
pub const RATE_11B_ID_RATE_11B_B1M: RATE_11B_ID = 3;
pub type RATE_11B_ID = ::core::ffi::c_uint;
pub const RATE_11G_ID_RATE_11G_G54M: RATE_11G_ID = 0;
pub const RATE_11G_ID_RATE_11G_G48M: RATE_11G_ID = 1;
pub const RATE_11G_ID_RATE_11G_G36M: RATE_11G_ID = 2;
pub const RATE_11G_ID_RATE_11G_G24M: RATE_11G_ID = 3;
pub const RATE_11G_ID_RATE_11G_G18M: RATE_11G_ID = 4;
pub const RATE_11G_ID_RATE_11G_G12M: RATE_11G_ID = 5;
pub const RATE_11G_ID_RATE_11G_G9M: RATE_11G_ID = 6;
pub const RATE_11G_ID_RATE_11G_G6M: RATE_11G_ID = 7;
pub const RATE_11G_ID_RATE_11G_B5M: RATE_11G_ID = 8;
pub const RATE_11G_ID_RATE_11G_B2M: RATE_11G_ID = 9;
pub const RATE_11G_ID_RATE_11G_B1M: RATE_11G_ID = 10;
pub type RATE_11G_ID = ::core::ffi::c_uint;
pub const RATE_11N_ID_RATE_11N_MCS7S: RATE_11N_ID = 0;
pub const RATE_11N_ID_RATE_11N_MCS7: RATE_11N_ID = 1;
pub const RATE_11N_ID_RATE_11N_MCS6: RATE_11N_ID = 2;
pub const RATE_11N_ID_RATE_11N_MCS5: RATE_11N_ID = 3;
pub const RATE_11N_ID_RATE_11N_MCS4: RATE_11N_ID = 4;
pub const RATE_11N_ID_RATE_11N_MCS3: RATE_11N_ID = 5;
pub const RATE_11N_ID_RATE_11N_MCS2: RATE_11N_ID = 6;
pub const RATE_11N_ID_RATE_11N_MCS1: RATE_11N_ID = 7;
pub const RATE_11N_ID_RATE_11N_MCS0: RATE_11N_ID = 8;
pub const RATE_11N_ID_RATE_11N_B5M: RATE_11N_ID = 9;
pub const RATE_11N_ID_RATE_11N_B2M: RATE_11N_ID = 10;
pub const RATE_11N_ID_RATE_11N_B1M: RATE_11N_ID = 11;
pub type RATE_11N_ID = ::core::ffi::c_uint;
pub const USER_IE_BEACON: _bindgen_ty_6 = 0;
pub const USER_IE_PROBE_REQ: _bindgen_ty_6 = 1;
pub const USER_IE_PROBE_RESP: _bindgen_ty_6 = 2;
pub const USER_IE_ASSOC_REQ: _bindgen_ty_6 = 3;
pub const USER_IE_ASSOC_RESP: _bindgen_ty_6 = 4;
pub const USER_IE_MAX: _bindgen_ty_6 = 5;
pub type _bindgen_ty_6 = ::core::ffi::c_uint;
pub type user_ie_manufacturer_recv_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        type_: uint8,
        sa: *const uint8,
        m_oui: *const uint8,
        ie: *mut uint8,
        ie_len: uint8,
        rssi: ::core::ffi::c_int,
    ),
>;
#[doc = "< Country policy is auto, use the country info of AP to which the station is connected"]
pub const WIFI_COUNTRY_POLICY_WIFI_COUNTRY_POLICY_AUTO: WIFI_COUNTRY_POLICY = 0;
#[doc = "< Country policy is manual, always use the configured country info"]
pub const WIFI_COUNTRY_POLICY_WIFI_COUNTRY_POLICY_MANUAL: WIFI_COUNTRY_POLICY = 1;
pub type WIFI_COUNTRY_POLICY = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_country_t {
    #[doc = "< country code string"]
    pub cc: [::core::ffi::c_char; 3usize],
    #[doc = "< start channel"]
    pub schan: u8,
    #[doc = "< total channel number"]
    pub nchan: u8,
    #[doc = "< country policy"]
    pub policy: u8,
}
pub const partition_type_t_SYSTEM_PARTITION_INVALID: partition_type_t = 0;
pub const partition_type_t_SYSTEM_PARTITION_BOOTLOADER: partition_type_t = 1;
pub const partition_type_t_SYSTEM_PARTITION_OTA_1: partition_type_t = 2;
pub const partition_type_t_SYSTEM_PARTITION_OTA_2: partition_type_t = 3;
pub const partition_type_t_SYSTEM_PARTITION_RF_CAL: partition_type_t = 4;
pub const partition_type_t_SYSTEM_PARTITION_PHY_DATA: partition_type_t = 5;
pub const partition_type_t_SYSTEM_PARTITION_SYSTEM_PARAMETER: partition_type_t = 6;
pub const partition_type_t_SYSTEM_PARTITION_AT_PARAMETER: partition_type_t = 7;
pub const partition_type_t_SYSTEM_PARTITION_SSL_CLIENT_CERT_PRIVKEY: partition_type_t = 8;
pub const partition_type_t_SYSTEM_PARTITION_SSL_CLIENT_CA: partition_type_t = 9;
pub const partition_type_t_SYSTEM_PARTITION_SSL_SERVER_CERT_PRIVKEY: partition_type_t = 10;
pub const partition_type_t_SYSTEM_PARTITION_SSL_SERVER_CA: partition_type_t = 11;
pub const partition_type_t_SYSTEM_PARTITION_WPA2_ENTERPRISE_CERT_PRIVKEY: partition_type_t = 12;
pub const partition_type_t_SYSTEM_PARTITION_WPA2_ENTERPRISE_CA: partition_type_t = 13;
pub const partition_type_t_SYSTEM_PARTITION_CUSTOMER_BEGIN: partition_type_t = 100;
pub const partition_type_t_SYSTEM_PARTITION_MAX: partition_type_t = 101;
pub type partition_type_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct partition_item_t {
    pub type_: partition_type_t,
    pub addr: u32,
    pub size: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
extern "C" {
    pub fn gpio_init();
    pub fn gpio_output_set(
        set_mask: uint32,
        clear_mask: uint32,
        enable_mask: uint32,
        disable_mask: uint32,
    );
    pub fn gpio_input_get() -> uint32;
    pub fn gpio_register_set(reg_id: uint32, value: uint32);
    pub fn gpio_register_get(reg_id: uint32) -> uint32;
    pub fn gpio_intr_handler_register(fn_: gpio_intr_handler_fn_t, arg: *mut ::core::ffi::c_void);
    pub fn gpio_intr_pending() -> uint32;
    pub fn gpio_intr_ack(ack_mask: uint32);
    pub fn gpio_pin_wakeup_enable(i: uint32, intr_state: GPIO_INT_TYPE);
    pub fn gpio_pin_wakeup_disable();
    pub fn gpio_pin_intr_state_set(i: uint32, intr_state: GPIO_INT_TYPE);
    pub fn system_upgrade_init();
    pub fn system_upgrade_deinit();
    pub fn system_upgrade(data: *mut uint8, len: uint16) -> bool_;
    pub fn system_upgrade_start(server: *mut upgrade_server_info) -> bool_;
    pub fn register_simple_pair_status_cb(cb: simple_pair_status_cb_t) -> ::core::ffi::c_int;
    pub fn unregister_simple_pair_status_cb();
    pub fn simple_pair_init() -> ::core::ffi::c_int;
    pub fn simple_pair_deinit();
    pub fn simple_pair_state_reset() -> ::core::ffi::c_int;
    pub fn simple_pair_ap_enter_announce_mode() -> ::core::ffi::c_int;
    pub fn simple_pair_sta_enter_scan_mode() -> ::core::ffi::c_int;
    pub fn simple_pair_sta_start_negotiate() -> ::core::ffi::c_int;
    pub fn simple_pair_ap_start_negotiate() -> ::core::ffi::c_int;
    pub fn simple_pair_ap_refuse_negotiate() -> ::core::ffi::c_int;
    pub fn simple_pair_set_peer_ref(
        peer_mac: *mut u8_,
        tmp_key: *mut u8_,
        ex_key: *mut u8_,
    ) -> ::core::ffi::c_int;
    pub fn simple_pair_get_peer_ref(
        peer_mac: *mut u8_,
        tmp_key: *mut u8_,
        ex_key: *mut u8_,
    ) -> ::core::ffi::c_int;
    pub fn ipaddr_addr(cp: *const ::core::ffi::c_char) -> uint32;
    #[doc = " FunctionName : espconn_connect\n Description  : The function given as the connect\n Parameters   : espconn -- the espconn used to listen the connection\n Returns      : none"]
    pub fn espconn_connect(espconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_disconnect\n Description  : disconnect with host\n Parameters   : espconn -- the espconn used to disconnect the connection\n Returns      : none"]
    pub fn espconn_disconnect(espconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_delete\n Description  : disconnect with host\n Parameters   : espconn -- the espconn used to disconnect the connection\n Returns      : none"]
    pub fn espconn_delete(espconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_accept\n Description  : The function given as the listen\n Parameters   : espconn -- the espconn used to listen the connection\n Returns      : none"]
    pub fn espconn_accept(espconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_create\n Description  : sent data for client or server\n Parameters   : espconn -- espconn to the data transmission\n Returns      : result"]
    pub fn espconn_create(espconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_tcp_get_max_con\n Description  : get the number of simulatenously active TCP connections\n Parameters   : none\n Returns      : none"]
    pub fn espconn_tcp_get_max_con() -> uint8;
    #[doc = " FunctionName : espconn_tcp_set_max_con\n Description  : set the number of simulatenously active TCP connections\n Parameters   : num -- total number\n Returns      : none"]
    pub fn espconn_tcp_set_max_con(num: uint8) -> sint8;
    #[doc = " FunctionName : espconn_tcp_get_max_con_allow\n Description  : get the count of simulatenously active connections on the server\n Parameters   : espconn -- espconn to get the count\n Returns      : result"]
    pub fn espconn_tcp_get_max_con_allow(espconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_tcp_set_max_con_allow\n Description  : set the count of simulatenously active connections on the server\n Parameters   : espconn -- espconn to set the count\n \t\t\t\t  num -- support the connection number\n Returns      : result"]
    pub fn espconn_tcp_set_max_con_allow(espconn: *mut espconn, num: uint8) -> sint8;
    #[doc = " FunctionName : espconn_regist_time\n Description  : used to specify the time that should be called when don't recv data\n Parameters   : espconn -- the espconn used to the connection\n \t\t\t\t  interval -- the timer when don't recv data\n Returns      : none"]
    pub fn espconn_regist_time(espconn: *mut espconn, interval: uint32, type_flag: uint8) -> sint8;
    #[doc = " FunctionName : espconn_get_connection_info\n Description  : used to specify the function that should be called when disconnect\n Parameters   : espconn -- espconn to set the err callback\n                discon_cb -- err callback function to call when err\n Returns      : none"]
    pub fn espconn_get_connection_info(
        pespconn: *mut espconn,
        pcon_info: *mut *mut remot_info,
        typeflags: uint8,
    ) -> sint8;
    #[doc = " FunctionName : espconn_get_packet_info\n Description  : get the packet info with host\n Parameters   : espconn -- the espconn used to disconnect the connection\n \t\t\t\t  infoarg -- the packet info\n Returns      : the errur code"]
    pub fn espconn_get_packet_info(espconn: *mut espconn, infoarg: *mut espconn_packet) -> sint8;
    #[doc = " FunctionName : espconn_regist_sentcb\n Description  : Used to specify the function that should be called when data\n                has been successfully delivered to the remote host.\n Parameters   : struct espconn *espconn -- espconn to set the sent callback\n                espconn_sent_callback sent_cb -- sent callback function to\n                call for this espconn when data is successfully sent\n Returns      : none"]
    pub fn espconn_regist_sentcb(espconn: *mut espconn, sent_cb: espconn_sent_callback) -> sint8;
    #[doc = " FunctionName : espconn_regist_sentcb\n Description  : Used to specify the function that should be called when data\n                has been successfully delivered to the remote host.\n Parameters   : espconn -- espconn to set the sent callback\n                sent_cb -- sent callback function to call for this espconn\n                when data is successfully sent\n Returns      : none"]
    pub fn espconn_regist_write_finish(
        espconn: *mut espconn,
        write_finish_fn: espconn_connect_callback,
    ) -> sint8;
    #[doc = " FunctionName : espconn_send\n Description  : sent data for client or server\n Parameters   : espconn -- espconn to set for client or server\n                psent -- data to send\n                length -- length of data to send\n Returns      : none"]
    pub fn espconn_send(espconn: *mut espconn, psent: *mut uint8, length: uint16) -> sint8;
    #[doc = " FunctionName : espconn_sent\n Description  : sent data for client or server\n Parameters   : espconn -- espconn to set for client or server\n                psent -- data to send\n                length -- length of data to send\n Returns      : none"]
    pub fn espconn_sent(espconn: *mut espconn, psent: *mut uint8, length: uint16) -> sint8;
    #[doc = " FunctionName : espconn_sendto\n Description  : send data for UDP\n Parameters   : espconn -- espconn to set for UDP\n                psent -- data to send\n                length -- length of data to send\n Returns      : error"]
    pub fn espconn_sendto(espconn: *mut espconn, psent: *mut uint8, length: uint16) -> sint16;
    #[doc = " FunctionName : espconn_regist_connectcb\n Description  : used to specify the function that should be called when\n                connects to host.\n Parameters   : espconn -- espconn to set the connect callback\n                connect_cb -- connected callback function to call when connected\n Returns      : none"]
    pub fn espconn_regist_connectcb(
        espconn: *mut espconn,
        connect_cb: espconn_connect_callback,
    ) -> sint8;
    #[doc = " FunctionName : espconn_regist_recvcb\n Description  : used to specify the function that should be called when recv\n                data from host.\n Parameters   : espconn -- espconn to set the recv callback\n                recv_cb -- recv callback function to call when recv data\n Returns      : none"]
    pub fn espconn_regist_recvcb(espconn: *mut espconn, recv_cb: espconn_recv_callback) -> sint8;
    #[doc = " FunctionName : espconn_regist_reconcb\n Description  : used to specify the function that should be called when connection\n                because of err disconnect.\n Parameters   : espconn -- espconn to set the err callback\n                recon_cb -- err callback function to call when err\n Returns      : none"]
    pub fn espconn_regist_reconcb(
        espconn: *mut espconn,
        recon_cb: espconn_reconnect_callback,
    ) -> sint8;
    #[doc = " FunctionName : espconn_regist_disconcb\n Description  : used to specify the function that should be called when disconnect\n Parameters   : espconn -- espconn to set the err callback\n                discon_cb -- err callback function to call when err\n Returns      : none"]
    pub fn espconn_regist_disconcb(
        espconn: *mut espconn,
        discon_cb: espconn_connect_callback,
    ) -> sint8;
    #[doc = " FunctionName : espconn_port\n Description  : access port value for client so that we don't end up bouncing\n                all connections at the same time .\n Parameters   : none\n Returns      : access port value"]
    pub fn espconn_port() -> uint32;
    #[doc = " FunctionName : espconn_set_opt\n Description  : access port value for client so that we don't end up bouncing\n                all connections at the same time .\n Parameters   : none\n Returns      : access port value"]
    pub fn espconn_set_opt(espconn: *mut espconn, opt: uint8) -> sint8;
    #[doc = " FunctionName : espconn_clear_opt\n Description  : clear the option for connections so that we don't end up bouncing\n                all connections at the same time .\n Parameters   : espconn -- the espconn used to set the connection\n \t\t\t\t  opt -- the option for clear\n Returns      : the result"]
    pub fn espconn_clear_opt(espconn: *mut espconn, opt: uint8) -> sint8;
    #[doc = " FunctionName : espconn_set_keepalive\n Description  : access level value for connection so that we set the value for\n \t\t\t\t  keep alive\n Parameters   : espconn -- the espconn used to set the connection\n \t\t\t\t  level -- the connection's level\n \t\t\t\t  value -- the value of time(s)\n Returns      : access port value"]
    pub fn espconn_set_keepalive(
        espconn: *mut espconn,
        level: uint8,
        optarg: *mut ::core::ffi::c_void,
    ) -> sint8;
    #[doc = " FunctionName : espconn_get_keepalive\n Description  : access level value for connection so that we get the value for\n \t\t\t\t  keep alive\n Parameters   : espconn -- the espconn used to get the connection\n \t\t\t\t  level -- the connection's level\n Returns      : access keep alive value"]
    pub fn espconn_get_keepalive(
        espconn: *mut espconn,
        level: uint8,
        optarg: *mut ::core::ffi::c_void,
    ) -> sint8;
    #[doc = " FunctionName : espconn_gethostbyname\n Description  : Resolve a hostname (string) into an IP address.\n Parameters   : pespconn -- espconn to resolve a hostname\n                hostname -- the hostname that is to be queried\n                addr -- pointer to a ip_addr_t where to store the address if\n                it is already cached in the dns_table (only valid if ESPCONN_OK\n                is returned!)\n                found -- a callback function to be called on success, failure\n                or timeout (only if ERR_INPROGRESS is returned!)\n Returns      : err_t return code\n                - ESPCONN_OK if hostname is a valid IP address string or the host\n                  name is already in the local names table.\n                - ESPCONN_INPROGRESS enqueue a request to be sent to the DNS server\n                  for resolution if no errors are present.\n                - ESPCONN_ARG: dns client not initialized or invalid hostname"]
    pub fn espconn_gethostbyname(
        pespconn: *mut espconn,
        hostname: *const ::core::ffi::c_char,
        addr: *mut ip_addr_t,
        found: dns_found_callback,
    ) -> err_t;
    #[doc = " FunctionName : espconn_abort\n Description  : Forcely abort with host\n Parameters   : espconn -- the espconn used to connect with the host\n Returns      : result"]
    pub fn espconn_abort(espconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_encry_connect\n Description  : The function given as connection\n Parameters   : espconn -- the espconn used to connect with the host\n Returns      : none"]
    pub fn espconn_secure_connect(espconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_encry_disconnect\n Description  : The function given as the disconnection\n Parameters   : espconn -- the espconn used to disconnect with the host\n Returns      : none"]
    pub fn espconn_secure_disconnect(espconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_secure_send\n Description  : sent data for client or server\n Parameters   : espconn -- espconn to set for client or server\n \t\t\t\t  psent -- data to send\n                length -- length of data to send\n Returns      : none"]
    pub fn espconn_secure_send(espconn: *mut espconn, psent: *mut uint8, length: uint16) -> sint8;
    #[doc = " FunctionName : espconn_encry_sent\n Description  : sent data for client or server\n Parameters   : espconn -- espconn to set for client or server\n \t\t\t\t  psent -- data to send\n                length -- length of data to send\n Returns      : none"]
    pub fn espconn_secure_sent(espconn: *mut espconn, psent: *mut uint8, length: uint16) -> sint8;
    #[doc = " FunctionName : espconn_secure_set_size\n Description  : set the buffer size for client or server\n Parameters   : level -- set for client or server\n \t\t\t\t  1: client,2:server,3:client and server\n \t\t\t\t  size -- buffer size\n Returns      : true or false"]
    pub fn espconn_secure_set_size(level: uint8, size: uint16) -> bool_;
    #[doc = " FunctionName : espconn_secure_get_size\n Description  : get buffer size for client or server\n Parameters   : level -- set for client or server\n\t\t\t\t  1: client,2:server,3:client and server\n Returns      : buffer size for client or server"]
    pub fn espconn_secure_get_size(level: uint8) -> sint16;
    #[doc = " FunctionName : espconn_secure_ca_enable\n Description  : enable the certificate authenticate and set the flash sector\n \t\t\t\t  as client or server\n Parameters   : level -- set for client or server\n\t\t\t\t  1: client,2:server,3:client and server\n\t\t\t\t  flash_sector -- flash sector for save certificate\n Returns      : result true or false"]
    pub fn espconn_secure_ca_enable(level: uint8, flash_sector: uint32) -> bool_;
    #[doc = " FunctionName : espconn_secure_ca_disable\n Description  : disable the certificate authenticate  as client or server\n Parameters   : level -- set for client or server\n\t\t\t\t  1: client,2:server,3:client and server\n Returns      : result true or false"]
    pub fn espconn_secure_ca_disable(level: uint8) -> bool_;
    #[doc = " FunctionName : espconn_secure_cert_req_enable\n Description  : enable the client certificate authenticate and set the flash sector\n \t\t\t\t  as client or server\n Parameters   : level -- set for client or server\n\t\t\t\t  1: client,2:server,3:client and server\n\t\t\t\t  flash_sector -- flash sector for save certificate\n Returns      : result true or false"]
    pub fn espconn_secure_cert_req_enable(level: uint8, flash_sector: uint32) -> bool_;
    #[doc = " FunctionName : espconn_secure_ca_disable\n Description  : disable the client certificate authenticate  as client or server\n Parameters   : level -- set for client or server\n\t\t\t\t  1: client,2:server,3:client and server\n Returns      : result true or false"]
    pub fn espconn_secure_cert_req_disable(level: uint8) -> bool_;
    #[doc = " FunctionName : espconn_secure_set_default_certificate\n Description  : Load the certificates in memory depending on compile-time\n \t\t\t\t  and user options.\n Parameters   : certificate -- Load the certificate\n\t\t\t\t  length -- Load the certificate length\n Returns      : result true or false"]
    pub fn espconn_secure_set_default_certificate(
        certificate: *const uint8,
        length: uint16,
    ) -> bool_;
    #[doc = " FunctionName : espconn_secure_set_default_private_key\n Description  : Load the key in memory depending on compile-time\n \t\t\t\t  and user options.\n Parameters   : private_key -- Load the key\n\t\t\t\t  length -- Load the key length\n Returns      : result true or false"]
    pub fn espconn_secure_set_default_private_key(
        private_key: *const uint8,
        length: uint16,
    ) -> bool_;
    #[doc = " FunctionName : espconn_secure_accept\n Description  : The function given as the listen\n Parameters   : espconn -- the espconn used to listen the connection\n Returns      : result"]
    pub fn espconn_secure_accept(espconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_secure_accepts\n Description  : delete the secure server host\n Parameters   : espconn -- the espconn used to listen the connection\n Returns      : result"]
    pub fn espconn_secure_delete(espconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_igmp_join\n Description  : join a multicast group\n Parameters   : host_ip -- the ip address of udp server\n \t\t\t\t  multicast_ip -- multicast ip given by user\n Returns      : none"]
    pub fn espconn_igmp_join(host_ip: *mut ip_addr_t, multicast_ip: *mut ip_addr_t) -> sint8;
    #[doc = " FunctionName : espconn_igmp_leave\n Description  : leave a multicast group\n Parameters   : host_ip -- the ip address of udp server\n \t\t\t\t  multicast_ip -- multicast ip given by user\n Returns      : none"]
    pub fn espconn_igmp_leave(host_ip: *mut ip_addr_t, multicast_ip: *mut ip_addr_t) -> sint8;
    #[doc = " FunctionName : espconn_recv_hold\n Description  : hold tcp receive\n Parameters   : espconn -- espconn to hold\n Returns      : none"]
    pub fn espconn_recv_hold(pespconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_recv_unhold\n Description  : unhold tcp receive\n Parameters   : espconn -- espconn to unhold\n Returns      : none"]
    pub fn espconn_recv_unhold(pespconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_recved_len\n Description  : get TCP readable data bytes\n Parameters   : espconn -- espconn to unhold\n Returns      : result"]
    pub fn espconn_recved_len(espconn: *mut espconn) -> sint16;
    #[doc = " FunctionName : espconn_mdns_init\n Description  : register a device with mdns\n Parameters   : ipAddr -- the ip address of device\n \t\t\t\t  hostname -- the hostname of device\n Returns      : none"]
    pub fn espconn_mdns_init(info: *mut mdns_info);
    #[doc = " FunctionName : espconn_mdns_close\n Description  : close a device with mdns\n Parameters   : a\n Returns      : none"]
    pub fn espconn_mdns_close();
    #[doc = " FunctionName : espconn_mdns_server_register\n Description  : register a device with mdns\n Parameters   : a\n Returns      : none"]
    pub fn espconn_mdns_server_register();
    #[doc = " FunctionName : espconn_mdns_server_unregister\n Description  : unregister a device with mdns\n Parameters   : a\n Returns      : none"]
    pub fn espconn_mdns_server_unregister();
    #[doc = " FunctionName : espconn_mdns_get_servername\n Description  : get server name of device with mdns\n Parameters   : a\n Returns      : none"]
    pub fn espconn_mdns_get_servername() -> *mut ::core::ffi::c_char;
    #[doc = " FunctionName : espconn_mdns_set_servername\n Description  : set server name of device with mdns\n Parameters   : a\n Returns      : none"]
    pub fn espconn_mdns_set_servername(name: *const ::core::ffi::c_char);
    #[doc = " FunctionName : espconn_mdns_set_hostname\n Description  : set host name of device with mdns\n Parameters   : a\n Returns      : none"]
    pub fn espconn_mdns_set_hostname(name: *mut ::core::ffi::c_char);
    #[doc = " FunctionName : espconn_mdns_get_hostname\n Description  : get host name of device with mdns\n Parameters   : a\n Returns      : none"]
    pub fn espconn_mdns_get_hostname() -> *mut ::core::ffi::c_char;
    #[doc = " FunctionName : espconn_mdns_disable\n Description  : disable a device with mdns\n Parameters   : a\n Returns      : none"]
    pub fn espconn_mdns_disable();
    #[doc = " FunctionName : espconn_mdns_enable\n Description  : disable a device with mdns\n Parameters   : a\n Returns      : none"]
    pub fn espconn_mdns_enable();
    #[doc = " FunctionName : espconn_dns_setserver\n Description  : Initialize one of the DNS servers.\n Parameters   : numdns -- the index of the DNS server to set must\n \t\t\t\t  be < DNS_MAX_SERVERS = 2\n \t\t\t      dnsserver -- IP address of the DNS server to set\n  Returns     : none"]
    pub fn espconn_dns_setserver(numdns: uint8, dnsserver: *mut ip_addr_t);
    #[doc = " FunctionName : espconn_dns_getserver\n Description  : get dns server.\n Parameters   : numdns -- the index of the DNS server, must\n                be < DNS_MAX_SERVERS = 2\n  Returns     : dnsserver -- IP address of the DNS server to set"]
    pub fn espconn_dns_getserver(numdns: uint8) -> ip_addr_t;
    pub fn wifi_station_set_wpa2_enterprise_auth(enable: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn wifi_station_set_enterprise_cert_key(
        client_cert: *mut u8_,
        client_cert_len: ::core::ffi::c_int,
        private_key: *mut u8_,
        private_key_len: ::core::ffi::c_int,
        private_key_passwd: *mut u8_,
        private_key_passwd_len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn wifi_station_clear_enterprise_cert_key();
    pub fn wifi_station_set_enterprise_ca_cert(
        ca_cert: *mut u8_,
        ca_cert_len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn wifi_station_clear_enterprise_ca_cert();
    pub fn wifi_station_set_enterprise_identity(
        identity: *mut u8_,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn wifi_station_clear_enterprise_identity();
    pub fn wifi_station_set_enterprise_username(
        username: *mut u8_,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn wifi_station_clear_enterprise_username();
    pub fn wifi_station_set_enterprise_password(
        password: *mut u8_,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn wifi_station_clear_enterprise_password();
    pub fn wifi_station_set_enterprise_new_password(
        new_password: *mut u8_,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn wifi_station_clear_enterprise_new_password();
    pub fn wifi_station_set_enterprise_disable_time_check(disable: bool_);
    pub fn wifi_station_get_enterprise_disable_time_check() -> bool_;
    pub fn wpa2_enterprise_set_user_get_time(cb: get_time_func_t);
    #[doc = " @brief     Get airkiss lib version.\n\n @attention The lenth of version is unknown\n\n @param     null.\n\n @return    const char*"]
    pub fn airkiss_version() -> *const ::core::ffi::c_char;
    #[doc = " @brief     Receive UDP packet and input this API for analyzing.\n\n @attention null.\n\n @param     const void* body : The start of the UDP message body data pointer.\n @param     unsigned short length : the effective length of data.\n @param     const airkiss_config_t* config : input struct airkiss_config_t\n\n @return    >=0 : succeed (reference airkiss_lan_ret_t)\n @return    <0  : error code (reference airkiss_lan_ret_t)"]
    pub fn airkiss_lan_recv(
        body: *const ::core::ffi::c_void,
        length: ::core::ffi::c_ushort,
        config: *const airkiss_config_t,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief     Packaging the UDP packet to send.\n\n @attention null.\n\n @param     airkiss_lan_cmdid_t ak_lan_cmdid : The packet type.\n @param     void* appid : Vendor's Wechat public number id.\n @param     void* deviceid : device model id.\n @param     void* _datain : the data to be sent.\n @param     unsigned short inlength : the lenth of data to be sent.\n @param     void* _dataout : Data buffer addr.\n @param     unsigned short* outlength : the size of data buffer.\n @param     const airkiss_config_t* config : input struct airkiss_config_t\n\n @return    >=0 : succeed (reference airkiss_lan_ret_t)\n @return    <0  : error code (reference airkiss_lan_ret_t)"]
    pub fn airkiss_lan_pack(
        ak_lan_cmdid: airkiss_lan_cmdid_t,
        appid: *mut ::core::ffi::c_void,
        deviceid: *mut ::core::ffi::c_void,
        _datain: *mut ::core::ffi::c_void,
        inlength: ::core::ffi::c_ushort,
        _dataout: *mut ::core::ffi::c_void,
        outlength: *mut ::core::ffi::c_ushort,
        config: *const airkiss_config_t,
    ) -> ::core::ffi::c_int;
    pub fn smartconfig_get_version() -> *const ::core::ffi::c_char;
    pub fn smartconfig_start(cb: sc_callback_t, ...) -> bool_;
    pub fn smartconfig_stop() -> bool_;
    pub fn esptouch_set_timeout(time_s: uint8) -> bool_;
    pub fn smartconfig_set_type(type_: sc_type) -> bool_;
    pub fn ets_intr_lock();
    pub fn ets_intr_unlock();
    pub fn ets_isr_attach(i: ::core::ffi::c_int, func: ets_isr_t, arg: *mut ::core::ffi::c_void);
    pub fn ets_isr_mask(mask: uint32);
    pub fn ets_isr_unmask(unmask: uint32);
    pub fn NmiTimSetFunc(func: ::core::option::Option<unsafe extern "C" fn()>);
    #[doc = " get the seconds since Jan 01, 1970, 00:00 (GMT + 8)"]
    pub fn sntp_get_current_timestamp() -> uint32;
    #[doc = " get real time (GTM + 8 time zone)"]
    pub fn sntp_get_real_time(t: ::core::ffi::c_long) -> *mut ::core::ffi::c_char;
    #[doc = " SNTP get time_zone default GMT + 8"]
    pub fn sntp_get_timezone() -> sint8;
    #[doc = " SNTP set time_zone (default GMT + 8)"]
    pub fn sntp_set_timezone(timezone: sint8) -> bool_;
    #[doc = " Initialize this module.\n Send out request instantly or after SNTP_STARTUP_DELAY(_FUNC)."]
    pub fn sntp_init();
    #[doc = " Stop this module."]
    pub fn sntp_stop();
    #[doc = " Initialize one of the NTP servers by IP address\n\n @param numdns the index of the NTP server to set must be < SNTP_MAX_SERVERS\n @param dnsserver IP address of the NTP server to set"]
    pub fn sntp_setserver(idx: ::core::ffi::c_uchar, addr: *mut ip_addr_t);
    #[doc = " Obtain one of the currently configured by IP address (or DHCP) NTP servers\n\n @param numdns the index of the NTP server\n @return IP address of the indexed NTP server or \"ip_addr_any\" if the NTP\n         server has not been configured by address (or at all)."]
    pub fn sntp_getserver(idx: ::core::ffi::c_uchar) -> ip_addr_t;
    #[doc = " Initialize one of the NTP servers by name\n\n @param numdns the index of the NTP server to set must be < SNTP_MAX_SERVERS,now sdk support SNTP_MAX_SERVERS = 3\n @param dnsserver DNS name of the NTP server to set, to be resolved at contact time"]
    pub fn sntp_setservername(idx: ::core::ffi::c_uchar, server: *mut ::core::ffi::c_char);
    #[doc = " Obtain one of the currently configured by name NTP servers.\n\n @param numdns the index of the NTP server\n @return IP address of the indexed NTP server or NULL if the NTP\n         server has not been configured by name (or at all)"]
    pub fn sntp_getservername(idx: ::core::ffi::c_uchar) -> *mut ::core::ffi::c_char;
    pub fn esp_now_init() -> ::core::ffi::c_int;
    pub fn esp_now_deinit() -> ::core::ffi::c_int;
    pub fn esp_now_register_send_cb(cb: esp_now_send_cb_t) -> ::core::ffi::c_int;
    pub fn esp_now_unregister_send_cb() -> ::core::ffi::c_int;
    pub fn esp_now_register_recv_cb(cb: esp_now_recv_cb_t) -> ::core::ffi::c_int;
    pub fn esp_now_unregister_recv_cb() -> ::core::ffi::c_int;
    pub fn esp_now_send(
        da: *mut u8_,
        data: *mut u8_,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn esp_now_add_peer(
        mac_addr: *mut u8_,
        role: u8_,
        channel: u8_,
        key: *mut u8_,
        key_len: u8_,
    ) -> ::core::ffi::c_int;
    pub fn esp_now_del_peer(mac_addr: *mut u8_) -> ::core::ffi::c_int;
    pub fn esp_now_set_self_role(role: u8_) -> ::core::ffi::c_int;
    pub fn esp_now_get_self_role() -> ::core::ffi::c_int;
    pub fn esp_now_set_peer_role(mac_addr: *mut u8_, role: u8_) -> ::core::ffi::c_int;
    pub fn esp_now_get_peer_role(mac_addr: *mut u8_) -> ::core::ffi::c_int;
    pub fn esp_now_set_peer_channel(mac_addr: *mut u8_, channel: u8_) -> ::core::ffi::c_int;
    pub fn esp_now_get_peer_channel(mac_addr: *mut u8_) -> ::core::ffi::c_int;
    pub fn esp_now_set_peer_key(
        mac_addr: *mut u8_,
        key: *mut u8_,
        key_len: u8_,
    ) -> ::core::ffi::c_int;
    pub fn esp_now_get_peer_key(
        mac_addr: *mut u8_,
        key: *mut u8_,
        key_len: *mut u8_,
    ) -> ::core::ffi::c_int;
    pub fn esp_now_fetch_peer(restart: bool_) -> *mut u8_;
    pub fn esp_now_is_peer_exist(mac_addr: *mut u8_) -> ::core::ffi::c_int;
    pub fn esp_now_get_cnt_info(all_cnt: *mut u8_, encrypt_cnt: *mut u8_) -> ::core::ffi::c_int;
    pub fn esp_now_set_kok(key: *mut u8_, len: u8_) -> ::core::ffi::c_int;
    pub fn pwm_init(
        period: uint32,
        duty: *mut uint32,
        pwm_channel_num: uint32,
        pin_info_list: *mut [uint32; 3usize],
    );
    pub fn pwm_start();
    pub fn pwm_set_duty(duty: uint32, channel: uint8);
    pub fn pwm_get_duty(channel: uint8) -> uint32;
    pub fn pwm_set_period(period: uint32);
    pub fn pwm_get_period() -> uint32;
    pub fn get_pwm_version() -> uint32;
    pub fn set_pwm_debug_en(print_en: uint8);
    pub static mut default_certificate: [::core::ffi::c_uchar; 843usize];
    pub fn spi_flash_get_id() -> uint32;
    pub fn spi_flash_erase_sector(sec: uint16) -> SpiFlashOpResult;
    pub fn spi_flash_write(
        des_addr: uint32,
        src_addr: *mut uint32,
        size: uint32,
    ) -> SpiFlashOpResult;
    pub fn spi_flash_read(
        src_addr: uint32,
        des_addr: *mut uint32,
        size: uint32,
    ) -> SpiFlashOpResult;
    pub fn spi_flash_set_read_func(read: user_spi_flash_read);
    pub fn spi_flash_erase_protect_enable() -> bool_;
    pub fn spi_flash_erase_protect_disable() -> bool_;
    pub static patch_data: [uint8; 4416usize];
    pub fn ping_start(ping_opt: *mut ping_option) -> bool_;
    pub fn ping_regist_recv(ping_opt: *mut ping_option, ping_recv: ping_recv_function) -> bool_;
    pub fn ping_regist_sent(ping_opt: *mut ping_option, ping_sent: ping_sent_function) -> bool_;
    pub static mut at_customLinkMax: uint8;
    #[doc = " @brief  Response \"OK\" to uart.\n @param  None\n @retval None"]
    pub fn at_response_ok();
    #[doc = " @brief  Response \"ERROR\" to uart.\n @param  None\n @retval None"]
    pub fn at_response_error();
    #[doc = " @brief  Response string.\n  It is equivalent to at_port_print,if not call at_register_response_func or call at_register_response_func(NULL);\n  It will run custom response function,if call at_register_response_func and parameter is not NULL.\n @param  string\n @retval None"]
    pub fn at_response(str_: *const ::core::ffi::c_char);
    #[doc = " @brief  register custom response function.\n @param  response_func: the function that will run when call at_response\n @retval None"]
    pub fn at_register_response_func(response_func: at_custom_response_func_type);
    #[doc = " @brief  Task of process command or txdata.\n @param  custom_at_cmd_array: the array of at cmd that custom defined\n         cmd_num : the num of at cmd that custom defined\n @retval None"]
    pub fn at_cmd_array_regist(custom_at_cmd_array: *mut at_funcationType, cmd_num: uint32);
    #[doc = " @brief  get digit form at cmd line.the maybe alter pSrc\n @param  p_src: at cmd line string\n         result:the buffer to be placed result\n         err : err num\n @retval TRUE:\n         FALSE:"]
    pub fn at_get_next_int_dec(
        p_src: *mut *mut ::core::ffi::c_char,
        result: *mut ::core::ffi::c_int,
        err: *mut ::core::ffi::c_int,
    ) -> bool_;
    #[doc = " @brief  get string form at cmd line.the maybe alter pSrc\n @param  p_dest: the buffer to be placed result\n         p_src: at cmd line string\n         max_len :max len of string excepted to get\n @retval None"]
    pub fn at_data_str_copy(
        p_dest: *mut ::core::ffi::c_char,
        p_src: *mut *mut ::core::ffi::c_char,
        max_len: int32,
    ) -> int32;
    #[doc = " @brief  initialize at module\n @param  None\n @retval None"]
    pub fn at_init();
    #[doc = " @brief  print string to at port\n @param  string\n @retval None"]
    pub fn at_port_print(str_: *const ::core::ffi::c_char);
    #[doc = " @brief  print custom information when AT+GMR\n @param  string\n @retval None"]
    pub fn at_set_custom_info(info: *mut ::core::ffi::c_char);
    #[doc = " @brief  if current at command is processing,you can call at_enter_special_state,\n         then if other comamnd coming,it will return busy.\n @param  None\n @retval None"]
    pub fn at_enter_special_state();
    #[doc = " @brief\n @param  None\n @retval None"]
    pub fn at_leave_special_state();
    #[doc = " @brief  get at version\n @param  None\n @retval at version\n         bit24~31: at main version\n         bit23~16: at sub version\n         bit15~8 : at test version\n         bit7~0  : customized version"]
    pub fn at_get_version() -> uint32;
    #[doc = " @brief  register custom uart rx interrupt function\n @param  rx_func: custom uart rx interrupt function.\n If rx_func is non-void,when rx interrupt comming,it will call rx_func(data,len),\n data is the buffer of data,len is the length of data.Otherwise,it will run AT rx function.\n @retval None"]
    pub fn at_register_uart_rx_intr(rx_func: at_custom_uart_rx_intr);
    #[doc = " @brief notify at module that has receive data\n @param  data: data buffer.\n @param  length: data length\n @retval data len,if ok len == length"]
    pub fn at_fake_uart_rx(data: *mut uint8, length: uint32) -> uint32;
    #[doc = " @brief enable fake uart,and register fake uart tx\n @param  enable: enable fake uart.\n @param  at_fake_uart_tx_func:\n @retval data len,if ok len == length"]
    pub fn at_fake_uart_enable(
        enable: bool_,
        at_fake_uart_tx_func: at_fake_uart_tx_func_type,
    ) -> bool_;
    #[doc = " @brief set at escape character\n @param  ch: escape character.\n @retval TRUE,if set ok,otherwize FALSE."]
    pub fn at_set_escape_character(ch: uint8) -> bool_;
    #[doc = " @brief Enable wpa2 enterprise command\n @      include AT+CWJEAP_DEF, AT+CWJEAP_CUR\n @param  None\n @retval TRUE,if set ok,otherwize FALSE."]
    pub fn at_cmd_enable_wpa2_enterprise() -> bool_;
    #[doc = " @brief Enable smartconfig command\n @      include AT+CWSTARTSMART, AT+CWSTOPSMART, AT+CWSTARTDISCOVER, AT+CWSTOPDISCOVER\n @param  None\n @retval TRUE,if set ok,otherwize FALSE."]
    pub fn at_cmd_enable_smartconfig() -> bool_;
    pub fn memcpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn memmove(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn memccpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn memset(
        __s: *mut ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn memcmp(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
    pub fn __memcmpeq(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: usize,
    ) -> ::core::ffi::c_int;
    pub fn memchr(
        __s: *const ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn strcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
    pub fn strcat(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strncat(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
    pub fn strcmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn strncmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
    pub fn strcoll(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn strxfrm(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
    pub fn strcoll_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __l: locale_t,
    ) -> ::core::ffi::c_int;
    pub fn strxfrm_l(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
    pub fn strdup(__s: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn strndup(
        __string: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
    pub fn strchr(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn strrchr(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn strchrnul(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn strcspn(
        __s: *const ::core::ffi::c_char,
        __reject: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_ulong;
    pub fn strspn(
        __s: *const ::core::ffi::c_char,
        __accept: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_ulong;
    pub fn strpbrk(
        __s: *const ::core::ffi::c_char,
        __accept: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strstr(
        __haystack: *const ::core::ffi::c_char,
        __needle: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strtok(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn __strtok_r(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
        __save_ptr: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strtok_r(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
        __save_ptr: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strcasestr(
        __haystack: *const ::core::ffi::c_char,
        __needle: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn memmem(
        __haystack: *const ::core::ffi::c_void,
        __haystacklen: usize,
        __needle: *const ::core::ffi::c_void,
        __needlelen: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn __mempcpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn mempcpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn strlen(__s: *const ::core::ffi::c_char) -> ::core::ffi::c_ulong;
    pub fn strnlen(__string: *const ::core::ffi::c_char, __maxlen: usize) -> usize;
    pub fn strerror(__errnum: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_char,
        __buflen: usize,
    ) -> ::core::ffi::c_int;
    pub fn strerror_l(__errnum: ::core::ffi::c_int, __l: locale_t) -> *mut ::core::ffi::c_char;
    pub fn bcmp(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
    pub fn bcopy(
        __src: *const ::core::ffi::c_void,
        __dest: *mut ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    );
    pub fn bzero(__s: *mut ::core::ffi::c_void, __n: ::core::ffi::c_ulong);
    pub fn index(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn rindex(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn ffs(__i: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn ffsl(__l: ::core::ffi::c_long) -> ::core::ffi::c_int;
    pub fn ffsll(__ll: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
    pub fn strcasecmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn strncasecmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
    pub fn strcasecmp_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __loc: locale_t,
    ) -> ::core::ffi::c_int;
    pub fn strncasecmp_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::core::ffi::c_int;
    pub fn explicit_bzero(__s: *mut ::core::ffi::c_void, __n: usize);
    pub fn strsep(
        __stringp: *mut *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strsignal(__sig: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
    pub fn __stpcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn stpcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn __stpncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: usize,
    ) -> *mut ::core::ffi::c_char;
    pub fn stpncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
    pub fn strlcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
    pub fn strlcat(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
    pub fn ets_bzero(s: *mut ::core::ffi::c_void, n: usize);
    pub fn ets_delay_us(us: u32);
    pub fn ets_install_putc1(
        p: ::core::option::Option<unsafe extern "C" fn(c: ::core::ffi::c_char)>,
    );
    pub fn ets_memcmp(
        str1: *const ::core::ffi::c_void,
        str2: *const ::core::ffi::c_void,
        nbyte: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
    pub fn ets_memcpy(
        dest: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        nbyte: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub fn ets_memmove(
        dest: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        nbyte: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub fn ets_memset(
        dest: *mut ::core::ffi::c_void,
        val: ::core::ffi::c_int,
        nbyte: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub fn ets_strcmp(
        s1: *const ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn ets_strcpy(
        s1: *mut ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn ets_strlen(s: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn ets_strncmp(
        s1: *const ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
        n: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
    pub fn ets_strncpy(
        s1: *mut ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
        n: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_char;
    pub fn ets_strstr(
        s1: *const ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn ets_timer_arm_new(ptimer: *mut ETSTimer, time: u32, repeat_flag: bool_, ms_flag: bool_);
    pub fn ets_timer_disarm(ptimer: *mut ETSTimer);
    pub fn ets_timer_setfn(
        ptimer: *mut ETSTimer,
        pfunction: ETSTimerFunc,
        parg: *mut ::core::ffi::c_void,
    );
    pub fn ets_sprintf(
        str_: *mut ::core::ffi::c_char,
        format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn os_printf_plus(format: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn ets_snprintf(
        str_: *mut ::core::ffi::c_char,
        size: ::core::ffi::c_uint,
        format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn os_random() -> ::core::ffi::c_ulong;
    pub fn os_get_random(buf: *mut ::core::ffi::c_uchar, len: usize) -> ::core::ffi::c_int;
    pub static mut default_private_key: [::core::ffi::c_uchar; 916usize];
    pub fn pvPortMalloc(
        sz: usize,
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
        arg3: bool_,
    ) -> *mut ::core::ffi::c_void;
    pub fn vPortFree(
        p: *mut ::core::ffi::c_void,
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
    );
    pub fn pvPortZalloc(
        sz: usize,
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub fn pvPortRealloc(
        p: *mut ::core::ffi::c_void,
        n: usize,
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub fn pvPortCalloc(
        count: usize,
        size: usize,
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub fn pvPortCallocIram(
        count: usize,
        size: usize,
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub fn pvPortZallocIram(
        sz: usize,
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub fn system_get_rst_info() -> *mut rst_info;
    pub fn system_restore();
    pub fn system_restart();
    pub fn system_deep_sleep_set_option(option: uint8) -> bool_;
    pub fn system_deep_sleep(time_in_us: uint64) -> bool_;
    pub fn system_deep_sleep_instant(time_in_us: uint64) -> bool_;
    pub fn system_upgrade_userbin_check() -> uint8;
    pub fn system_upgrade_reboot();
    pub fn system_upgrade_flag_check() -> uint8;
    pub fn system_upgrade_flag_set(flag: uint8);
    pub fn system_timer_reinit();
    pub fn system_get_time() -> uint32;
    pub fn system_os_task(task: ETSTask, prio: uint8, queue: *mut ETSEvent, qlen: uint8) -> bool_;
    pub fn system_os_post(prio: uint8, sig: ETSSignal, par: ETSParam) -> bool_;
    pub fn system_print_meminfo();
    pub fn system_get_free_heap_size() -> uint32;
    pub fn system_set_os_print(onoff: uint8);
    pub fn system_get_os_print() -> uint8;
    pub fn system_mktime(
        year: uint32,
        mon: uint32,
        day: uint32,
        hour: uint32,
        min: uint32,
        sec: uint32,
    ) -> uint64;
    pub fn system_get_chip_id() -> uint32;
    pub fn system_init_done_cb(cb: init_done_cb_t);
    pub fn system_rtc_clock_cali_proc() -> uint32;
    pub fn system_get_rtc_time() -> uint32;
    pub fn system_rtc_mem_read(
        src_addr: uint8,
        des_addr: *mut ::core::ffi::c_void,
        load_size: uint16,
    ) -> bool_;
    pub fn system_rtc_mem_write(
        des_addr: uint8,
        src_addr: *const ::core::ffi::c_void,
        save_size: uint16,
    ) -> bool_;
    pub fn system_uart_swap();
    pub fn system_uart_de_swap();
    pub fn system_adc_read() -> uint16;
    pub fn system_adc_read_fast(adc_addr: *mut uint16, adc_num: uint16, adc_clk_div: uint8);
    pub fn system_get_vdd33() -> uint16;
    pub fn system_get_sdk_version() -> *const ::core::ffi::c_char;
    pub fn system_get_boot_version() -> uint8;
    pub fn system_get_userbin_addr() -> uint32;
    pub fn system_get_boot_mode() -> uint8;
    pub fn system_restart_enhance(bin_type: uint8, bin_addr: uint32) -> bool_;
    pub fn system_update_cpu_freq(freq: uint8) -> bool_;
    pub fn system_get_cpu_freq() -> uint8;
    pub fn system_get_flash_size_map() -> flash_size_map;
    pub fn system_phy_set_max_tpw(max_tpw: uint8);
    pub fn system_phy_set_tpw_via_vdd33(vdd33: uint16);
    pub fn system_phy_set_rfoption(option: uint8);
    pub fn system_phy_set_powerup_option(option: uint8);
    pub fn system_param_save_with_protect(
        start_sec: uint16,
        param: *mut ::core::ffi::c_void,
        len: uint16,
    ) -> bool_;
    pub fn system_param_load(
        start_sec: uint16,
        offset: uint16,
        param: *mut ::core::ffi::c_void,
        len: uint16,
    ) -> bool_;
    pub fn system_soft_wdt_stop();
    pub fn system_soft_wdt_restart();
    pub fn system_soft_wdt_feed();
    pub fn system_show_malloc();
    pub fn wifi_get_opmode() -> uint8;
    pub fn wifi_get_opmode_default() -> uint8;
    pub fn wifi_set_opmode(opmode: uint8) -> bool_;
    pub fn wifi_set_opmode_current(opmode: uint8) -> bool_;
    pub fn wifi_get_broadcast_if() -> uint8;
    pub fn wifi_set_broadcast_if(interface: uint8) -> bool_;
    pub fn wifi_station_get_config(config: *mut station_config) -> bool_;
    pub fn wifi_station_get_config_default(config: *mut station_config) -> bool_;
    pub fn wifi_station_set_config(config: *mut station_config) -> bool_;
    pub fn wifi_station_set_config_current(config: *mut station_config) -> bool_;
    pub fn wifi_station_connect() -> bool_;
    pub fn wifi_station_disconnect() -> bool_;
    pub fn wifi_enable_signaling_measurement();
    pub fn wifi_disable_signaling_measurement();
    pub fn wifi_station_get_rssi() -> sint8;
    pub fn wifi_station_scan(config: *mut scan_config, cb: scan_done_cb_t) -> bool_;
    pub fn wifi_station_get_auto_connect() -> uint8;
    pub fn wifi_station_set_auto_connect(set: uint8) -> bool_;
    pub fn wifi_station_set_reconnect_policy(set: bool_) -> bool_;
    pub fn wifi_station_get_connect_status() -> uint8;
    pub fn wifi_station_get_current_ap_id() -> uint8;
    pub fn wifi_station_ap_change(current_ap_id: uint8) -> bool_;
    pub fn wifi_station_ap_number_set(ap_number: uint8) -> bool_;
    pub fn wifi_station_get_ap_info(config: *mut station_config) -> uint8;
    pub fn wifi_station_dhcpc_start() -> bool_;
    pub fn wifi_station_dhcpc_stop() -> bool_;
    pub fn wifi_station_dhcpc_status() -> dhcp_status;
    pub fn wifi_station_dhcpc_set_maxtry(num: uint8) -> bool_;
    pub fn wifi_station_get_hostname() -> *mut ::core::ffi::c_char;
    pub fn wifi_station_set_hostname(name: *mut ::core::ffi::c_char) -> bool_;
    pub fn wifi_station_set_cert_key(
        client_cert: *mut uint8,
        client_cert_len: ::core::ffi::c_int,
        private_key: *mut uint8,
        private_key_len: ::core::ffi::c_int,
        private_key_passwd: *mut uint8,
        private_key_passwd_len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn wifi_station_clear_cert_key();
    pub fn wifi_station_set_username(
        username: *mut uint8,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn wifi_station_clear_username();
    pub fn wifi_softap_get_config(config: *mut softap_config) -> bool_;
    pub fn wifi_softap_get_config_default(config: *mut softap_config) -> bool_;
    pub fn wifi_softap_set_config(config: *mut softap_config) -> bool_;
    pub fn wifi_softap_set_config_current(config: *mut softap_config) -> bool_;
    pub fn wifi_softap_get_station_num() -> uint8;
    pub fn wifi_softap_get_station_info() -> *mut station_info;
    pub fn wifi_softap_free_station_info();
    pub fn wifi_softap_dhcps_start() -> bool_;
    pub fn wifi_softap_dhcps_stop() -> bool_;
    pub fn wifi_softap_set_dhcps_lease(please: *mut dhcps_lease) -> bool_;
    pub fn wifi_softap_get_dhcps_lease(please: *mut dhcps_lease) -> bool_;
    pub fn wifi_softap_get_dhcps_lease_time() -> uint32;
    pub fn wifi_softap_set_dhcps_lease_time(minute: uint32) -> bool_;
    pub fn wifi_softap_reset_dhcps_lease_time() -> bool_;
    pub fn wifi_softap_dhcps_status() -> dhcp_status;
    pub fn wifi_softap_set_dhcps_offer_option(
        level: uint8,
        optarg: *mut ::core::ffi::c_void,
    ) -> bool_;
    pub fn wifi_get_ip_info(if_index: uint8, info: *mut ip_info) -> bool_;
    pub fn wifi_set_ip_info(if_index: uint8, info: *mut ip_info) -> bool_;
    pub fn wifi_get_macaddr(if_index: uint8, macaddr: *mut uint8) -> bool_;
    pub fn wifi_set_macaddr(if_index: uint8, macaddr: *mut uint8) -> bool_;
    pub fn wifi_get_channel() -> uint8;
    pub fn wifi_set_channel(channel: uint8) -> bool_;
    pub fn wifi_status_led_install(gpio_id: uint8, gpio_name: uint32, gpio_func: uint8);
    pub fn wifi_status_led_uninstall();
    pub fn wifi_promiscuous_enable(promiscuous: uint8);
    pub fn wifi_set_promiscuous_rx_cb(cb: wifi_promiscuous_cb_t);
    pub fn wifi_promiscuous_set_mac(address: *const u8);
    pub fn wifi_get_phy_mode() -> phy_mode;
    pub fn wifi_set_phy_mode(mode: phy_mode) -> bool_;
    pub fn wifi_set_sleep_type(type_: sleep_type) -> bool_;
    pub fn wifi_get_sleep_type() -> sleep_type;
    pub fn wifi_set_sleep_level(level: sleep_level) -> bool_;
    pub fn wifi_get_sleep_level() -> sleep_level;
    pub fn wifi_set_listen_interval(interval: uint8) -> bool_;
    pub fn wifi_get_listen_interval() -> uint8;
    pub fn wifi_fpm_open();
    pub fn wifi_fpm_close();
    pub fn wifi_fpm_do_wakeup();
    pub fn wifi_fpm_do_sleep(sleep_time_in_us: uint32) -> sint8;
    pub fn wifi_fpm_set_sleep_type(type_: sleep_type);
    pub fn wifi_fpm_get_sleep_type() -> sleep_type;
    pub fn wifi_fpm_set_wakeup_cb(cb: fpm_wakeup_cb);
    pub fn wifi_fpm_auto_sleep_set_in_null_mode(req: uint8);
    pub fn wifi_set_event_handler_cb(cb: wifi_event_handler_cb_t);
    pub fn wifi_wps_enable(wps_type: WPS_TYPE_t) -> bool_;
    pub fn wifi_wps_disable() -> bool_;
    pub fn wifi_wps_start() -> bool_;
    pub fn wifi_set_wps_cb(cb: wps_st_cb_t) -> bool_;
    pub fn wifi_register_send_pkt_freedom_cb(cb: freedom_outside_cb_t) -> ::core::ffi::c_int;
    pub fn wifi_unregister_send_pkt_freedom_cb();
    pub fn wifi_send_pkt_freedom(
        buf: *mut uint8,
        len: ::core::ffi::c_int,
        sys_seq: bool_,
    ) -> ::core::ffi::c_int;
    pub fn wifi_rfid_locp_recv_open() -> ::core::ffi::c_int;
    pub fn wifi_rfid_locp_recv_close();
    pub fn wifi_register_rfid_locp_recv_cb(cb: rfid_locp_cb_t) -> ::core::ffi::c_int;
    pub fn wifi_unregister_rfid_locp_recv_cb();
    pub fn wifi_set_user_fixed_rate(enable_mask: uint8, rate: uint8) -> ::core::ffi::c_int;
    pub fn wifi_get_user_fixed_rate(
        enable_mask: *mut uint8,
        rate: *mut uint8,
    ) -> ::core::ffi::c_int;
    pub fn wifi_set_user_sup_rate(min: uint8, max: uint8) -> ::core::ffi::c_int;
    pub fn wifi_set_user_rate_limit(mode: uint8, ifidx: uint8, max: uint8, min: uint8) -> bool_;
    pub fn wifi_get_user_limit_rate_mask() -> uint8;
    pub fn wifi_set_user_limit_rate_mask(enable_mask: uint8) -> bool_;
    pub fn wifi_set_user_ie(
        enable: bool_,
        m_oui: *mut uint8,
        type_: uint8,
        user_ie: *mut uint8,
        len: uint8,
    ) -> bool_;
    pub fn wifi_register_user_ie_manufacturer_recv_cb(
        cb: user_ie_manufacturer_recv_cb_t,
    ) -> ::core::ffi::c_int;
    pub fn wifi_unregister_user_ie_manufacturer_recv_cb();
    pub fn wifi_enable_gpio_wakeup(i: uint32, intr_status: GPIO_INT_TYPE);
    pub fn wifi_disable_gpio_wakeup();
    pub fn uart_div_modify(uart_no: uint8, DivLatchValue: uint32);
    #[doc = " @brief     configure country info\n\n @attention 1. The default country is {.cc=\"CN\", .schan=1, .nchan=13, policy=WIFI_COUNTRY_POLICY_AUTO}\n @attention 2. When the country policy is WIFI_COUNTRY_POLICY_AUTO, use the country info of AP to which the station is\n               connected. E.g. if the configured country info is {.cc=\"USA\", .schan=1, .nchan=11}, the country info of\n               the AP to which the station is connected is {.cc=\"JP\", .schan=1, .nchan=14}, then our country info is\n               {.cc=\"JP\", .schan=1, .nchan=14}. If the station disconnected from the AP, the country info back to\n               {.cc=\"USA\", .schan=1, .nchan=11} again.\n @attention 3. When the country policy is WIFI_COUNTRY_POLICY_MANUAL, always use the configured country info.\n @attention 4. When the country info is changed because of configuration or because the station connects to a different\n               external AP, the country IE in probe response/beacon of the soft-AP is changed also.\n @attention 5. The country configuration is not stored into flash\n\n @param     wifi_country_t *country: the configured country info\n\n @return  true : succeed\n @return false : fail"]
    pub fn wifi_set_country(country: *mut wifi_country_t) -> bool_;
    #[doc = " @brief     get the current country info\n\n @param     wifi_country_t *country: country info\n\n @return  true : succeed\n @return false : fail"]
    pub fn wifi_get_country(country: *mut wifi_country_t) -> bool_;
    #[doc = " @brief     regist partition table information, user MUST call it in user_pre_init()\n\n @param     partition_table: the partition table\n @param     partition_num:   the partition number in partition table\n @param     map:             the flash map\n\n @return  true : succeed\n @return false : fail"]
    pub fn system_partition_table_regist(
        partition_table: *const partition_item_t,
        partition_num: u32,
        map: u32,
    ) -> bool_;
    #[doc = " @brief     get ota partition size\n\n @return    the size of ota partition"]
    pub fn system_partition_get_ota_partition_size() -> u32;
    #[doc = " @brief     get partition information\n\n @param     type:             the partition type\n @param     partition_item:   the point to store partition information\n\n @return  true : succeed\n @return false : fail"]
    pub fn system_partition_get_item(
        type_: partition_type_t,
        partition_item: *mut partition_item_t,
    ) -> bool_;
}
