/* automatically generated by rust-bindgen 0.71.1 */

pub const ESP_SYSTEM_APP: u32 = 1;
pub const SYS_LIGHTWEIGHT_PROT: u32 = 0;
pub const NO_SYS: u32 = 1;
pub const NO_SYS_NO_TIMERS: u32 = 0;
pub const MEM_LIBC_MALLOC: u32 = 1;
pub const MEMP_MEM_MALLOC: u32 = 1;
pub const MEM_ALIGNMENT: u32 = 4;
pub const MEM_SIZE: u32 = 16000;
pub const MEMP_SEPARATE_POOLS: u32 = 1;
pub const MEMP_OVERFLOW_CHECK: u32 = 0;
pub const MEMP_SANITY_CHECK: u32 = 1;
pub const MEM_USE_POOLS: u32 = 0;
pub const MEM_USE_POOLS_TRY_BIGGER_POOL: u32 = 0;
pub const MEMP_USE_CUSTOM_POOLS: u32 = 0;
pub const LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT: u32 = 0;
pub const MEMP_NUM_PBUF: u32 = 10;
pub const MEMP_NUM_RAW_PCB: u32 = 4;
pub const MEMP_NUM_UDP_PCB: u32 = 4;
pub const MEMP_NUM_TCP_PCB_LISTEN: u32 = 2;
pub const MEMP_NUM_TCP_SEG: u32 = 16;
pub const MEMP_NUM_REASSDATA: u32 = 0;
pub const MEMP_NUM_FRAG_PBUF: u32 = 0;
pub const MEMP_NUM_ARP_QUEUE: u32 = 10;
pub const MEMP_NUM_IGMP_GROUP: u32 = 8;
pub const MEMP_NUM_SYS_TIMEOUT: u32 = 8;
pub const MEMP_NUM_NETBUF: u32 = 0;
pub const MEMP_NUM_NETCONN: u32 = 0;
pub const MEMP_NUM_TCPIP_MSG_API: u32 = 4;
pub const MEMP_NUM_TCPIP_MSG_INPKT: u32 = 4;
pub const MEMP_NUM_SNMP_NODE: u32 = 0;
pub const MEMP_NUM_SNMP_ROOTNODE: u32 = 0;
pub const MEMP_NUM_SNMP_VARBIND: u32 = 0;
pub const MEMP_NUM_SNMP_VALUE: u32 = 0;
pub const MEMP_NUM_NETDB: u32 = 0;
pub const MEMP_NUM_LOCALHOSTLIST: u32 = 0;
pub const MEMP_NUM_PPPOE_INTERFACES: u32 = 0;
pub const PBUF_POOL_SIZE: u32 = 10;
pub const LWIP_ARP: u32 = 1;
pub const ARP_TABLE_SIZE: u32 = 10;
pub const ARP_QUEUEING: u32 = 1;
pub const ETHARP_TRUST_IP_MAC: u32 = 0;
pub const ETHARP_SUPPORT_VLAN: u32 = 0;
pub const ETH_PAD_SIZE: u32 = 0;
pub const ETHARP_SUPPORT_STATIC_ENTRIES: u32 = 0;
pub const IP_FORWARD: u32 = 0;
pub const IP_OPTIONS_ALLOWED: u32 = 1;
pub const IP_REASSEMBLY: u32 = 0;
pub const IP_FRAG: u32 = 0;
pub const IP_REASS_MAXAGE: u32 = 3;
pub const IP_REASS_MAX_PBUFS: u32 = 10;
pub const IP_FRAG_USES_STATIC_BUF: u32 = 1;
pub const IP_FRAG_MAX_MTU: u32 = 1500;
pub const IP_DEFAULT_TTL: u32 = 128;
pub const IP_SOF_BROADCAST: u32 = 0;
pub const IP_SOF_BROADCAST_RECV: u32 = 0;
pub const LWIP_ICMP: u32 = 1;
pub const ICMP_TTL: u32 = 128;
pub const LWIP_BROADCAST_PING: u32 = 0;
pub const LWIP_MULTICAST_PING: u32 = 0;
pub const LWIP_RAW: u32 = 1;
pub const RAW_TTL: u32 = 128;
pub const LWIP_DHCP: u32 = 1;
pub const LWIP_AUTOIP: u32 = 0;
pub const LWIP_DHCP_AUTOIP_COOP: u32 = 0;
pub const LWIP_DHCP_AUTOIP_COOP_TRIES: u32 = 9;
pub const LWIP_SNMP: u32 = 0;
pub const SNMP_CONCURRENT_REQUESTS: u32 = 0;
pub const SNMP_TRAP_DESTINATIONS: u32 = 0;
pub const SNMP_PRIVATE_MIB: u32 = 0;
pub const SNMP_SAFE_REQUESTS: u32 = 0;
pub const SNMP_MAX_OCTET_STRING_LEN: u32 = 127;
pub const SNMP_MAX_TREE_DEPTH: u32 = 15;
pub const LWIP_IGMP: u32 = 1;
pub const LWIP_MDNS: u32 = 1;
pub const LWIP_DNS: u32 = 1;
pub const DNS_TABLE_SIZE: u32 = 4;
pub const DNS_MAX_NAME_LENGTH: u32 = 256;
pub const DNS_MAX_SERVERS: u32 = 2;
pub const DNS_DOES_NAME_CHECK: u32 = 1;
pub const DNS_MSG_SIZE: u32 = 512;
pub const DNS_LOCAL_HOSTLIST: u32 = 0;
pub const DNS_LOCAL_HOSTLIST_IS_DYNAMIC: u32 = 0;
pub const LWIP_UDP: u32 = 1;
pub const LWIP_UDPLITE: u32 = 0;
pub const UDP_TTL: u32 = 128;
pub const LWIP_NETBUF_RECVINFO: u32 = 0;
pub const LWIP_TCP: u32 = 1;
pub const TCP_TTL: u32 = 128;
pub const TCP_MAXRTO: u32 = 10;
pub const TCP_MINRTO: u32 = 2;
pub const TCP_QUEUE_OOSEQ: u32 = 1;
pub const TCP_MSS: u32 = 1460;
pub const TCP_CALCULATE_EFF_SEND_MSS: u32 = 1;
pub const TCP_SND_BUF: u32 = 2920;
pub const TCP_SND_QUEUELEN: u32 = 8;
pub const TCP_SNDLOWAT: u32 = 1460;
pub const TCP_LISTEN_BACKLOG: u32 = 0;
pub const TCP_DEFAULT_LISTEN_BACKLOG: u32 = 255;
pub const TCP_OVERSIZE: u32 = 1460;
pub const LWIP_TCP_TIMESTAMPS: u32 = 0;
pub const LWIP_EVENT_API: u32 = 0;
pub const LWIP_CALLBACK_API: u32 = 1;
pub const PBUF_LINK_HLEN: u32 = 14;
pub const LWIP_NETIF_HOSTNAME: u32 = 1;
pub const LWIP_NETIF_API: u32 = 0;
pub const LWIP_NETIF_STATUS_CALLBACK: u32 = 0;
pub const LWIP_NETIF_LINK_CALLBACK: u32 = 0;
pub const LWIP_NETIF_HWADDRHINT: u32 = 0;
pub const LWIP_NETIF_LOOPBACK: u32 = 0;
pub const LWIP_LOOPBACK_MAX_PBUFS: u32 = 0;
pub const LWIP_NETIF_TX_SINGLE_PBUF: u32 = 1;
pub const LWIP_HAVE_LOOPIF: u32 = 0;
pub const LWIP_HAVE_SLIPIF: u32 = 0;
pub const TCPIP_THREAD_NAME: &[u8; 13] = b"tcpip_thread\0";
pub const TCPIP_THREAD_STACKSIZE: u32 = 0;
pub const TCPIP_THREAD_PRIO: u32 = 1;
pub const TCPIP_MBOX_SIZE: u32 = 0;
pub const SLIPIF_THREAD_NAME: &[u8; 12] = b"slipif_loop\0";
pub const SLIPIF_THREAD_STACKSIZE: u32 = 0;
pub const SLIPIF_THREAD_PRIO: u32 = 1;
pub const PPP_THREAD_NAME: &[u8; 15] = b"pppInputThread\0";
pub const PPP_THREAD_STACKSIZE: u32 = 0;
pub const PPP_THREAD_PRIO: u32 = 1;
pub const DEFAULT_THREAD_NAME: &[u8; 5] = b"lwIP\0";
pub const DEFAULT_THREAD_STACKSIZE: u32 = 0;
pub const DEFAULT_THREAD_PRIO: u32 = 1;
pub const DEFAULT_RAW_RECVMBOX_SIZE: u32 = 0;
pub const DEFAULT_UDP_RECVMBOX_SIZE: u32 = 0;
pub const DEFAULT_TCP_RECVMBOX_SIZE: u32 = 0;
pub const DEFAULT_ACCEPTMBOX_SIZE: u32 = 0;
pub const LWIP_TCPIP_CORE_LOCKING: u32 = 0;
pub const LWIP_TCPIP_CORE_LOCKING_INPUT: u32 = 0;
pub const LWIP_NETCONN: u32 = 0;
pub const LWIP_TCPIP_TIMEOUT: u32 = 1;
pub const LWIP_SOCKET: u32 = 0;
pub const LWIP_COMPAT_SOCKETS: u32 = 0;
pub const LWIP_POSIX_SOCKETS_IO_NAMES: u32 = 0;
pub const LWIP_TCP_KEEPALIVE: u32 = 1;
pub const LWIP_SO_RCVTIMEO: u32 = 0;
pub const LWIP_SO_RCVBUF: u32 = 0;
pub const SO_REUSE: u32 = 0;
pub const SO_REUSE_RXTOALL: u32 = 0;
pub const LWIP_STATS: u32 = 0;
pub const ETHARP_STATS: u32 = 0;
pub const LINK_STATS: u32 = 0;
pub const IP_STATS: u32 = 0;
pub const IPFRAG_STATS: u32 = 0;
pub const ICMP_STATS: u32 = 0;
pub const IGMP_STATS: u32 = 0;
pub const UDP_STATS: u32 = 0;
pub const TCP_STATS: u32 = 0;
pub const MEM_STATS: u32 = 0;
pub const MEMP_STATS: u32 = 0;
pub const SYS_STATS: u32 = 0;
pub const LWIP_STATS_DISPLAY: u32 = 0;
pub const PPP_SUPPORT: u32 = 0;
pub const PPPOE_SUPPORT: u32 = 0;
pub const PPPOS_SUPPORT: u32 = 0;
pub const CHECKSUM_GEN_IP: u32 = 1;
pub const CHECKSUM_GEN_UDP: u32 = 1;
pub const CHECKSUM_GEN_TCP: u32 = 1;
pub const CHECKSUM_CHECK_IP: u32 = 1;
pub const CHECKSUM_CHECK_UDP: u32 = 1;
pub const CHECKSUM_CHECK_TCP: u32 = 1;
pub const LWIP_CHECKSUM_ON_COPY: u32 = 0;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const BIT31: u32 = 2147483648;
pub const BIT30: u32 = 1073741824;
pub const BIT29: u32 = 536870912;
pub const BIT28: u32 = 268435456;
pub const BIT27: u32 = 134217728;
pub const BIT26: u32 = 67108864;
pub const BIT25: u32 = 33554432;
pub const BIT24: u32 = 16777216;
pub const BIT23: u32 = 8388608;
pub const BIT22: u32 = 4194304;
pub const BIT21: u32 = 2097152;
pub const BIT20: u32 = 1048576;
pub const BIT19: u32 = 524288;
pub const BIT18: u32 = 262144;
pub const BIT17: u32 = 131072;
pub const BIT16: u32 = 65536;
pub const BIT15: u32 = 32768;
pub const BIT14: u32 = 16384;
pub const BIT13: u32 = 8192;
pub const BIT12: u32 = 4096;
pub const BIT11: u32 = 2048;
pub const BIT10: u32 = 1024;
pub const BIT9: u32 = 512;
pub const BIT8: u32 = 256;
pub const BIT7: u32 = 128;
pub const BIT6: u32 = 64;
pub const BIT5: u32 = 32;
pub const BIT4: u32 = 16;
pub const BIT3: u32 = 8;
pub const BIT2: u32 = 4;
pub const BIT1: u32 = 2;
pub const BIT0: u32 = 1;
pub const APB_CLK_FREQ: u32 = 80000000;
pub const UART_CLK_FREQ: u32 = 80000000;
pub const TIMER_CLK_FREQ: u32 = 312500;
pub const PERIPHS_DPORT_BASEADDR: u32 = 1072693248;
pub const PERIPHS_GPIO_BASEADDR: u32 = 1610613504;
pub const PERIPHS_TIMER_BASEDDR: u32 = 1610614272;
pub const PERIPHS_RTC_BASEADDR: u32 = 1610614528;
pub const PERIPHS_IO_MUX: u32 = 1610614784;
pub const EDGE_INT_ENABLE_REG: u32 = 1072693252;
pub const GPIO_OUT_ADDRESS: u32 = 0;
pub const GPIO_OUT_W1TS_ADDRESS: u32 = 4;
pub const GPIO_OUT_W1TC_ADDRESS: u32 = 8;
pub const GPIO_ENABLE_ADDRESS: u32 = 12;
pub const GPIO_ENABLE_W1TS_ADDRESS: u32 = 16;
pub const GPIO_ENABLE_W1TC_ADDRESS: u32 = 20;
pub const GPIO_OUT_W1TC_DATA_MASK: u32 = 65535;
pub const GPIO_IN_ADDRESS: u32 = 24;
pub const GPIO_STATUS_ADDRESS: u32 = 28;
pub const GPIO_STATUS_W1TS_ADDRESS: u32 = 32;
pub const GPIO_STATUS_W1TC_ADDRESS: u32 = 36;
pub const GPIO_STATUS_INTERRUPT_MASK: u32 = 65535;
pub const GPIO_RTC_CALIB_SYNC: u32 = 1610613612;
pub const RTC_CALIB_START: u32 = 2147483648;
pub const RTC_PERIOD_NUM_MASK: u32 = 1023;
pub const GPIO_RTC_CALIB_VALUE: u32 = 1610613616;
pub const RTC_CALIB_RDY_S: u32 = 31;
pub const RTC_CALIB_VALUE_MASK: u32 = 1048575;
pub const GPIO_PIN0_ADDRESS: u32 = 40;
pub const GPIO_ID_PIN0: u32 = 0;
pub const GPIO_ID_NONE: u32 = 4294967295;
pub const GPIO_PIN_COUNT: u32 = 16;
pub const GPIO_PIN_CONFIG_MSB: u32 = 12;
pub const GPIO_PIN_CONFIG_LSB: u32 = 11;
pub const GPIO_PIN_CONFIG_MASK: u32 = 6144;
pub const GPIO_WAKEUP_ENABLE: u32 = 1;
pub const GPIO_WAKEUP_DISABLE: i32 = -2;
pub const GPIO_PIN_WAKEUP_ENABLE_MSB: u32 = 10;
pub const GPIO_PIN_WAKEUP_ENABLE_LSB: u32 = 10;
pub const GPIO_PIN_WAKEUP_ENABLE_MASK: u32 = 1024;
pub const GPIO_PIN_INT_TYPE_MASK: u32 = 896;
pub const GPIO_PIN_INT_TYPE_MSB: u32 = 9;
pub const GPIO_PIN_INT_TYPE_LSB: u32 = 7;
pub const GPIO_PAD_DRIVER_ENABLE: u32 = 1;
pub const GPIO_PAD_DRIVER_DISABLE: i32 = -2;
pub const GPIO_PIN_PAD_DRIVER_MSB: u32 = 2;
pub const GPIO_PIN_PAD_DRIVER_LSB: u32 = 2;
pub const GPIO_PIN_PAD_DRIVER_MASK: u32 = 4;
pub const GPIO_AS_PIN_SOURCE: u32 = 0;
pub const SIGMA_AS_PIN_SOURCE: i32 = -1;
pub const GPIO_PIN_SOURCE_MSB: u32 = 0;
pub const GPIO_PIN_SOURCE_LSB: u32 = 0;
pub const GPIO_PIN_SOURCE_MASK: u32 = 1;
pub const FRC1_LOAD_ADDRESS: u32 = 0;
pub const FRC1_COUNT_ADDRESS: u32 = 4;
pub const FRC1_CTRL_ADDRESS: u32 = 8;
pub const FRC1_INT_ADDRESS: u32 = 12;
pub const FRC1_INT_CLR_MASK: u32 = 1;
pub const FRC2_COUNT_ADDRESS: u32 = 36;
pub const REG_RTC_BASE: u32 = 1610614528;
pub const RTC_STORE0: u32 = 1610614576;
pub const RTC_STORE1: u32 = 1610614580;
pub const RTC_STORE2: u32 = 1610614584;
pub const RTC_STORE3: u32 = 1610614588;
pub const RTC_GPIO_OUT: u32 = 1610614632;
pub const RTC_GPIO_ENABLE: u32 = 1610614644;
pub const RTC_GPIO_IN_DATA: u32 = 1610614668;
pub const RTC_GPIO_CONF: u32 = 1610614672;
pub const PAD_XPD_DCDC_CONF: u32 = 1610614688;
pub const PERIPHS_IO_MUX_FUNC: u32 = 19;
pub const PERIPHS_IO_MUX_FUNC_S: u32 = 4;
pub const PERIPHS_IO_MUX_PULLUP: u32 = 128;
pub const PERIPHS_IO_MUX_PULLUP2: u32 = 64;
pub const PERIPHS_IO_MUX_SLEEP_PULLUP: u32 = 8;
pub const PERIPHS_IO_MUX_SLEEP_PULLUP2: u32 = 4;
pub const PERIPHS_IO_MUX_SLEEP_OE: u32 = 2;
pub const PERIPHS_IO_MUX_OE: u32 = 1;
pub const PERIPHS_IO_MUX_CONF_U: u32 = 1610614784;
pub const SPI0_CLK_EQU_SYS_CLK: u32 = 256;
pub const SPI1_CLK_EQU_SYS_CLK: u32 = 512;
pub const PERIPHS_IO_MUX_MTDI_U: u32 = 1610614788;
pub const FUNC_GPIO12: u32 = 3;
pub const PERIPHS_IO_MUX_MTCK_U: u32 = 1610614792;
pub const FUNC_GPIO13: u32 = 3;
pub const PERIPHS_IO_MUX_MTMS_U: u32 = 1610614796;
pub const FUNC_GPIO14: u32 = 3;
pub const PERIPHS_IO_MUX_MTDO_U: u32 = 1610614800;
pub const FUNC_GPIO15: u32 = 3;
pub const FUNC_U0RTS: u32 = 4;
pub const PERIPHS_IO_MUX_U0RXD_U: u32 = 1610614804;
pub const FUNC_GPIO3: u32 = 3;
pub const PERIPHS_IO_MUX_U0TXD_U: u32 = 1610614808;
pub const FUNC_U0TXD: u32 = 0;
pub const FUNC_GPIO1: u32 = 3;
pub const PERIPHS_IO_MUX_SD_CLK_U: u32 = 1610614812;
pub const FUNC_SDCLK: u32 = 0;
pub const FUNC_SPICLK: u32 = 1;
pub const PERIPHS_IO_MUX_SD_DATA0_U: u32 = 1610614816;
pub const FUNC_SDDATA0: u32 = 0;
pub const FUNC_SPIQ: u32 = 1;
pub const FUNC_U1TXD: u32 = 4;
pub const PERIPHS_IO_MUX_SD_DATA1_U: u32 = 1610614820;
pub const FUNC_SDDATA1: u32 = 0;
pub const FUNC_SPID: u32 = 1;
pub const FUNC_U1RXD: u32 = 4;
pub const FUNC_SDDATA1_U1RXD: u32 = 7;
pub const PERIPHS_IO_MUX_SD_DATA2_U: u32 = 1610614824;
pub const FUNC_SDDATA2: u32 = 0;
pub const FUNC_SPIHD: u32 = 1;
pub const FUNC_GPIO9: u32 = 3;
pub const PERIPHS_IO_MUX_SD_DATA3_U: u32 = 1610614828;
pub const FUNC_SDDATA3: u32 = 0;
pub const FUNC_SPIWP: u32 = 1;
pub const FUNC_GPIO10: u32 = 3;
pub const PERIPHS_IO_MUX_SD_CMD_U: u32 = 1610614832;
pub const FUNC_SDCMD: u32 = 0;
pub const FUNC_SPICS0: u32 = 1;
pub const PERIPHS_IO_MUX_GPIO0_U: u32 = 1610614836;
pub const FUNC_GPIO0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO2_U: u32 = 1610614840;
pub const FUNC_GPIO2: u32 = 0;
pub const FUNC_U1TXD_BK: u32 = 2;
pub const FUNC_U0TXD_BK: u32 = 4;
pub const PERIPHS_IO_MUX_GPIO4_U: u32 = 1610614844;
pub const FUNC_GPIO4: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO5_U: u32 = 1610614848;
pub const FUNC_GPIO5: u32 = 0;
pub const ETS_SDIO_INUM: u32 = 1;
pub const ETS_SPI_INUM: u32 = 2;
pub const ETS_GPIO_INUM: u32 = 4;
pub const ETS_UART_INUM: u32 = 5;
pub const ETS_UART1_INUM: u32 = 5;
pub const ETS_FRC_TIMER1_INUM: u32 = 9;
pub const _STRING_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC23: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_TIME_BITS64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C23_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 40;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const EFAULT: u32 = 14;
pub const BYTE_ORDER: u32 = 1234;
pub const S16_F: &[u8; 2] = b"d\0";
pub const U16_F: &[u8; 2] = b"d\0";
pub const X16_F: &[u8; 2] = b"x\0";
pub const S32_F: &[u8; 2] = b"d\0";
pub const U32_F: &[u8; 2] = b"d\0";
pub const X32_F: &[u8; 2] = b"x\0";
pub const LWIP_PLATFORM_BYTESWAP: u32 = 1;
pub const SZT_F: &[u8; 2] = b"d\0";
pub const X8_F: &[u8; 4] = b"02x\0";
pub const LWIP_DBG_LEVEL_ALL: u32 = 0;
pub const LWIP_DBG_LEVEL_OFF: u32 = 0;
pub const LWIP_DBG_LEVEL_WARNING: u32 = 1;
pub const LWIP_DBG_LEVEL_SERIOUS: u32 = 2;
pub const LWIP_DBG_LEVEL_SEVERE: u32 = 3;
pub const LWIP_DBG_MASK_LEVEL: u32 = 3;
pub const LWIP_DBG_ON: u32 = 128;
pub const LWIP_DBG_OFF: u32 = 0;
pub const LWIP_DBG_TRACE: u32 = 64;
pub const LWIP_DBG_STATE: u32 = 32;
pub const LWIP_DBG_FRESH: u32 = 16;
pub const LWIP_DBG_HALT: u32 = 8;
pub const ERR_OK: u32 = 0;
pub const ERR_MEM: i32 = -1;
pub const ERR_BUF: i32 = -2;
pub const ERR_TIMEOUT: i32 = -3;
pub const ERR_RTE: i32 = -4;
pub const ERR_INPROGRESS: i32 = -5;
pub const ERR_VAL: i32 = -6;
pub const ERR_WOULDBLOCK: i32 = -7;
pub const ERR_ABRT: i32 = -8;
pub const ERR_RST: i32 = -9;
pub const ERR_CLSD: i32 = -10;
pub const ERR_CONN: i32 = -11;
pub const ERR_ARG: i32 = -12;
pub const ERR_USE: i32 = -13;
pub const ERR_IF: i32 = -14;
pub const ERR_ISCONN: i32 = -15;
pub const PBUF_TRANSPORT_HLEN: u32 = 20;
pub const PBUF_IP_HLEN: u32 = 20;
pub const PBUF_FLAG_PUSH: u32 = 1;
pub const PBUF_FLAG_IS_CUSTOM: u32 = 2;
pub const PBUF_FLAG_MCASTLOOP: u32 = 4;
pub const IP_CLASSA_NET: u32 = 4278190080;
pub const IP_CLASSA_NSHIFT: u32 = 24;
pub const IP_CLASSA_HOST: u32 = 16777215;
pub const IP_CLASSA_MAX: u32 = 128;
pub const IP_CLASSB_NET: u32 = 4294901760;
pub const IP_CLASSB_NSHIFT: u32 = 16;
pub const IP_CLASSB_HOST: u32 = 65535;
pub const IP_CLASSB_MAX: u32 = 65536;
pub const IP_CLASSC_NET: u32 = 4294967040;
pub const IP_CLASSC_NSHIFT: u32 = 8;
pub const IP_CLASSC_HOST: u32 = 255;
pub const IP_CLASSD_NET: u32 = 4026531840;
pub const IP_CLASSD_NSHIFT: u32 = 28;
pub const IP_CLASSD_HOST: u32 = 268435455;
pub const IP_LOOPBACKNET: u32 = 127;
pub const IPSTR: &[u8; 12] = b"%d.%d.%d.%d\0";
pub const NETIF_MAX_HWADDR_LEN: u32 = 6;
pub const NETIF_FLAG_UP: u32 = 1;
pub const NETIF_FLAG_BROADCAST: u32 = 2;
pub const NETIF_FLAG_POINTTOPOINT: u32 = 4;
pub const NETIF_FLAG_DHCP: u32 = 8;
pub const NETIF_FLAG_LINK_UP: u32 = 16;
pub const NETIF_FLAG_ETHARP: u32 = 32;
pub const NETIF_FLAG_ETHERNET: u32 = 64;
pub const NETIF_FLAG_IGMP: u32 = 128;
pub const IP_OPTIONS_SEND: u32 = 1;
pub const IP_HLEN: u32 = 20;
pub const IP_PROTO_ICMP: u32 = 1;
pub const IP_PROTO_IGMP: u32 = 2;
pub const IP_PROTO_UDP: u32 = 17;
pub const IP_PROTO_UDPLITE: u32 = 136;
pub const IP_PROTO_TCP: u32 = 6;
pub const IP_RF: u32 = 32768;
pub const IP_DF: u32 = 16384;
pub const IP_MF: u32 = 8192;
pub const IP_OFFMASK: u32 = 8191;
pub const ICMP_ER: u32 = 0;
pub const ICMP_DUR: u32 = 3;
pub const ICMP_SQ: u32 = 4;
pub const ICMP_RD: u32 = 5;
pub const ICMP_ECHO: u32 = 8;
pub const ICMP_TE: u32 = 11;
pub const ICMP_PP: u32 = 12;
pub const ICMP_TS: u32 = 13;
pub const ICMP_TSR: u32 = 14;
pub const ICMP_IRQ: u32 = 15;
pub const ICMP_IR: u32 = 16;
pub const TCP_SNDQUEUELEN_OVERFLOW: u32 = 65532;
pub const TCP_WRITE_FLAG_COPY: u32 = 1;
pub const TCP_WRITE_FLAG_MORE: u32 = 2;
pub const TCP_PRIO_MIN: u32 = 1;
pub const TCP_PRIO_NORMAL: u32 = 64;
pub const TCP_PRIO_MAX: u32 = 127;
pub const DNS_TMR_INTERVAL: u32 = 1000;
pub const DNS_RRTYPE_A: u32 = 1;
pub const DNS_RRTYPE_NS: u32 = 2;
pub const DNS_RRTYPE_MD: u32 = 3;
pub const DNS_RRTYPE_MF: u32 = 4;
pub const DNS_RRTYPE_CNAME: u32 = 5;
pub const DNS_RRTYPE_SOA: u32 = 6;
pub const DNS_RRTYPE_MB: u32 = 7;
pub const DNS_RRTYPE_MG: u32 = 8;
pub const DNS_RRTYPE_MR: u32 = 9;
pub const DNS_RRTYPE_NULL: u32 = 10;
pub const DNS_RRTYPE_WKS: u32 = 11;
pub const DNS_RRTYPE_PTR: u32 = 12;
pub const DNS_RRTYPE_HINFO: u32 = 13;
pub const DNS_RRTYPE_MINFO: u32 = 14;
pub const DNS_RRTYPE_MX: u32 = 15;
pub const DNS_RRTYPE_TXT: u32 = 16;
pub const DNS_RRCLASS_IN: u32 = 1;
pub const DNS_RRCLASS_CS: u32 = 2;
pub const DNS_RRCLASS_CH: u32 = 3;
pub const DNS_RRCLASS_HS: u32 = 4;
pub const DNS_RRCLASS_FLUSH: u32 = 2048;
pub const NETDB_ELEM_SIZE: u32 = 305;
pub const INSTRUMENT_PORT: u32 = 8760;
pub const INSTRUMENT_LENGTH: u32 = 80;
pub const MDNS_NAME_LENGTH: u32 = 68;
pub const DNS_SD_SERVICE: &[u8; 29] = b"_services._dns-sd._udp.local\0";
pub const SERVICE_DESCRIPTION: &[u8; 14] = b"PUCK PROTOCOL\0";
pub const PUCK_SERVICE_LENGTH: u32 = 30;
pub const UUID_LEN: u32 = 16;
pub const DS_VERS_LEN: u32 = 2;
pub const DS_SIZE_LEN: u32 = 2;
pub const MAN_ID_LEN: u32 = 4;
pub const MAN_MODEL_LEN: u32 = 2;
pub const MAN_VERS_LEN: u32 = 2;
pub const SER_NUM_LEN: u32 = 4;
pub const NAME_LEN: u32 = 64;
pub const PUCK_DATASHEET_SIZE: u32 = 96;
pub const UUID_OFFSET: u32 = 0;
pub const DS_VERS_OFFSET: u32 = 16;
pub const DS_SIZE_OFFSET: u32 = 18;
pub const MAN_ID_OFFSET: u32 = 20;
pub const MAN_MODEL_OFFSET: u32 = 24;
pub const MAN_VERS_OFFSET: u32 = 26;
pub const SER_NUM_OFFSET: u32 = 28;
pub const NAME_OFFSET: u32 = 32;
pub const DNS_OFFSET_FLAG: u32 = 192;
pub const DNS_DEFAULT_OFFSET: u32 = 12;
pub const DNS_IP_ADDR_LEN: u32 = 4;
pub const DNS_RRTYPE_SRV: u32 = 33;
pub const DNS_RRTYPE_OPT: u32 = 41;
pub const DNS_RRTYPE_TSIG: u32 = 250;
pub const DNS_RRTYPE_ANY: u32 = 255;
pub const DNS_RRCLASS_FLUSH_IN: u32 = 32769;
pub const LWIP_VERSION_MAJOR: u32 = 1;
pub const LWIP_VERSION_MINOR: u32 = 4;
pub const LWIP_VERSION_REVISION: u32 = 0;
pub const LWIP_VERSION_RC: u32 = 2;
pub const LWIP_RC_RELEASE: u32 = 255;
pub const LWIP_RC_DEVELOPMENT: u32 = 0;
pub const LWIP_VERSION: u32 = 17039362;
pub const IGMP_TMR_INTERVAL: u32 = 100;
pub const IGMP_V1_DELAYING_MEMBER_TMR: u32 = 10;
pub const IGMP_JOIN_DELAYING_MEMBER_TMR: u32 = 5;
pub const IGMP_DEL_MAC_FILTER: u32 = 0;
pub const IGMP_ADD_MAC_FILTER: u32 = 1;
pub const LWIP_CHKSUM_COPY_ALGORITHM: u32 = 0;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const SNTP_MAX_SERVERS: u32 = 3;
pub const SNTP_GET_SERVERS_FROM_DHCP: u32 = 0;
pub const SNTP_SERVER_DNS: u32 = 1;
pub const NETBUF_FLAG_DESTADDR: u32 = 1;
pub const NETBUF_FLAG_CHKSUM: u32 = 2;
pub const UDP_HLEN: u32 = 8;
pub const UDP_FLAGS_NOCHKSUM: u32 = 1;
pub const UDP_FLAGS_UDPLITE: u32 = 2;
pub const UDP_FLAGS_CONNECTED: u32 = 4;
pub const UDP_FLAGS_MULTICAST_LOOP: u32 = 8;
pub const DHCP_COARSE_TIMER_SECS: u32 = 60;
pub const DHCP_COARSE_TIMER_MSECS: u32 = 60000;
pub const DHCP_FINE_TIMER_MSECS: u32 = 500;
pub const DHCP_CHADDR_LEN: u32 = 16;
pub const DHCP_SNAME_LEN: u32 = 64;
pub const DHCP_FILE_LEN: u32 = 128;
pub const LWIP_DHCP_BOOTP_FILE: u32 = 0;
pub const DHCP_MIN_OPTIONS_LEN: u32 = 68;
pub const DHCP_OPTIONS_LEN: u32 = 68;
pub const DHCP_OP_OFS: u32 = 0;
pub const DHCP_HTYPE_OFS: u32 = 1;
pub const DHCP_HLEN_OFS: u32 = 2;
pub const DHCP_HOPS_OFS: u32 = 3;
pub const DHCP_XID_OFS: u32 = 4;
pub const DHCP_SECS_OFS: u32 = 8;
pub const DHCP_FLAGS_OFS: u32 = 10;
pub const DHCP_CIADDR_OFS: u32 = 12;
pub const DHCP_YIADDR_OFS: u32 = 16;
pub const DHCP_SIADDR_OFS: u32 = 20;
pub const DHCP_GIADDR_OFS: u32 = 24;
pub const DHCP_CHADDR_OFS: u32 = 28;
pub const DHCP_SNAME_OFS: u32 = 44;
pub const DHCP_FILE_OFS: u32 = 108;
pub const DHCP_MSG_LEN: u32 = 236;
pub const DHCP_COOKIE_OFS: u32 = 236;
pub const DHCP_OPTIONS_OFS: u32 = 240;
pub const DHCP_CLIENT_PORT: u32 = 68;
pub const DHCP_SERVER_PORT: u32 = 67;
pub const DHCP_OFF: u32 = 0;
pub const DHCP_REQUESTING: u32 = 1;
pub const DHCP_INIT: u32 = 2;
pub const DHCP_REBOOTING: u32 = 3;
pub const DHCP_REBINDING: u32 = 4;
pub const DHCP_RENEWING: u32 = 5;
pub const DHCP_SELECTING: u32 = 6;
pub const DHCP_INFORMING: u32 = 7;
pub const DHCP_CHECKING: u32 = 8;
pub const DHCP_PERMANENT: u32 = 9;
pub const DHCP_BOUND: u32 = 10;
pub const DHCP_BACKING_OFF: u32 = 12;
pub const DHCP_AUTOIP_COOP_STATE_OFF: u32 = 0;
pub const DHCP_AUTOIP_COOP_STATE_ON: u32 = 1;
pub const DHCP_BOOTREQUEST: u32 = 1;
pub const DHCP_BOOTREPLY: u32 = 2;
pub const DHCP_DISCOVER: u32 = 1;
pub const DHCP_OFFER: u32 = 2;
pub const DHCP_REQUEST: u32 = 3;
pub const DHCP_DECLINE: u32 = 4;
pub const DHCP_ACK: u32 = 5;
pub const DHCP_NAK: u32 = 6;
pub const DHCP_RELEASE: u32 = 7;
pub const DHCP_INFORM: u32 = 8;
pub const DHCP_HTYPE_ETH: u32 = 1;
pub const DHCP_MAGIC_COOKIE: u32 = 1669485411;
pub const DHCP_OPTION_PAD: u32 = 0;
pub const DHCP_OPTION_SUBNET_MASK: u32 = 1;
pub const DHCP_OPTION_ROUTER: u32 = 3;
pub const DHCP_OPTION_DNS_SERVER: u32 = 6;
pub const DHCP_OPTION_HOSTNAME: u32 = 12;
pub const DHCP_OPTION_IP_TTL: u32 = 23;
pub const DHCP_OPTION_MTU: u32 = 26;
pub const DHCP_OPTION_BROADCAST: u32 = 28;
pub const DHCP_OPTION_TCP_TTL: u32 = 37;
pub const DHCP_OPTION_END: u32 = 255;
pub const DHCP_OPTION_DOMAIN_NAME: u32 = 15;
pub const DHCP_OPTION_PRD: u32 = 31;
pub const DHCP_OPTION_STATIC_ROUTER: u32 = 33;
pub const DHCP_OPTION_VSN: u32 = 43;
pub const DHCP_OPTION_NB_TINS: u32 = 44;
pub const DHCP_OPTION_NB_TINT: u32 = 46;
pub const DHCP_OPTION_NB_TIS: u32 = 47;
pub const DHCP_OPTION_CLASSLESS_STATIC_ROUTER: u32 = 121;
pub const DHCP_OPTION_REQUESTED_IP: u32 = 50;
pub const DHCP_OPTION_LEASE_TIME: u32 = 51;
pub const DHCP_OPTION_OVERLOAD: u32 = 52;
pub const DHCP_OPTION_MESSAGE_TYPE: u32 = 53;
pub const DHCP_OPTION_MESSAGE_TYPE_LEN: u32 = 1;
pub const DHCP_OPTION_SERVER_ID: u32 = 54;
pub const DHCP_OPTION_PARAMETER_REQUEST_LIST: u32 = 55;
pub const DHCP_OPTION_MAX_MSG_SIZE: u32 = 57;
pub const DHCP_OPTION_MAX_MSG_SIZE_LEN: u32 = 2;
pub const DHCP_OPTION_T1: u32 = 58;
pub const DHCP_OPTION_T2: u32 = 59;
pub const DHCP_OPTION_US: u32 = 60;
pub const DHCP_OPTION_CLIENT_ID: u32 = 61;
pub const DHCP_OPTION_TFTP_SERVERNAME: u32 = 66;
pub const DHCP_OPTION_BOOTFILE: u32 = 67;
pub const DHCP_OVERLOAD_NONE: u32 = 0;
pub const DHCP_OVERLOAD_FILE: u32 = 1;
pub const DHCP_OVERLOAD_SNAME: u32 = 2;
pub const DHCP_OVERLOAD_SNAME_FILE: u32 = 3;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_CLASSD_NET: u32 = 4026531840;
pub const IN_CLASSD_NSHIFT: u32 = 28;
pub const IN_CLASSD_HOST: u32 = 268435455;
pub const IN_LOOPBACKNET: u32 = 127;
pub const TCP_FIN: u32 = 1;
pub const TCP_SYN: u32 = 2;
pub const TCP_RST: u32 = 4;
pub const TCP_PSH: u32 = 8;
pub const TCP_ACK: u32 = 16;
pub const TCP_URG: u32 = 32;
pub const TCP_ECE: u32 = 64;
pub const TCP_CWR: u32 = 128;
pub const TCP_FLAGS: u32 = 63;
pub const TCP_HLEN: u32 = 20;
pub const TCP_TMR_INTERVAL: u32 = 125;
pub const TCP_FAST_INTERVAL: u32 = 125;
pub const TCP_SLOW_INTERVAL: u32 = 250;
pub const TCP_FIN_WAIT_TIMEOUT: u32 = 20000;
pub const TCP_SYN_RCVD_TIMEOUT: u32 = 20000;
pub const TCP_OOSEQ_TIMEOUT: u32 = 6;
pub const TCP_MSL: u32 = 60000;
pub const TCP_KEEPIDLE_DEFAULT: u32 = 120000;
pub const TCP_KEEPINTVL_DEFAULT: u32 = 10000;
pub const TCP_KEEPCNT_DEFAULT: u32 = 9;
pub const TCP_MAXIDLE: u32 = 90000;
pub const TCP_OVERSIZE_DBGCHECK: u32 = 0;
pub const TCP_DEBUG_PCB_LISTS: u32 = 0;
pub const LWIP_DEBUG_TIMERNAMES: u32 = 0;
pub const ESPCONN_UDP_DEBUG: u32 = 0;
pub const ESPCONN_OK: u32 = 0;
pub const ESPCONN_MEM: i32 = -1;
pub const ESPCONN_TIMEOUT: i32 = -3;
pub const ESPCONN_RTE: i32 = -4;
pub const ESPCONN_INPROGRESS: i32 = -5;
pub const ESPCONN_MAXNUM: i32 = -7;
pub const ESPCONN_ABRT: i32 = -8;
pub const ESPCONN_RST: i32 = -9;
pub const ESPCONN_CLSD: i32 = -10;
pub const ESPCONN_CONN: i32 = -11;
pub const ESPCONN_ARG: i32 = -12;
pub const ESPCONN_IF: i32 = -14;
pub const ESPCONN_ISCONN: i32 = -15;
pub const ESPCONN_TIME: i32 = -16;
pub const ESPCONN_NODATA: i32 = -17;
pub const ESPCONN_HANDSHAKE: i32 = -28;
pub const ESPCONN_RESP_TIMEOUT: i32 = -29;
pub const ESPCONN_PROTO_MSG: i32 = -61;
pub const ESPCONN_SSL: u32 = 1;
pub const ESPCONN_NORM: u32 = 0;
pub const ESPCONN_STA: u32 = 1;
pub const ESPCONN_AP: u32 = 2;
pub const ESPCONN_AP_STA: u32 = 3;
pub const STA_NETIF: u32 = 0;
pub const AP_NETIF: u32 = 1;
pub const linkMax: u32 = 15;
pub const espconn_TaskPrio: u32 = 26;
pub const espconn_TaskQueueLen: u32 = 15;
pub const ESPCONN_TCP_DEBUG: u32 = 0;
pub const ESPCONN_TCP_TIMER: u32 = 40;
pub const DHCPS_MAX_LEASE: u32 = 100;
pub const BOOTP_BROADCAST: u32 = 32768;
pub const DHCP_REPLY: u32 = 2;
pub const DHCP_HTYPE_ETHERNET: u32 = 1;
pub const DHCP_HLEN_ETHERNET: u32 = 6;
pub const DHCPS_SERVER_PORT: u32 = 67;
pub const DHCPS_CLIENT_PORT: u32 = 68;
pub const DHCPDISCOVER: u32 = 1;
pub const DHCPOFFER: u32 = 2;
pub const DHCPREQUEST: u32 = 3;
pub const DHCPDECLINE: u32 = 4;
pub const DHCPACK: u32 = 5;
pub const DHCPNAK: u32 = 6;
pub const DHCPRELEASE: u32 = 7;
pub const DHCP_OPTION_REQ_IPADDR: u32 = 50;
pub const DHCP_OPTION_MSG_TYPE: u32 = 53;
pub const DHCP_OPTION_INTERFACE_MTU: u32 = 26;
pub const DHCP_OPTION_PERFORM_ROUTER_DISCOVERY: u32 = 31;
pub const DHCP_OPTION_BROADCAST_ADDRESS: u32 = 28;
pub const DHCP_OPTION_REQ_LIST: u32 = 55;
pub const DHCPS_DEBUG: u32 = 0;
pub const MAX_STATION_NUM: u32 = 8;
pub const DHCPS_STATE_OFFER: u32 = 1;
pub const DHCPS_STATE_DECLINE: u32 = 2;
pub const DHCPS_STATE_ACK: u32 = 3;
pub const DHCPS_STATE_NAK: u32 = 4;
pub const DHCPS_STATE_IDLE: u32 = 5;
pub const DHCPS_STATE_RELEASE: u32 = 6;
pub const PING_USE_SOCKETS: u32 = 0;
pub const PING_DEBUG: u32 = 0;
pub const PING_RCV_TIMEO: u32 = 1000;
pub const PING_COARSE: u32 = 1000;
pub const PING_ID: u32 = 44975;
pub const PING_DATA_SIZE: u32 = 32;
pub const DEFAULT_PING_MAX_COUNT: u32 = 4;
pub const PING_TIMEOUT_MS: u32 = 1000;
pub const _SYS_TIME_H: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub type sint8_t = ::core::ffi::c_schar;
pub type sint16_t = ::core::ffi::c_short;
pub type sint32_t = ::core::ffi::c_int;
pub type sint64_t = ::core::ffi::c_longlong;
pub type u_int64_t = ::core::ffi::c_ulonglong;
pub type real32_t = f32;
pub type real64_t = f64;
pub type uint8 = ::core::ffi::c_uchar;
pub type u8_ = ::core::ffi::c_uchar;
pub type sint8 = ::core::ffi::c_schar;
pub type int8 = ::core::ffi::c_schar;
pub type s8 = ::core::ffi::c_schar;
pub type uint16 = ::core::ffi::c_ushort;
pub type u16_ = ::core::ffi::c_ushort;
pub type sint16 = ::core::ffi::c_short;
pub type s16 = ::core::ffi::c_short;
pub type uint32 = ::core::ffi::c_uint;
pub type u_int = ::core::ffi::c_uint;
pub type u32_ = ::core::ffi::c_uint;
pub type sint32 = ::core::ffi::c_int;
pub type s32 = ::core::ffi::c_int;
pub type int32 = ::core::ffi::c_int;
pub type sint64 = ::core::ffi::c_longlong;
pub type uint64 = ::core::ffi::c_ulonglong;
pub type u64_ = ::core::ffi::c_ulonglong;
pub type real32 = f32;
pub type real64 = f64;
pub const STATUS_OK: STATUS = 0;
pub const STATUS_FAIL: STATUS = 1;
pub const STATUS_PENDING: STATUS = 2;
pub const STATUS_BUSY: STATUS = 3;
pub const STATUS_CANCEL: STATUS = 4;
pub type STATUS = ::core::ffi::c_uint;
pub type bool_ = ::core::ffi::c_uchar;
pub type ETSSignal = u32;
pub type ETSParam = u32;
pub type ETSEvent = ETSEventTag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ETSEventTag {
    pub sig: ETSSignal,
    pub par: ETSParam,
}
pub type ETSTask = ::core::option::Option<unsafe extern "C" fn(e: *mut ETSEvent)>;
pub type ETSHandle = u32;
pub type ETSTimerFunc =
    ::core::option::Option<unsafe extern "C" fn(timer_arg: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETSTIMER_ {
    pub timer_next: *mut _ETSTIMER_,
    pub timer_expire: u32,
    pub timer_period: u32,
    pub timer_func: ETSTimerFunc,
    pub timer_arg: *mut ::core::ffi::c_void,
}
pub type ETSTimer = _ETSTIMER_;
pub type ets_isr_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::core::ffi::c_ushort,
    pub __ctype_tolower: *const ::core::ffi::c_int,
    pub __ctype_toupper: *const ::core::ffi::c_int,
    pub __names: [*const ::core::ffi::c_char; 13usize],
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
pub type u8_t = ::core::ffi::c_uchar;
pub type s8_t = ::core::ffi::c_schar;
pub type u16_t = ::core::ffi::c_ushort;
pub type s16_t = ::core::ffi::c_short;
pub type u32_t = ::core::ffi::c_ulong;
pub type s32_t = ::core::ffi::c_long;
pub type mem_ptr_t = ::core::ffi::c_ulong;
pub type err_t = s32_t;
pub const pbuf_layer_PBUF_TRANSPORT: pbuf_layer = 0;
pub const pbuf_layer_PBUF_IP: pbuf_layer = 1;
pub const pbuf_layer_PBUF_LINK: pbuf_layer = 2;
pub const pbuf_layer_PBUF_RAW: pbuf_layer = 3;
pub type pbuf_layer = ::core::ffi::c_uint;
pub const pbuf_type_PBUF_RAM: pbuf_type = 0;
pub const pbuf_type_PBUF_ROM: pbuf_type = 1;
pub const pbuf_type_PBUF_REF: pbuf_type = 2;
pub const pbuf_type_PBUF_POOL: pbuf_type = 3;
pub type pbuf_type = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pbuf {
    #[doc = " next pbuf in singly linked pbuf chain"]
    pub next: *mut pbuf,
    #[doc = " pointer to the actual data in the buffer"]
    pub payload: *mut ::core::ffi::c_void,
    #[doc = " total length of this buffer and all next buffers in chain\n belonging to the same packet.\n\n For non-queue packet chains this is the invariant:\n p->tot_len == p->len + (p->next? p->next->tot_len: 0)"]
    pub tot_len: u16_t,
    #[doc = " length of this buffer"]
    pub len: u16_t,
    #[doc = " pbuf_type as u8_t instead of enum to save space"]
    pub type_: u8_t,
    #[doc = " misc flags"]
    pub flags: u8_t,
    #[doc = " the reference count always equals the number of pointers\n that refer to this pbuf. This can be pointers from an application,\n the stack itself, or pbuf->next pointers from a chain."]
    pub ref_: u16_t,
    pub eb: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_addr {
    pub addr: u32_t,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ip_addr_packed {
    pub addr: u32_t,
}
#[doc = " ip_addr_t uses a struct for convenience only, so that the same defines can\n operate both on ip_addr_t as well as on ip_addr_p_t."]
pub type ip_addr_t = ip_addr;
pub type ip_addr_p_t = ip_addr_packed;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ip_addr2 {
    pub addrw: [u16_t; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_info {
    pub ip: ip_addr,
    pub netmask: ip_addr,
    pub gw: ip_addr,
}
#[doc = " Function prototype for netif init functions. Set up flags and output/linkoutput\n callback functions in this function.\n\n @param netif The netif to initialize"]
pub type netif_init_fn = ::core::option::Option<unsafe extern "C" fn(netif: *mut netif) -> err_t>;
#[doc = " Function prototype for netif->input functions. This function is saved as 'input'\n callback function in the netif struct. Call it when a packet has been received.\n\n @param p The received packet, copied into a pbuf\n @param inp The netif which received the packet"]
pub type netif_input_fn =
    ::core::option::Option<unsafe extern "C" fn(p: *mut pbuf, inp: *mut netif) -> err_t>;
#[doc = " Function prototype for netif->output functions. Called by lwIP when a packet\n shall be sent. For ethernet netif, set this to 'etharp_output' and set\n 'linkoutput'.\n\n @param netif The netif which shall send a packet\n @param p The packet to send (p->payload points to IP header)\n @param ipaddr The IP address to which the packet shall be sent"]
pub type netif_output_fn = ::core::option::Option<
    unsafe extern "C" fn(netif: *mut netif, p: *mut pbuf, ipaddr: *mut ip_addr_t) -> err_t,
>;
#[doc = " Function prototype for netif->linkoutput functions. Only used for ethernet\n netifs. This function is called by ARP when a packet shall be sent.\n\n @param netif The netif which shall send a packet\n @param p The packet to send (raw ethernet packet)"]
pub type netif_linkoutput_fn =
    ::core::option::Option<unsafe extern "C" fn(netif: *mut netif, p: *mut pbuf) -> err_t>;
#[doc = " Function prototype for netif status- or link-callback functions."]
pub type netif_status_callback_fn = ::core::option::Option<unsafe extern "C" fn(netif: *mut netif)>;
#[doc = " Function prototype for netif igmp_mac_filter functions"]
pub type netif_igmp_mac_filter_fn = ::core::option::Option<
    unsafe extern "C" fn(netif: *mut netif, group: *mut ip_addr_t, action: u8_t) -> err_t,
>;
pub type dhcp_event_fn = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " Generic data structure used for all lwIP network interfaces.\n  The following fields should be filled in by the initialization\n  function for the device driver: hwaddr_len, hwaddr[], mtu, flags"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netif {
    #[doc = " pointer to next in linked list"]
    pub next: *mut netif,
    #[doc = " IP address configuration in network byte order"]
    pub ip_addr: ip_addr_t,
    pub netmask: ip_addr_t,
    pub gw: ip_addr_t,
    #[doc = " This function is called by the network device driver\n  to pass a packet up the TCP/IP stack. ��IP���������ݰ�"]
    pub input: netif_input_fn,
    #[doc = " This function is called by the IP module when it wants\n  to send a packet on the interface. This function typically\n  first resolves the hardware address, then sends the packet. ����IP���ݰ�"]
    pub output: netif_output_fn,
    #[doc = " This function is called by the ARP module when it wants\n  to send a packet on the interface. This function outputs\n  the pbuf as-is on the link medium. �ײ����ݰ�����"]
    pub linkoutput: netif_linkoutput_fn,
    #[doc = " This field can be set by the device driver and could point\n  to state information for the device. ���������\u{5b6}Σ�����\u{5b8}��ײ��豸�����Ϣ"]
    pub state: *mut ::core::ffi::c_void,
    #[doc = " the DHCP client state information for this netif"]
    pub dhcp: *mut dhcp,
    pub dhcps_pcb: *mut udp_pcb,
    pub dhcp_event: dhcp_event_fn,
    pub hostname: *mut ::core::ffi::c_char,
    #[doc = " maximum transfer unit (in bytes) �ýӿ�������������ݰ����ȣ�����1500"]
    pub mtu: u16_t,
    #[doc = " number of bytes used in hwaddr�ýӿ�������\u{5b7}����"]
    pub hwaddr_len: u8_t,
    #[doc = " link level hardware address of this interface �ýӿ�������\u{5b7}"]
    pub hwaddr: [u8_t; 6usize],
    #[doc = " flags (see NETIF_FLAG_ above) �ýӿ�״\u{32c}�������\u{5b6}�"]
    pub flags: u8_t,
    #[doc = " descriptive abbreviation �ýӿڵ�����"]
    pub name: [::core::ffi::c_char; 2usize],
    #[doc = " number of this interface �ýӿڵı��"]
    pub num: u8_t,
    #[doc = " This function could be called to add or delete a entry in the multicast\nfilter table of the ethernet MAC."]
    pub igmp_mac_filter: netif_igmp_mac_filter_fn,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_pcb {
    pub local_ip: ip_addr_t,
    pub remote_ip: ip_addr_t,
    pub so_options: u8_t,
    pub tos: u8_t,
    pub ttl: u8_t,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ip_hdr {
    pub _v_hl_tos: u16_t,
    pub _len: u16_t,
    pub _id: u16_t,
    pub _offset: u16_t,
    pub _ttl: u8_t,
    pub _proto: u8_t,
    pub _chksum: u16_t,
    pub src: ip_addr_p_t,
    pub dest: ip_addr_p_t,
}
pub type wchar_t = ::core::ffi::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::core::ffi::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
pub type mem_size_t = usize;
pub const memp_t_MEMP_RAW_PCB: memp_t = 0;
pub const memp_t_MEMP_UDP_PCB: memp_t = 1;
pub const memp_t_MEMP_TCP_PCB: memp_t = 2;
pub const memp_t_MEMP_TCP_PCB_LISTEN: memp_t = 3;
pub const memp_t_MEMP_TCP_SEG: memp_t = 4;
pub const memp_t_MEMP_ARP_QUEUE: memp_t = 5;
pub const memp_t_MEMP_IGMP_GROUP: memp_t = 6;
pub const memp_t_MEMP_SYS_TIMEOUT: memp_t = 7;
pub const memp_t_MEMP_PBUF: memp_t = 8;
pub const memp_t_MEMP_PBUF_POOL: memp_t = 9;
pub const memp_t_MEMP_MAX: memp_t = 10;
pub type memp_t = ::core::ffi::c_uint;
pub type sys_sem_t = u8_t;
pub type sys_mutex_t = u8_t;
pub type sys_mbox_t = u8_t;
pub const icmp_dur_type_ICMP_DUR_NET: icmp_dur_type = 0;
pub const icmp_dur_type_ICMP_DUR_HOST: icmp_dur_type = 1;
pub const icmp_dur_type_ICMP_DUR_PROTO: icmp_dur_type = 2;
pub const icmp_dur_type_ICMP_DUR_PORT: icmp_dur_type = 3;
pub const icmp_dur_type_ICMP_DUR_FRAG: icmp_dur_type = 4;
pub const icmp_dur_type_ICMP_DUR_SR: icmp_dur_type = 5;
pub type icmp_dur_type = ::core::ffi::c_uint;
pub const icmp_te_type_ICMP_TE_TTL: icmp_te_type = 0;
pub const icmp_te_type_ICMP_TE_FRAG: icmp_te_type = 1;
pub type icmp_te_type = ::core::ffi::c_uint;
#[doc = " This is the standard ICMP header only that the u32_t data\n  is splitted to two u16_t like ICMP echo needs it.\n  This header is also used for other ICMP types that do not\n  use the data part.\n  ����ICMP�����������ײ��ṹ��\n  ��������ICMP�����ײ��к\u{734}������ԣ�\n  �ýṹ\u{36c}������������ICMP���ġ�"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct icmp_echo_hdr {
    pub type_: u8_t,
    pub code: u8_t,
    pub chksum: u16_t,
    pub id: u16_t,
    pub seqno: u16_t,
}
#[doc = " Function prototype for tcp accept callback functions. Called when a new\n connection can be accepted on a listening pcb.\n\n @param arg Additional argument to pass to the callback function (@see tcp_arg())\n @param newpcb The new connection pcb\n @param err An error code if there has been an error accepting.\n            Only return ERR_ABRT if you have called tcp_abort from within the\n            callback function!"]
pub type tcp_accept_fn = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, newpcb: *mut tcp_pcb, err: err_t) -> err_t,
>;
#[doc = " Function prototype for tcp receive callback functions. Called when data has\n been received.\n\n @param arg Additional argument to pass to the callback function (@see tcp_arg())\n @param tpcb The connection pcb which received data\n @param p The received data (or NULL when the connection has been closed!)\n @param err An error code if there has been an error receiving\n            Only return ERR_ABRT if you have called tcp_abort from within the\n            callback function!"]
pub type tcp_recv_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::core::ffi::c_void,
        tpcb: *mut tcp_pcb,
        p: *mut pbuf,
        err: err_t,
    ) -> err_t,
>;
#[doc = " Function prototype for tcp sent callback functions. Called when sent data has\n been acknowledged by the remote side. Use it to free corresponding resources.\n This also means that the pcb has now space available to send new data.\n\n @param arg Additional argument to pass to the callback function (@see tcp_arg())\n @param tpcb The connection pcb for which data has been acknowledged\n @param len The amount of bytes acknowledged\n @return ERR_OK: try to send some data by calling tcp_output\n            Only return ERR_ABRT if you have called tcp_abort from within the\n            callback function!"]
pub type tcp_sent_fn = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, tpcb: *mut tcp_pcb, len: u16_t) -> err_t,
>;
#[doc = " Function prototype for tcp poll callback functions. Called periodically as\n specified by @see tcp_poll.\n\n @param arg Additional argument to pass to the callback function (@see tcp_arg())\n @param tpcb tcp pcb\n @return ERR_OK: try to send some data by calling tcp_output\n            Only return ERR_ABRT if you have called tcp_abort from within the\n            callback function!"]
pub type tcp_poll_fn = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, tpcb: *mut tcp_pcb) -> err_t,
>;
#[doc = " Function prototype for tcp error callback functions. Called when the pcb\n receives a RST or is unexpectedly closed for any other reason.\n\n @note The corresponding pcb is already freed when this callback is called!\n\n @param arg Additional argument to pass to the callback function (@see tcp_arg())\n @param err Error code to indicate why the pcb has been closed\n            ERR_ABRT: aborted through tcp_abort or by a TCP timer\n            ERR_RST: the connection was reset by the remote host"]
pub type tcp_err_fn =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, err: err_t)>;
#[doc = " Function prototype for tcp connected callback functions. Called when a pcb\n is connected to the remote side after initiating a connection attempt by\n calling tcp_connect().\n\n @param arg Additional argument to pass to the callback function (@see tcp_arg())\n @param tpcb The connection pcb which is connected\n @param err An unused error code, always ERR_OK currently ;-) TODO!\n            Only return ERR_ABRT if you have called tcp_abort from within the\n            callback function!\n\n @note When a connection attempt fails, the error callback is currently called!"]
pub type tcp_connected_fn = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, tpcb: *mut tcp_pcb, err: err_t) -> err_t,
>;
pub const tcp_state_CLOSED: tcp_state = 0;
pub const tcp_state_LISTEN: tcp_state = 1;
pub const tcp_state_SYN_SENT: tcp_state = 2;
pub const tcp_state_SYN_RCVD: tcp_state = 3;
pub const tcp_state_ESTABLISHED: tcp_state = 4;
pub const tcp_state_FIN_WAIT_1: tcp_state = 5;
pub const tcp_state_FIN_WAIT_2: tcp_state = 6;
pub const tcp_state_CLOSE_WAIT: tcp_state = 7;
pub const tcp_state_CLOSING: tcp_state = 8;
pub const tcp_state_LAST_ACK: tcp_state = 9;
pub const tcp_state_TIME_WAIT: tcp_state = 10;
pub type tcp_state = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_pcb {
    #[doc = " common PCB members"]
    pub local_ip: ip_addr_t,
    #[doc = " common PCB members"]
    pub remote_ip: ip_addr_t,
    #[doc = " common PCB members"]
    pub so_options: u8_t,
    #[doc = " common PCB members"]
    pub tos: u8_t,
    #[doc = " common PCB members"]
    pub ttl: u8_t,
    #[doc = " protocol specific PCB members"]
    pub next: *mut tcp_pcb,
    #[doc = " protocol specific PCB members"]
    pub state: tcp_state,
    #[doc = " protocol specific PCB members"]
    pub prio: u8_t,
    #[doc = " protocol specific PCB members"]
    pub callback_arg: *mut ::core::ffi::c_void,
    #[doc = " protocol specific PCB members"]
    pub accept: tcp_accept_fn,
    #[doc = " protocol specific PCB members"]
    pub local_port: u16_t,
    pub remote_port: u16_t,
    pub flags: u8_t,
    pub rcv_nxt: u32_t,
    pub rcv_wnd: u16_t,
    pub rcv_ann_wnd: u16_t,
    pub rcv_ann_right_edge: u32_t,
    pub tmr: u32_t,
    pub polltmr: u8_t,
    pub pollinterval: u8_t,
    pub rtime: s16_t,
    pub mss: u16_t,
    pub rttest: u32_t,
    pub rtseq: u32_t,
    pub sa: s16_t,
    pub sv: s16_t,
    pub rto: s16_t,
    pub nrtx: u8_t,
    pub lastack: u32_t,
    pub dupacks: u8_t,
    pub cwnd: u16_t,
    pub ssthresh: u16_t,
    pub snd_nxt: u32_t,
    pub snd_wnd: u16_t,
    pub snd_wl1: u32_t,
    pub snd_wl2: u32_t,
    pub snd_lbb: u32_t,
    pub acked: u16_t,
    pub snd_buf: u16_t,
    pub snd_queuelen: u16_t,
    pub unsent_oversize: u16_t,
    pub unsent: *mut tcp_seg,
    pub unacked: *mut tcp_seg,
    pub ooseq: *mut tcp_seg,
    pub refused_data: *mut pbuf,
    pub sent: tcp_sent_fn,
    pub recv: tcp_recv_fn,
    pub connected: tcp_connected_fn,
    pub poll: tcp_poll_fn,
    pub errf: tcp_err_fn,
    pub keep_idle: u32_t,
    pub keep_intvl: u32_t,
    pub keep_cnt: u32_t,
    pub persist_cnt: u32_t,
    pub persist_backoff: u8_t,
    pub keep_cnt_sent: u8_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_pcb_listen {
    pub local_ip: ip_addr_t,
    pub remote_ip: ip_addr_t,
    pub so_options: u8_t,
    pub tos: u8_t,
    pub ttl: u8_t,
    pub next: *mut tcp_pcb_listen,
    pub state: tcp_state,
    pub prio: u8_t,
    pub callback_arg: *mut ::core::ffi::c_void,
    pub accept: tcp_accept_fn,
    pub local_port: u16_t,
}
#[doc = " Callback which is invoked when a hostname is found.\n A function of this type must be implemented by the application using the DNS resolver.\n @param name pointer to the name that was looked up.\n @param ipaddr pointer to an ip_addr_t containing the IP address of the hostname,\n        or NULL if the name could not be found (or on any other error).\n @param callback_arg a user-specified callback argument passed to dns_gethostbyname"]
pub type dns_found_callback = ::core::option::Option<
    unsafe extern "C" fn(
        name: *const ::core::ffi::c_char,
        ipaddr: *mut ip_addr_t,
        callback_arg: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mdns_info {
    pub host_name: *mut ::core::ffi::c_char,
    pub server_name: *mut ::core::ffi::c_char,
    pub server_port: uint16,
    pub ipAddr: ::core::ffi::c_ulong,
    pub txt_data: [*mut ::core::ffi::c_char; 10usize],
}
#[doc = " igmp group structure - there is\n a list of groups for each interface\n these should really be linked from the interface, but\n if we keep them separate we will not affect the lwip original code\n too much\n\n There will be a group for the all systems group address but this\n will not run the state machine as it is used to kick off reports\n from all the other groups"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct igmp_group {
    #[doc = " next link"]
    pub next: *mut igmp_group,
    #[doc = " interface on which the group is active"]
    pub netif: *mut netif,
    #[doc = " multicast address"]
    pub group_address: ip_addr_t,
    #[doc = " signifies we were the last person to report"]
    pub last_reporter_flag: u8_t,
    #[doc = " current state of the group"]
    pub group_state: u8_t,
    #[doc = " timer for reporting, negative is OFF"]
    pub timer: u16_t,
    #[doc = " counter of simultaneous uses"]
    pub use_: u8_t,
}
pub const snmp_ifType_snmp_ifType_other: snmp_ifType = 1;
pub const snmp_ifType_snmp_ifType_regular1822: snmp_ifType = 2;
pub const snmp_ifType_snmp_ifType_hdh1822: snmp_ifType = 3;
pub const snmp_ifType_snmp_ifType_ddn_x25: snmp_ifType = 4;
pub const snmp_ifType_snmp_ifType_rfc877_x25: snmp_ifType = 5;
pub const snmp_ifType_snmp_ifType_ethernet_csmacd: snmp_ifType = 6;
pub const snmp_ifType_snmp_ifType_iso88023_csmacd: snmp_ifType = 7;
pub const snmp_ifType_snmp_ifType_iso88024_tokenBus: snmp_ifType = 8;
pub const snmp_ifType_snmp_ifType_iso88025_tokenRing: snmp_ifType = 9;
pub const snmp_ifType_snmp_ifType_iso88026_man: snmp_ifType = 10;
pub const snmp_ifType_snmp_ifType_starLan: snmp_ifType = 11;
pub const snmp_ifType_snmp_ifType_proteon_10Mbit: snmp_ifType = 12;
pub const snmp_ifType_snmp_ifType_proteon_80Mbit: snmp_ifType = 13;
pub const snmp_ifType_snmp_ifType_hyperchannel: snmp_ifType = 14;
pub const snmp_ifType_snmp_ifType_fddi: snmp_ifType = 15;
pub const snmp_ifType_snmp_ifType_lapb: snmp_ifType = 16;
pub const snmp_ifType_snmp_ifType_sdlc: snmp_ifType = 17;
pub const snmp_ifType_snmp_ifType_ds1: snmp_ifType = 18;
pub const snmp_ifType_snmp_ifType_e1: snmp_ifType = 19;
pub const snmp_ifType_snmp_ifType_basicISDN: snmp_ifType = 20;
pub const snmp_ifType_snmp_ifType_primaryISDN: snmp_ifType = 21;
pub const snmp_ifType_snmp_ifType_propPointToPointSerial: snmp_ifType = 22;
pub const snmp_ifType_snmp_ifType_ppp: snmp_ifType = 23;
pub const snmp_ifType_snmp_ifType_softwareLoopback: snmp_ifType = 24;
pub const snmp_ifType_snmp_ifType_eon: snmp_ifType = 25;
pub const snmp_ifType_snmp_ifType_ethernet_3Mbit: snmp_ifType = 26;
pub const snmp_ifType_snmp_ifType_nsip: snmp_ifType = 27;
pub const snmp_ifType_snmp_ifType_slip: snmp_ifType = 28;
pub const snmp_ifType_snmp_ifType_ultra: snmp_ifType = 29;
pub const snmp_ifType_snmp_ifType_ds3: snmp_ifType = 30;
pub const snmp_ifType_snmp_ifType_sip: snmp_ifType = 31;
pub const snmp_ifType_snmp_ifType_frame_relay: snmp_ifType = 32;
#[doc = " @see RFC1213, \"MIB-II, 6. Definitions\""]
pub type snmp_ifType = ::core::ffi::c_uint;
pub type __u_char = ::core::ffi::c_uchar;
pub type __u_short = ::core::ffi::c_ushort;
pub type __u_int = ::core::ffi::c_uint;
pub type __u_long = ::core::ffi::c_ulong;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_long;
pub type __uint64_t = ::core::ffi::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::core::ffi::c_long;
pub type __u_quad_t = ::core::ffi::c_ulong;
pub type __intmax_t = ::core::ffi::c_long;
pub type __uintmax_t = ::core::ffi::c_ulong;
pub type __dev_t = ::core::ffi::c_ulong;
pub type __uid_t = ::core::ffi::c_uint;
pub type __gid_t = ::core::ffi::c_uint;
pub type __ino_t = ::core::ffi::c_ulong;
pub type __ino64_t = ::core::ffi::c_ulong;
pub type __mode_t = ::core::ffi::c_uint;
pub type __nlink_t = ::core::ffi::c_ulong;
pub type __off_t = ::core::ffi::c_long;
pub type __off64_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::core::ffi::c_int; 2usize],
}
pub type __clock_t = ::core::ffi::c_long;
pub type __rlim_t = ::core::ffi::c_ulong;
pub type __rlim64_t = ::core::ffi::c_ulong;
pub type __id_t = ::core::ffi::c_uint;
pub type __time_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_uint;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __suseconds64_t = ::core::ffi::c_long;
pub type __daddr_t = ::core::ffi::c_int;
pub type __key_t = ::core::ffi::c_int;
pub type __clockid_t = ::core::ffi::c_int;
pub type __timer_t = *mut ::core::ffi::c_void;
pub type __blksize_t = ::core::ffi::c_long;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blkcnt64_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = ::core::ffi::c_ulong;
pub type __fsblkcnt64_t = ::core::ffi::c_ulong;
pub type __fsfilcnt_t = ::core::ffi::c_ulong;
pub type __fsfilcnt64_t = ::core::ffi::c_ulong;
pub type __fsword_t = ::core::ffi::c_long;
pub type __ssize_t = ::core::ffi::c_long;
pub type __syscall_slong_t = ::core::ffi::c_long;
pub type __syscall_ulong_t = ::core::ffi::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::core::ffi::c_char;
pub type __intptr_t = ::core::ffi::c_long;
pub type __socklen_t = ::core::ffi::c_uint;
pub type __sig_atomic_t = ::core::ffi::c_int;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::core::ffi::c_int,
    pub tm_min: ::core::ffi::c_int,
    pub tm_hour: ::core::ffi::c_int,
    pub tm_mday: ::core::ffi::c_int,
    pub tm_mon: ::core::ffi::c_int,
    pub tm_year: ::core::ffi::c_int,
    pub tm_wday: ::core::ffi::c_int,
    pub tm_yday: ::core::ffi::c_int,
    pub tm_isdst: ::core::ffi::c_int,
    pub tm_gmtoff: ::core::ffi::c_long,
    pub tm_zone: *const ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netbuf {
    pub p: *mut pbuf,
    pub ptr: *mut pbuf,
    pub addr: ip_addr_t,
    pub port: u16_t,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct udp_hdr {
    pub src: u16_t,
    pub dest: u16_t,
    pub len: u16_t,
    pub chksum: u16_t,
}
#[doc = " Function prototype for udp pcb receive callback functions\n addr and port are in same byte order as in the pcb\n The callback is responsible for freeing the pbuf\n if it's not used any more.\n\n ATTENTION: Be aware that 'addr' points into the pbuf 'p' so freeing this pbuf\n            makes 'addr' invalid, too.\n\n @param arg user supplied argument (udp_pcb.recv_arg)\n @param pcb the udp_pcb which received data\n @param p the packet buffer that was received\n @param addr the remote IP address from which the packet was received\n @param port the remote port from which the packet was received"]
pub type udp_recv_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::core::ffi::c_void,
        pcb: *mut udp_pcb,
        p: *mut pbuf,
        addr: *mut ip_addr_t,
        port: u16_t,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udp_pcb {
    pub local_ip: ip_addr_t,
    pub remote_ip: ip_addr_t,
    pub so_options: u8_t,
    pub tos: u8_t,
    pub ttl: u8_t,
    pub next: *mut udp_pcb,
    pub flags: u8_t,
    #[doc = " ports are in host byte order"]
    pub local_port: u16_t,
    #[doc = " ports are in host byte order"]
    pub remote_port: u16_t,
    #[doc = " outgoing network interface for multicast packets"]
    pub multicast_ip: ip_addr_t,
    #[doc = " receive callback function"]
    pub recv: udp_recv_fn,
    #[doc = " user-supplied argument for the recv callback"]
    pub recv_arg: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dhcp {
    #[doc = " transaction identifier of last sent request"]
    pub xid: u32_t,
    #[doc = " our connection to the DHCP server"]
    pub pcb: *mut udp_pcb,
    #[doc = " incoming msg"]
    pub msg_in: *mut dhcp_msg,
    #[doc = " current DHCP state machine state"]
    pub state: u8_t,
    #[doc = " retries of current request"]
    pub tries: u8_t,
    pub subnet_mask_given: u8_t,
    pub p_out: *mut pbuf,
    pub msg_out: *mut dhcp_msg,
    pub options_out_len: u16_t,
    pub request_timeout: u16_t,
    pub t1_timeout: u16_t,
    pub t2_timeout: u16_t,
    pub t1_renew_time: u16_t,
    pub t2_rebind_time: u16_t,
    pub lease_used: u16_t,
    pub t0_timeout: u16_t,
    pub server_ip_addr: ip_addr_t,
    pub offered_ip_addr: ip_addr_t,
    pub offered_sn_mask: ip_addr_t,
    pub offered_gw_addr: ip_addr_t,
    pub offered_t0_lease: u32_t,
    pub offered_t1_renew: u32_t,
    pub offered_t2_rebind: u32_t,
}
#[doc = " minimum set of fields of any DHCP message"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct dhcp_msg {
    pub op: u8_t,
    pub htype: u8_t,
    pub hlen: u8_t,
    pub hops: u8_t,
    pub xid: u32_t,
    pub secs: u16_t,
    pub flags: u16_t,
    pub ciaddr: ip_addr_p_t,
    pub yiaddr: ip_addr_p_t,
    pub siaddr: ip_addr_p_t,
    pub giaddr: ip_addr_p_t,
    pub chaddr: [u8_t; 16usize],
    pub sname: [u8_t; 64usize],
    pub file: [u8_t; 128usize],
    pub cookie: u32_t,
    pub options: [u8_t; 68usize],
}
#[doc = " For compatibility with BSD code"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: u32_t,
}
#[doc = " Function prototype for raw pcb receive callback functions.\n @param arg user supplied argument (raw_pcb.recv_arg)\n @param pcb the raw_pcb which received data\n @param p the packet buffer that was received\n @param addr the remote IP address from which the packet was received\n @return 1 if the packet was 'eaten' (aka. deleted),\n         0 if the packet lives on\n If returning 1, the callback is responsible for freeing the pbuf\n if it's not used any more."]
pub type raw_recv_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::core::ffi::c_void,
        pcb: *mut raw_pcb,
        p: *mut pbuf,
        addr: *mut ip_addr_t,
    ) -> u8_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raw_pcb {
    pub local_ip: ip_addr_t,
    pub remote_ip: ip_addr_t,
    pub so_options: u8_t,
    pub tos: u8_t,
    pub ttl: u8_t,
    pub next: *mut raw_pcb,
    pub protocol: u8_t,
    #[doc = " receive callback function"]
    pub recv: raw_recv_fn,
    pub recv_arg: *mut ::core::ffi::c_void,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_hdr {
    pub src: u16_t,
    pub dest: u16_t,
    pub seqno: u32_t,
    pub ackno: u32_t,
    pub _hdrlen_rsvd_flags: u16_t,
    pub wnd: u16_t,
    pub chksum: u16_t,
    pub urgp: u16_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_seg {
    pub next: *mut tcp_seg,
    pub p: *mut pbuf,
    pub dataptr: *mut ::core::ffi::c_void,
    pub len: u16_t,
    pub flags: u8_t,
    pub tcphdr: *mut tcp_hdr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tcp_listen_pcbs_t {
    pub listen_pcbs: *mut tcp_pcb_listen,
    pub pcbs: *mut tcp_pcb,
}
pub type sio_fd_t = *mut ::core::ffi::c_void;
#[doc = " Function prototype for a timeout callback function. Register such a function\n using sys_timeout().\n\n @param arg Additional argument to pass to the function - set up by sys_timeout()"]
pub type sys_timeout_handler =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sys_timeo {
    pub next: *mut sys_timeo,
    pub time: u32_t,
    pub h: sys_timeout_handler,
    pub arg: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ringbuf_t {
    pub buf: *mut u8,
    pub head: *mut u8,
    pub tail: *mut u8,
    pub size: usize,
}
pub type ringbuf = ringbuf_t;
pub type ringbuf_t_ptr = *mut ringbuf_t;
pub type espconn_handle = *mut ::core::ffi::c_void;
pub type espconn_connect_callback =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void)>;
pub type espconn_reconnect_callback =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, err: sint8)>;
pub const espconn_type_ESPCONN_INVALID: espconn_type = 0;
pub const espconn_type_ESPCONN_TCP: espconn_type = 16;
pub const espconn_type_ESPCONN_UDP: espconn_type = 32;
#[doc = " Protocol family and type of the espconn"]
pub type espconn_type = ::core::ffi::c_uint;
pub const espconn_state_ESPCONN_NONE: espconn_state = 0;
pub const espconn_state_ESPCONN_WAIT: espconn_state = 1;
pub const espconn_state_ESPCONN_LISTEN: espconn_state = 2;
pub const espconn_state_ESPCONN_CONNECT: espconn_state = 3;
pub const espconn_state_ESPCONN_WRITE: espconn_state = 4;
pub const espconn_state_ESPCONN_READ: espconn_state = 5;
pub const espconn_state_ESPCONN_CLOSE: espconn_state = 6;
#[doc = " Current state of the espconn. Non-TCP espconn are always in state ESPCONN_NONE!"]
pub type espconn_state = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _esp_tcp {
    pub remote_port: ::core::ffi::c_int,
    pub local_port: ::core::ffi::c_int,
    pub local_ip: [uint8; 4usize],
    pub remote_ip: [uint8; 4usize],
    pub connect_callback: espconn_connect_callback,
    pub reconnect_callback: espconn_reconnect_callback,
    pub disconnect_callback: espconn_connect_callback,
    pub write_finish_fn: espconn_connect_callback,
}
pub type esp_tcp = _esp_tcp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _esp_udp {
    pub remote_port: ::core::ffi::c_int,
    pub local_port: ::core::ffi::c_int,
    pub local_ip: [uint8; 4usize],
    pub remote_ip: [uint8; 4usize],
}
pub type esp_udp = _esp_udp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _remot_info {
    pub state: espconn_state,
    pub remote_port: ::core::ffi::c_int,
    pub remote_ip: [uint8; 4usize],
}
pub type remot_info = _remot_info;
#[doc = " A callback prototype to inform about events for a espconn"]
pub type espconn_recv_callback = ::core::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::core::ffi::c_void,
        pdata: *mut ::core::ffi::c_char,
        len: ::core::ffi::c_ushort,
    ),
>;
pub type espconn_sent_callback =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void)>;
#[doc = " A espconn descriptor"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct espconn {
    #[doc = " type of the espconn (TCP, UDP)"]
    pub type_: espconn_type,
    #[doc = " current state of the espconn"]
    pub state: espconn_state,
    pub proto: espconn__bindgen_ty_1,
    #[doc = " A callback function that is informed about events for this espconn"]
    pub recv_callback: espconn_recv_callback,
    pub sent_callback: espconn_sent_callback,
    pub link_cnt: uint8,
    pub reverse: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union espconn__bindgen_ty_1 {
    pub tcp: *mut esp_tcp,
    pub udp: *mut esp_udp,
}
pub const espconn_option_ESPCONN_START: espconn_option = 0;
pub const espconn_option_ESPCONN_REUSEADDR: espconn_option = 1;
pub const espconn_option_ESPCONN_NODELAY: espconn_option = 2;
pub const espconn_option_ESPCONN_COPY: espconn_option = 4;
pub const espconn_option_ESPCONN_KEEPALIVE: espconn_option = 8;
pub const espconn_option_ESPCONN_MANUALRECV: espconn_option = 16;
pub const espconn_option_ESPCONN_END: espconn_option = 17;
pub type espconn_option = ::core::ffi::c_uint;
pub const espconn_level_ESPCONN_KEEPIDLE: espconn_level = 0;
pub const espconn_level_ESPCONN_KEEPINTVL: espconn_level = 1;
pub const espconn_level_ESPCONN_KEEPCNT: espconn_level = 2;
pub type espconn_level = ::core::ffi::c_uint;
pub const espconn_mode_ESPCONN_NOMODE: espconn_mode = 0;
pub const espconn_mode_ESPCONN_TCPSERVER_MODE: espconn_mode = 1;
pub const espconn_mode_ESPCONN_TCPCLIENT_MODE: espconn_mode = 2;
pub const espconn_mode_ESPCONN_UDP_MODE: espconn_mode = 3;
pub const espconn_mode_ESPCONN_NUM_MODE: espconn_mode = 4;
pub type espconn_mode = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct espconn_packet {
    pub sent_length: uint16,
    pub snd_buf_size: uint16,
    pub snd_queuelen: uint16,
    pub total_queuelen: uint16,
    pub packseqno: uint32,
    pub packseq_nxt: uint32,
    pub packnum: uint32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _espconn_buf {
    pub payload: *mut uint8,
    pub punsent: *mut uint8,
    pub unsent: uint16,
    pub len: uint16,
    pub tot_len: uint16,
    pub pnext: *mut _espconn_buf,
}
pub type espconn_buf = _espconn_buf;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _comon_pkt {
    pub pcb: *mut ::core::ffi::c_void,
    pub remote_port: ::core::ffi::c_int,
    pub remote_ip: [uint8; 4usize],
    pub local_port: uint32,
    pub local_ip: uint32,
    pub pbuf: *mut espconn_buf,
    pub ptail: *mut espconn_buf,
    pub ptrbuf: *mut uint8,
    pub cntr: uint16,
    pub err: sint8,
    pub timeout: uint32,
    pub recv_check: uint32,
    pub pbuf_num: uint8,
    pub packet_info: espconn_packet,
    pub write_flag: bool_,
    pub espconn_opt: espconn_option,
}
pub type comon_pkt = _comon_pkt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _espconn_msg {
    pub pespconn: *mut espconn,
    pub pcommon: comon_pkt,
    pub count_opt: uint8,
    pub espconn_mode: uint8,
    pub hs_status: sint16_t,
    pub preverse: *mut ::core::ffi::c_void,
    pub pssl: *mut ::core::ffi::c_void,
    pub pnext: *mut _espconn_msg,
    pub recv_hold_flag: uint8,
    pub recv_holded_buf_Len: uint16,
    pub close_flag: uint8,
    pub readbuf: *mut ringbuf,
}
pub type espconn_msg = _espconn_msg;
pub const espconn_sig_SIG_ESPCONN_NONE: espconn_sig = 0;
pub const espconn_sig_SIG_ESPCONN_ERRER: espconn_sig = 1;
pub const espconn_sig_SIG_ESPCONN_LISTEN: espconn_sig = 2;
pub const espconn_sig_SIG_ESPCONN_CONNECT: espconn_sig = 3;
pub const espconn_sig_SIG_ESPCONN_WRITE: espconn_sig = 4;
pub const espconn_sig_SIG_ESPCONN_SEND: espconn_sig = 5;
pub const espconn_sig_SIG_ESPCONN_READ: espconn_sig = 6;
pub const espconn_sig_SIG_ESPCONN_CLOSE: espconn_sig = 7;
pub type espconn_sig = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dhcps_state {
    pub state: sint16_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dhcps_msg {
    pub op: u8,
    pub htype: u8,
    pub hlen: u8,
    pub hops: u8,
    pub xid: [u8; 4usize],
    pub secs: u16,
    pub flags: u16,
    pub ciaddr: [u8; 4usize],
    pub yiaddr: [u8; 4usize],
    pub siaddr: [u8; 4usize],
    pub giaddr: [u8; 4usize],
    pub chaddr: [u8; 16usize],
    pub sname: [u8; 64usize],
    pub file: [u8; 128usize],
    pub options: [u8; 312usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dhcps_lease {
    pub enable: bool_,
    pub start_ip: ip_addr,
    pub end_ip: ip_addr,
}
pub const dhcps_offer_option_OFFER_START: dhcps_offer_option = 0;
pub const dhcps_offer_option_OFFER_ROUTER: dhcps_offer_option = 1;
pub const dhcps_offer_option_OFFER_END: dhcps_offer_option = 2;
pub type dhcps_offer_option = ::core::ffi::c_uint;
pub const dhcps_type_t_DHCPS_TYPE_DYNAMIC: dhcps_type_t = 0;
pub const dhcps_type_t_DHCPS_TYPE_STATIC: dhcps_type_t = 1;
pub type dhcps_type_t = ::core::ffi::c_uint;
pub const dhcps_state_t_DHCPS_STATE_ONLINE: dhcps_state_t = 0;
pub const dhcps_state_t_DHCPS_STATE_OFFLINE: dhcps_state_t = 1;
pub type dhcps_state_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dhcps_pool {
    pub ip: ip_addr,
    pub mac: [uint8; 6usize],
    pub lease_timer: uint32,
    pub type_: dhcps_type_t,
    pub state: dhcps_state_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _list_node {
    pub pnode: *mut ::core::ffi::c_void,
    pub pnext: *mut _list_node,
}
pub type list_node = _list_node;
pub type ping_recv_function = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, pdata: *mut ::core::ffi::c_void),
>;
pub type ping_sent_function = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, pdata: *mut ::core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ping_option {
    pub count: uint32,
    pub ip: uint32,
    pub coarse_time: uint32,
    pub recv_function: ping_recv_function,
    pub sent_function: ping_sent_function,
    pub reverse: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ping_msg {
    pub ping_opt: *mut ping_option,
    pub ping_pcb: *mut raw_pcb,
    pub ping_start: uint32,
    pub ping_sent: uint32,
    pub timeout_count: uint32,
    pub max_count: uint32,
    pub sent_count: uint32,
    pub coarse_time: uint32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ping_resp {
    pub total_count: uint32,
    pub resp_time: uint32,
    pub seqno: uint32,
    pub timeout_count: uint32,
    pub bytes: uint32,
    pub total_bytes: uint32,
    pub total_time: uint32,
    pub ping_err: sint8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
pub type suseconds_t = __suseconds_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::core::ffi::c_ulong; 16usize],
}
pub type sigset_t = __sigset_t;
pub type __fd_mask = ::core::ffi::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
pub type fd_mask = __fd_mask;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::core::ffi::c_int,
    pub tz_dsttime: ::core::ffi::c_int,
}
pub const __itimer_which_ITIMER_REAL: __itimer_which = 0;
pub const __itimer_which_ITIMER_VIRTUAL: __itimer_which = 1;
pub const __itimer_which_ITIMER_PROF: __itimer_which = 2;
pub type __itimer_which = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
pub type __itimer_which_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
extern "C" {
    pub fn ets_intr_lock();
    pub fn ets_intr_unlock();
    pub fn ets_isr_attach(i: ::core::ffi::c_int, func: ets_isr_t, arg: *mut ::core::ffi::c_void);
    pub fn ets_isr_mask(mask: uint32);
    pub fn ets_isr_unmask(unmask: uint32);
    pub fn NmiTimSetFunc(func: ::core::option::Option<unsafe extern "C" fn()>);
    pub fn memcpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn memmove(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn memccpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn memset(
        __s: *mut ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn memcmp(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
    pub fn __memcmpeq(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: usize,
    ) -> ::core::ffi::c_int;
    pub fn memchr(
        __s: *const ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn strcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
    pub fn strcat(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strncat(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
    pub fn strcmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn strncmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
    pub fn strcoll(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn strxfrm(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
    pub fn strcoll_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __l: locale_t,
    ) -> ::core::ffi::c_int;
    pub fn strxfrm_l(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
    pub fn strdup(__s: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn strndup(
        __string: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
    pub fn strchr(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn strrchr(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn strchrnul(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn strcspn(
        __s: *const ::core::ffi::c_char,
        __reject: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_ulong;
    pub fn strspn(
        __s: *const ::core::ffi::c_char,
        __accept: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_ulong;
    pub fn strpbrk(
        __s: *const ::core::ffi::c_char,
        __accept: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strstr(
        __haystack: *const ::core::ffi::c_char,
        __needle: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strtok(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn __strtok_r(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
        __save_ptr: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strtok_r(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
        __save_ptr: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strcasestr(
        __haystack: *const ::core::ffi::c_char,
        __needle: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn memmem(
        __haystack: *const ::core::ffi::c_void,
        __haystacklen: usize,
        __needle: *const ::core::ffi::c_void,
        __needlelen: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn __mempcpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn mempcpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn strlen(__s: *const ::core::ffi::c_char) -> ::core::ffi::c_ulong;
    pub fn strnlen(__string: *const ::core::ffi::c_char, __maxlen: usize) -> usize;
    pub fn strerror(__errnum: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_char,
        __buflen: usize,
    ) -> ::core::ffi::c_int;
    pub fn strerror_l(__errnum: ::core::ffi::c_int, __l: locale_t) -> *mut ::core::ffi::c_char;
    pub fn bcmp(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
    pub fn bcopy(
        __src: *const ::core::ffi::c_void,
        __dest: *mut ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    );
    pub fn bzero(__s: *mut ::core::ffi::c_void, __n: ::core::ffi::c_ulong);
    pub fn index(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn rindex(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn ffs(__i: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn ffsl(__l: ::core::ffi::c_long) -> ::core::ffi::c_int;
    pub fn ffsll(__ll: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
    pub fn strcasecmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn strncasecmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
    pub fn strcasecmp_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __loc: locale_t,
    ) -> ::core::ffi::c_int;
    pub fn strncasecmp_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::core::ffi::c_int;
    pub fn explicit_bzero(__s: *mut ::core::ffi::c_void, __n: usize);
    pub fn strsep(
        __stringp: *mut *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strsignal(__sig: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
    pub fn __stpcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn stpcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn __stpncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: usize,
    ) -> *mut ::core::ffi::c_char;
    pub fn stpncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
    pub fn strlcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
    pub fn strlcat(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
    pub fn ets_bzero(s: *mut ::core::ffi::c_void, n: usize);
    pub fn ets_delay_us(us: u32);
    pub fn ets_install_putc1(
        p: ::core::option::Option<unsafe extern "C" fn(c: ::core::ffi::c_char)>,
    );
    pub fn ets_memcmp(
        str1: *const ::core::ffi::c_void,
        str2: *const ::core::ffi::c_void,
        nbyte: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
    pub fn ets_memcpy(
        dest: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        nbyte: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub fn ets_memmove(
        dest: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        nbyte: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub fn ets_memset(
        dest: *mut ::core::ffi::c_void,
        val: ::core::ffi::c_int,
        nbyte: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub fn ets_strcmp(
        s1: *const ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn ets_strcpy(
        s1: *mut ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn ets_strlen(s: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn ets_strncmp(
        s1: *const ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
        n: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
    pub fn ets_strncpy(
        s1: *mut ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
        n: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_char;
    pub fn ets_strstr(
        s1: *const ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn ets_timer_arm_new(ptimer: *mut ETSTimer, time: u32, repeat_flag: bool_, ms_flag: bool_);
    pub fn ets_timer_disarm(ptimer: *mut ETSTimer);
    pub fn ets_timer_setfn(
        ptimer: *mut ETSTimer,
        pfunction: ETSTimerFunc,
        parg: *mut ::core::ffi::c_void,
    );
    pub fn ets_sprintf(
        str_: *mut ::core::ffi::c_char,
        format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn os_printf_plus(format: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn ets_snprintf(
        str_: *mut ::core::ffi::c_char,
        size: ::core::ffi::c_uint,
        format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn os_random() -> ::core::ffi::c_ulong;
    pub fn os_get_random(buf: *mut ::core::ffi::c_uchar, len: usize) -> ::core::ffi::c_int;
    pub static mut memp_memory_RAW_PCB_base: [u8_t; 0usize];
    pub static mut memp_memory_UDP_PCB_base: [u8_t; 0usize];
    pub static mut memp_memory_TCP_PCB_base: [u8_t; 0usize];
    pub static mut memp_memory_TCP_PCB_LISTEN_base: [u8_t; 0usize];
    pub static mut memp_memory_TCP_SEG_base: [u8_t; 0usize];
    pub static mut memp_memory_SYS_TIMEOUT_base: [u8_t; 0usize];
    pub static mut memp_memory_PBUF_base: [u8_t; 0usize];
    pub static mut memp_memory_PBUF_POOL_base: [u8_t; 0usize];
    pub fn pbuf_alloc(l: pbuf_layer, length: u16_t, type_: pbuf_type) -> *mut pbuf;
    pub fn pbuf_realloc(p: *mut pbuf, size: u16_t);
    pub fn pbuf_header(p: *mut pbuf, header_size: s16_t) -> u8_t;
    pub fn pbuf_ref(p: *mut pbuf);
    pub fn pbuf_free(p: *mut pbuf) -> u8_t;
    pub fn pbuf_clen(p: *mut pbuf) -> u8_t;
    pub fn pbuf_cat(head: *mut pbuf, tail: *mut pbuf);
    pub fn pbuf_chain(head: *mut pbuf, tail: *mut pbuf);
    pub fn pbuf_dechain(p: *mut pbuf) -> *mut pbuf;
    pub fn pbuf_copy(p_to: *mut pbuf, p_from: *mut pbuf) -> err_t;
    pub fn pbuf_copy_partial(
        p: *mut pbuf,
        dataptr: *mut ::core::ffi::c_void,
        len: u16_t,
        offset: u16_t,
    ) -> u16_t;
    pub fn pbuf_take(buf: *mut pbuf, dataptr: *const ::core::ffi::c_void, len: u16_t) -> err_t;
    pub fn pbuf_coalesce(p: *mut pbuf, layer: pbuf_layer) -> *mut pbuf;
    pub fn pbuf_get_at(p: *mut pbuf, offset: u16_t) -> u8_t;
    pub fn pbuf_memcmp(
        p: *mut pbuf,
        offset: u16_t,
        s2: *const ::core::ffi::c_void,
        n: u16_t,
    ) -> u16_t;
    pub fn pbuf_memfind(
        p: *mut pbuf,
        mem: *const ::core::ffi::c_void,
        mem_len: u16_t,
        start_offset: u16_t,
    ) -> u16_t;
    pub fn pbuf_strstr(p: *mut pbuf, substr: *const ::core::ffi::c_char) -> u16_t;
    pub static ip_addr_any: ip_addr_t;
    pub static ip_addr_broadcast: ip_addr_t;
    pub fn ip4_addr_isbroadcast(addr: u32_t, netif: *const netif) -> u8_t;
    pub fn ip4_addr_netmask_valid(netmask: u32_t) -> u8_t;
    pub fn ipaddr_addr(cp: *const ::core::ffi::c_char) -> u32_t;
    pub fn ipaddr_aton(cp: *const ::core::ffi::c_char, addr: *mut ip_addr_t) -> ::core::ffi::c_int;
    #[doc = " returns ptr to static buffer; not reentrant!"]
    pub fn ipaddr_ntoa(addr: *const ip_addr_t) -> *mut ::core::ffi::c_char;
    pub fn ipaddr_ntoa_r(
        addr: *const ip_addr_t,
        buf: *mut ::core::ffi::c_char,
        buflen: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    #[doc = " The list of network interfaces."]
    pub static mut netif_list: *mut netif;
    #[doc = " The default network interface."]
    pub static mut netif_default: *mut netif;
    pub fn netif_init();
    pub fn netif_add(
        netif: *mut netif,
        ipaddr: *mut ip_addr_t,
        netmask: *mut ip_addr_t,
        gw: *mut ip_addr_t,
        state: *mut ::core::ffi::c_void,
        init: netif_init_fn,
        input: netif_input_fn,
    ) -> *mut netif;
    pub fn netif_set_addr(
        netif: *mut netif,
        ipaddr: *mut ip_addr_t,
        netmask: *mut ip_addr_t,
        gw: *mut ip_addr_t,
    );
    pub fn netif_remove(netif: *mut netif);
    pub fn netif_find(name: *mut ::core::ffi::c_char) -> *mut netif;
    pub fn netif_set_default(netif: *mut netif);
    pub fn netif_set_ipaddr(netif: *mut netif, ipaddr: *mut ip_addr_t);
    pub fn netif_set_netmask(netif: *mut netif, netmask: *mut ip_addr_t);
    pub fn netif_set_gw(netif: *mut netif, gw: *mut ip_addr_t);
    pub fn netif_set_up(netif: *mut netif);
    pub fn netif_set_down(netif: *mut netif);
    pub fn netif_set_link_up(netif: *mut netif);
    pub fn netif_set_link_down(netif: *mut netif);
    #[doc = " The interface that provided the packet for the current callback invocation."]
    pub static mut current_netif: *mut netif;
    #[doc = " Header of the input packet currently being processed."]
    pub static mut current_header: *const ip_hdr;
    #[doc = " Source IP address of current_header"]
    pub static mut current_iphdr_src: ip_addr_t;
    #[doc = " Destination IP address of current_header"]
    pub static mut current_iphdr_dest: ip_addr_t;
    pub fn ip_route(dest: *mut ip_addr_t) -> *mut netif;
    pub fn ip_router(dest: *mut ip_addr_t, source: *mut ip_addr_t) -> *mut netif;
    pub fn ip_input(p: *mut pbuf, inp: *mut netif) -> err_t;
    pub fn ip_output(
        p: *mut pbuf,
        src: *mut ip_addr_t,
        dest: *mut ip_addr_t,
        ttl: u8_t,
        tos: u8_t,
        proto: u8_t,
    ) -> err_t;
    pub fn ip_output_if(
        p: *mut pbuf,
        src: *mut ip_addr_t,
        dest: *mut ip_addr_t,
        ttl: u8_t,
        tos: u8_t,
        proto: u8_t,
        netif: *mut netif,
    ) -> err_t;
    pub fn ip_output_if_opt(
        p: *mut pbuf,
        src: *mut ip_addr_t,
        dest: *mut ip_addr_t,
        ttl: u8_t,
        tos: u8_t,
        proto: u8_t,
        netif: *mut netif,
        ip_options: *mut ::core::ffi::c_void,
        optlen: u16_t,
    ) -> err_t;
    pub fn pvPortMalloc(
        sz: usize,
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
        arg3: bool_,
    ) -> *mut ::core::ffi::c_void;
    pub fn vPortFree(
        p: *mut ::core::ffi::c_void,
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
    );
    pub fn pvPortZalloc(
        sz: usize,
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub fn pvPortRealloc(
        p: *mut ::core::ffi::c_void,
        n: usize,
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub fn pvPortCalloc(
        count: usize,
        size: usize,
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub fn pvPortCallocIram(
        count: usize,
        size: usize,
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub fn pvPortZallocIram(
        sz: usize,
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub static memp_sizes: [u32_t; 10usize];
    pub fn sys_init();
    #[doc = " Ticks/jiffies since power up."]
    pub fn sys_jiffies() -> u32_t;
    pub fn icmp_input(p: *mut pbuf, inp: *mut netif);
    pub fn icmp_dest_unreach(p: *mut pbuf, t: icmp_dur_type);
    pub fn icmp_time_exceeded(p: *mut pbuf, t: icmp_te_type);
    pub fn tcp_new() -> *mut tcp_pcb;
    pub fn tcp_arg(pcb: *mut tcp_pcb, arg: *mut ::core::ffi::c_void);
    pub fn tcp_accept(pcb: *mut tcp_pcb, accept: tcp_accept_fn);
    pub fn tcp_recv(pcb: *mut tcp_pcb, recv: tcp_recv_fn);
    pub fn tcp_sent(pcb: *mut tcp_pcb, sent: tcp_sent_fn);
    pub fn tcp_poll(pcb: *mut tcp_pcb, poll: tcp_poll_fn, interval: u8_t);
    pub fn tcp_err(pcb: *mut tcp_pcb, err: tcp_err_fn);
    pub fn tcp_recved(pcb: *mut tcp_pcb, len: u16_t);
    pub fn tcp_bind(pcb: *mut tcp_pcb, ipaddr: *mut ip_addr_t, port: u16_t) -> err_t;
    pub fn tcp_connect(
        pcb: *mut tcp_pcb,
        ipaddr: *mut ip_addr_t,
        port: u16_t,
        connected: tcp_connected_fn,
    ) -> err_t;
    pub fn tcp_listen_with_backlog(pcb: *mut tcp_pcb, backlog: u8_t) -> *mut tcp_pcb;
    pub fn tcp_abort(pcb: *mut tcp_pcb);
    pub fn tcp_close(pcb: *mut tcp_pcb) -> err_t;
    pub fn tcp_shutdown(
        pcb: *mut tcp_pcb,
        shut_rx: ::core::ffi::c_int,
        shut_tx: ::core::ffi::c_int,
    ) -> err_t;
    pub fn tcp_write(
        pcb: *mut tcp_pcb,
        dataptr: *const ::core::ffi::c_void,
        len: u16_t,
        apiflags: u8_t,
    ) -> err_t;
    pub fn tcp_setprio(pcb: *mut tcp_pcb, prio: u8_t);
    pub fn tcp_output(pcb: *mut tcp_pcb) -> err_t;
    pub fn tcp_debug_state_str(s: tcp_state) -> *const ::core::ffi::c_char;
    pub fn dns_init();
    pub fn dns_tmr();
    pub fn dns_setserver(numdns: u8_t, dnsserver: *mut ip_addr_t);
    pub fn dns_getserver(numdns: u8_t) -> ip_addr_t;
    pub fn dns_gethostbyname(
        hostname: *const ::core::ffi::c_char,
        addr: *mut ip_addr_t,
        found: dns_found_callback,
        callback_arg: *mut ::core::ffi::c_void,
    ) -> err_t;
    pub static mut PUCK_SERVICE: *mut ::core::ffi::c_char;
    pub fn mdns_enable();
    pub fn mdns_disable();
    pub fn mdns_init(info: *mut mdns_info);
    pub fn mdns_close();
    pub fn mdns_get_hostname() -> *mut ::core::ffi::c_char;
    pub fn mdns_set_hostname(name: *mut ::core::ffi::c_char);
    pub fn mdns_set_servername(name: *const ::core::ffi::c_char);
    pub fn mdns_get_servername() -> *mut ::core::ffi::c_char;
    pub fn mdns_server_unregister();
    pub fn mdns_server_register();
    pub fn mdns_tmr();
    pub fn Delay(ulSeconds: ::core::ffi::c_ulong);
    pub fn lwip_init();
    pub fn igmp_init();
    pub fn igmp_start(netif: *mut netif) -> err_t;
    pub fn igmp_stop(netif: *mut netif) -> err_t;
    pub fn igmp_report_groups(netif: *mut netif);
    pub fn igmp_lookfor_group(ifp: *mut netif, addr: *mut ip_addr_t) -> *mut igmp_group;
    pub fn igmp_input(p: *mut pbuf, inp: *mut netif, dest: *mut ip_addr_t);
    pub fn igmp_joingroup(ifaddr: *mut ip_addr_t, groupaddr: *mut ip_addr_t) -> err_t;
    pub fn igmp_leavegroup(ifaddr: *mut ip_addr_t, groupaddr: *mut ip_addr_t) -> err_t;
    pub fn igmp_tmr();
    pub fn r_rand() -> ::core::ffi::c_int;
    pub fn inet_chksum(dataptr: *mut ::core::ffi::c_void, len: u16_t) -> u16_t;
    pub fn inet_chksum_pbuf(p: *mut pbuf) -> u16_t;
    pub fn inet_chksum_pseudo(
        p: *mut pbuf,
        src: *mut ip_addr_t,
        dest: *mut ip_addr_t,
        proto: u8_t,
        proto_len: u16_t,
    ) -> u16_t;
    pub fn inet_chksum_pseudo_partial(
        p: *mut pbuf,
        src: *mut ip_addr_t,
        dest: *mut ip_addr_t,
        proto: u8_t,
        proto_len: u16_t,
        chksum_len: u16_t,
    ) -> u16_t;
    pub fn clock() -> clock_t;
    pub fn time(__timer: *mut time_t) -> time_t;
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
    pub fn mktime(__tp: *mut tm) -> time_t;
    pub fn strftime(
        __s: *mut ::core::ffi::c_char,
        __maxsize: usize,
        __format: *const ::core::ffi::c_char,
        __tp: *const tm,
    ) -> usize;
    pub fn strftime_l(
        __s: *mut ::core::ffi::c_char,
        __maxsize: usize,
        __format: *const ::core::ffi::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
    pub fn localtime(__timer: *const time_t) -> *mut tm;
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
    pub fn asctime(__tp: *const tm) -> *mut ::core::ffi::c_char;
    pub fn ctime(__timer: *const time_t) -> *mut ::core::ffi::c_char;
    pub fn asctime_r(__tp: *const tm, __buf: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub static mut __tzname: [*mut ::core::ffi::c_char; 2usize];
    pub static mut __daylight: ::core::ffi::c_int;
    pub static mut __timezone: ::core::ffi::c_long;
    pub static mut tzname: [*mut ::core::ffi::c_char; 2usize];
    pub fn tzset();
    pub static mut daylight: ::core::ffi::c_int;
    pub static mut timezone: ::core::ffi::c_long;
    pub fn timegm(__tp: *mut tm) -> time_t;
    pub fn timelocal(__tp: *mut tm) -> time_t;
    pub fn dysize(__year: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::core::ffi::c_int;
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::core::ffi::c_int;
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::core::ffi::c_int;
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::core::ffi::c_int;
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::core::ffi::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::core::ffi::c_int;
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::core::ffi::c_int;
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::core::ffi::c_int;
    pub fn timer_delete(__timerid: timer_t) -> ::core::ffi::c_int;
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::core::ffi::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::core::ffi::c_int;
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::core::ffi::c_int;
    pub fn timer_getoverrun(__timerid: timer_t) -> ::core::ffi::c_int;
    pub fn timespec_get(__ts: *mut timespec, __base: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn sntp_get_timetype() -> bool_;
    pub fn sntp_set_receive_time_size();
    #[doc = " One server address/name can be defined as default if SNTP_SERVER_DNS == 1:\n #define SNTP_SERVER_ADDRESS \"pool.ntp.org\""]
    pub fn sntp_get_current_timestamp() -> uint64;
    pub fn sntp_get_real_time(t: ::core::ffi::c_long) -> *mut ::core::ffi::c_char;
    pub fn sntp_init();
    pub fn sntp_stop();
    pub fn sntp_get_timezone() -> sint8;
    pub fn sntp_set_timezone(timezone: sint8) -> bool_;
    pub fn sntp_setserver(idx: u8_t, addr: *mut ip_addr_t);
    pub fn sntp_getserver(idx: u8_t) -> ip_addr_t;
    pub fn sntp_setservername(idx: u8_t, server: *mut ::core::ffi::c_char);
    pub fn sntp_getservername(idx: u8_t) -> *mut ::core::ffi::c_char;
    pub fn netbuf_new() -> *mut netbuf;
    pub fn netbuf_delete(buf: *mut netbuf);
    pub fn netbuf_alloc(buf: *mut netbuf, size: u16_t) -> *mut ::core::ffi::c_void;
    pub fn netbuf_free(buf: *mut netbuf);
    pub fn netbuf_ref(buf: *mut netbuf, dataptr: *const ::core::ffi::c_void, size: u16_t) -> err_t;
    pub fn netbuf_chain(head: *mut netbuf, tail: *mut netbuf);
    pub fn netbuf_data(
        buf: *mut netbuf,
        dataptr: *mut *mut ::core::ffi::c_void,
        len: *mut u16_t,
    ) -> err_t;
    pub fn netbuf_next(buf: *mut netbuf) -> s8_t;
    pub fn netbuf_first(buf: *mut netbuf);
    pub static mut udp_pcbs: *mut udp_pcb;
    pub fn udp_new() -> *mut udp_pcb;
    pub fn udp_remove(pcb: *mut udp_pcb);
    pub fn udp_bind(pcb: *mut udp_pcb, ipaddr: *mut ip_addr_t, port: u16_t) -> err_t;
    pub fn udp_connect(pcb: *mut udp_pcb, ipaddr: *mut ip_addr_t, port: u16_t) -> err_t;
    pub fn udp_disconnect(pcb: *mut udp_pcb);
    pub fn udp_recv(pcb: *mut udp_pcb, recv: udp_recv_fn, recv_arg: *mut ::core::ffi::c_void);
    pub fn udp_sendto_if(
        pcb: *mut udp_pcb,
        p: *mut pbuf,
        dst_ip: *mut ip_addr_t,
        dst_port: u16_t,
        netif: *mut netif,
    ) -> err_t;
    pub fn udp_sendto(
        pcb: *mut udp_pcb,
        p: *mut pbuf,
        dst_ip: *mut ip_addr_t,
        dst_port: u16_t,
    ) -> err_t;
    pub fn udp_send(pcb: *mut udp_pcb, p: *mut pbuf) -> err_t;
    pub fn udp_input(p: *mut pbuf, inp: *mut netif);
    pub fn dhcp_set_struct(netif: *mut netif, dhcp: *mut dhcp);
    pub fn dhcp_cleanup(netif: *mut netif);
    #[doc = " start DHCP configuration"]
    pub fn dhcp_start(netif: *mut netif) -> err_t;
    #[doc = " enforce early lease renewal (not needed normally)"]
    pub fn dhcp_renew(netif: *mut netif) -> err_t;
    #[doc = " release the DHCP lease, usually called before dhcp_stop()"]
    pub fn dhcp_release(netif: *mut netif) -> err_t;
    #[doc = " stop DHCP configuration"]
    pub fn dhcp_stop(netif: *mut netif);
    #[doc = " inform server of our manual IP address"]
    pub fn dhcp_inform(netif: *mut netif);
    #[doc = " Handle a possible change in the network configuration"]
    pub fn dhcp_network_changed(netif: *mut netif);
    pub fn dhcp_set_vendor_class_identifier(len: u8, str_: *mut ::core::ffi::c_char) -> err_t;
    pub fn dhcp_arp_reply(netif: *mut netif, addr: *mut ip_addr_t);
    #[doc = " to be called every minute"]
    pub fn dhcp_coarse_tmr();
    #[doc = " to be called every half second"]
    pub fn dhcp_fine_tmr();
    pub fn raw_new(proto: u8_t) -> *mut raw_pcb;
    pub fn raw_remove(pcb: *mut raw_pcb);
    pub fn raw_bind(pcb: *mut raw_pcb, ipaddr: *mut ip_addr_t) -> err_t;
    pub fn raw_connect(pcb: *mut raw_pcb, ipaddr: *mut ip_addr_t) -> err_t;
    pub fn raw_recv(pcb: *mut raw_pcb, recv: raw_recv_fn, recv_arg: *mut ::core::ffi::c_void);
    pub fn raw_sendto(pcb: *mut raw_pcb, p: *mut pbuf, ipaddr: *mut ip_addr_t) -> err_t;
    pub fn raw_send(pcb: *mut raw_pcb, p: *mut pbuf) -> err_t;
    pub fn raw_input(p: *mut pbuf, inp: *mut netif) -> u8_t;
    pub fn tcp_tmr();
    pub fn tcp_slowtmr();
    pub fn tcp_fasttmr();
    pub fn tcp_input(p: *mut pbuf, inp: *mut netif);
    pub fn tcp_alloc(prio: u8_t) -> *mut tcp_pcb;
    pub fn tcp_abandon(pcb: *mut tcp_pcb, reset: ::core::ffi::c_int);
    pub fn tcp_send_empty_ack(pcb: *mut tcp_pcb) -> err_t;
    pub fn tcp_rexmit(pcb: *mut tcp_pcb);
    pub fn tcp_rexmit_rto(pcb: *mut tcp_pcb);
    pub fn tcp_rexmit_fast(pcb: *mut tcp_pcb);
    pub fn tcp_update_rcv_ann_wnd(pcb: *mut tcp_pcb) -> u32_t;
    pub static mut tcp_input_pcb: *mut tcp_pcb;
    pub static mut tcp_ticks: u32_t;
    pub static mut tcp_bound_pcbs: *mut tcp_pcb;
    pub static mut tcp_listen_pcbs: tcp_listen_pcbs_t;
    pub static mut tcp_active_pcbs: *mut tcp_pcb;
    pub static mut tcp_tw_pcbs: *mut tcp_pcb;
    pub static mut tcp_tmp_pcb: *mut tcp_pcb;
    pub fn tcp_pcb_copy(pcb: *mut tcp_pcb) -> *mut tcp_pcb;
    pub fn tcp_pcb_purge(pcb: *mut tcp_pcb);
    pub fn tcp_pcb_remove(pcblist: *mut *mut tcp_pcb, pcb: *mut tcp_pcb);
    pub fn tcp_segs_free(seg: *mut tcp_seg);
    pub fn tcp_seg_free(seg: *mut tcp_seg);
    pub fn tcp_seg_copy(seg: *mut tcp_seg) -> *mut tcp_seg;
    pub fn tcp_send_fin(pcb: *mut tcp_pcb) -> err_t;
    pub fn tcp_enqueue_flags(pcb: *mut tcp_pcb, flags: u8_t) -> err_t;
    pub fn tcp_rexmit_seg(pcb: *mut tcp_pcb, seg: *mut tcp_seg);
    pub fn tcp_rst(
        seqno: u32_t,
        ackno: u32_t,
        local_ip: *mut ip_addr_t,
        remote_ip: *mut ip_addr_t,
        local_port: u16_t,
        remote_port: u16_t,
    );
    pub fn tcp_next_iss() -> u32_t;
    pub fn tcp_keepalive(pcb: *mut tcp_pcb);
    pub fn tcp_zero_window_probe(pcb: *mut tcp_pcb);
    pub fn tcp_eff_send_mss(sendmss: u16_t, addr: *mut ip_addr_t) -> u16_t;
    pub fn tcp_recv_null(
        arg: *mut ::core::ffi::c_void,
        pcb: *mut tcp_pcb,
        p: *mut pbuf,
        err: err_t,
    ) -> err_t;
    #[doc = " External function (implemented in timers.c), called when TCP detects\n that a timer is needed (i.e. active- or time-wait-pcb found)."]
    pub fn tcp_timer_needed();
    #[doc = " Opens a serial device for communication.\n\n @param devnum device number\n @return handle to serial device if successful, NULL otherwise"]
    pub fn sio_open(devnum: u8_t) -> sio_fd_t;
    #[doc = " Sends a single character to the serial device.\n\n @param c character to send\n @param fd serial device handle\n\n @note This function will block until the character can be sent."]
    pub fn sio_send(c: u8_t, fd: sio_fd_t);
    #[doc = " Receives a single character from the serial device.\n\n @param fd serial device handle\n\n @note This function will block until a character is received."]
    pub fn sio_recv(fd: sio_fd_t) -> u8_t;
    #[doc = " Reads from the serial device.\n\n @param fd serial device handle\n @param data pointer to data buffer for receiving\n @param len maximum length (in bytes) of data to receive\n @return number of bytes actually received - may be 0 if aborted by sio_read_abort\n\n @note This function will block until data can be received. The blocking\n can be cancelled by calling sio_read_abort()."]
    pub fn sio_read(fd: sio_fd_t, data: *mut u8_t, len: u32_t) -> u32_t;
    #[doc = " Tries to read from the serial device. Same as sio_read but returns\n immediately if no data is available and never blocks.\n\n @param fd serial device handle\n @param data pointer to data buffer for receiving\n @param len maximum length (in bytes) of data to receive\n @return number of bytes actually received"]
    pub fn sio_tryread(fd: sio_fd_t, data: *mut u8_t, len: u32_t) -> u32_t;
    #[doc = " Writes to the serial device.\n\n @param fd serial device handle\n @param data pointer to data to send\n @param len length (in bytes) of data to send\n @return number of bytes actually sent\n\n @note This function will block until all data can be sent."]
    pub fn sio_write(fd: sio_fd_t, data: *mut u8_t, len: u32_t) -> u32_t;
    #[doc = " Aborts a blocking sio_read() call.\n\n @param fd serial device handle"]
    pub fn sio_read_abort(fd: sio_fd_t);
    pub fn sys_timeouts_init();
    pub fn sys_timeout(msecs: u32_t, handler: sys_timeout_handler, arg: *mut ::core::ffi::c_void);
    pub fn sys_untimeout(handler: sys_timeout_handler, arg: *mut ::core::ffi::c_void);
    pub fn sys_check_timeouts();
    pub fn sys_restart_timeouts();
    pub fn ringbuf_new(capacity: usize) -> ringbuf_t_ptr;
    pub fn ringbuf_buffer_size(rb: *const ringbuf_t) -> usize;
    pub fn ringbuf_reset(rb: ringbuf_t_ptr);
    pub fn ringbuf_free(rb: *mut ringbuf_t_ptr);
    pub fn ringbuf_capacity(rb: *const ringbuf_t) -> usize;
    pub fn ringbuf_bytes_free(rb: *const ringbuf_t) -> usize;
    pub fn ringbuf_bytes_used(rb: *const ringbuf_t) -> usize;
    pub fn ringbuf_is_full(rb: *const ringbuf_t) -> ::core::ffi::c_int;
    pub fn ringbuf_is_empty(rb: *const ringbuf_t) -> ::core::ffi::c_int;
    pub fn ringbuf_tail(rb: *const ringbuf_t) -> *const ::core::ffi::c_void;
    pub fn ringbuf_head(rb: *const ringbuf_t) -> *const ::core::ffi::c_void;
    pub fn ringbuf_findchr(rb: *const ringbuf_t, c: ::core::ffi::c_int, offset: usize) -> usize;
    pub fn ringbuf_memset(dst: ringbuf_t_ptr, c: ::core::ffi::c_int, len: usize) -> usize;
    pub fn ringbuf_memcpy_into(
        dst: ringbuf_t_ptr,
        src: *const ::core::ffi::c_void,
        count: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn ringbuf_memcpy_from(
        dst: *mut ::core::ffi::c_void,
        src: ringbuf_t_ptr,
        count: usize,
    ) -> *mut ::core::ffi::c_void;
    #[doc = " FunctionName : espconn_copy_partial\n Description  : reconnect with host\n Parameters   : arg -- Additional argument to pass to the callback function\n Returns      : none"]
    pub fn espconn_copy_partial(pesp_dest: *mut espconn, pesp_source: *mut espconn);
    #[doc = " FunctionName : espconn_copy_partial\n Description  : insert the node to the active connection list\n Parameters   : arg -- Additional argument to pass to the callback function\n Returns      : none"]
    pub fn espconn_list_creat(phead: *mut *mut espconn_msg, pinsert: *mut espconn_msg);
    #[doc = " FunctionName : espconn_list_delete\n Description  : remove the node from the active connection list\n Parameters   : arg -- Additional argument to pass to the callback function\n Returns      : none"]
    pub fn espconn_list_delete(phead: *mut *mut espconn_msg, pdelete: *mut espconn_msg);
    #[doc = " FunctionName : espconn_find_connection\n Description  : Initialize the server: set up a listening PCB and bind it to\n                the defined port\n Parameters   : espconn -- the espconn used to build server\n Returns      : none"]
    pub fn espconn_find_connection(pespconn: *mut espconn, pnode: *mut *mut espconn_msg) -> bool_;
    #[doc = " FunctionName : espconn_get_connection_info\n Description  : used to specify the function that should be called when disconnect\n Parameters   : espconn -- espconn to set the err callback\n                discon_cb -- err callback function to call when err\n Returns      : none"]
    pub fn espconn_get_connection_info(
        pespconn: *mut espconn,
        pcon_info: *mut *mut remot_info,
        typeflags: uint8,
    ) -> sint8;
    #[doc = " FunctionName : espconn_get_packet_info\n Description  : get the packet info with host\n Parameters   : espconn -- the espconn used to disconnect the connection\n \t\t\t\t  infoarg -- the packet info\n Returns      : the errur code"]
    pub fn espconn_get_packet_info(espconn: *mut espconn, infoarg: *mut espconn_packet) -> sint8;
    #[doc = " FunctionName : espconn_connect\n Description  : The function given as the connect\n Parameters   : espconn -- the espconn used to listen the connection\n Returns      : none"]
    pub fn espconn_connect(espconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_disconnect\n Description  : disconnect with host\n Parameters   : espconn -- the espconn used to disconnect the connection\n Returns      : none"]
    pub fn espconn_disconnect(espconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_delete\n Description  : disconnect with host\n Parameters   : espconn -- the espconn used to disconnect the connection\n Returns      : none"]
    pub fn espconn_delete(espconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_accept\n Description  : The function given as the listen\n Parameters   : espconn -- the espconn used to listen the connection\n Returns      : none"]
    pub fn espconn_accept(espconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_create\n Description  : sent data for client or server\n Parameters   : espconn -- espconn to the data transmission\n Returns      : result"]
    pub fn espconn_create(espconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_tcp_get_wnd\n Description  : get the window size of simulatenously active TCP connections\n Parameters   : none\n Returns      : the number of TCP_MSS active TCP connections"]
    pub fn espconn_tcp_get_wnd() -> uint8;
    #[doc = " FunctionName : espconn_tcp_set_max_con\n Description  : set the window size simulatenously active TCP connections\n Parameters   : num -- the number of TCP_MSS\n Returns      : ESPCONN_ARG -- Illegal argument\n \t\t\t\t  ESPCONN_OK  -- No error"]
    pub fn espconn_tcp_set_wnd(num: uint8) -> sint8;
    #[doc = " FunctionName : espconn_tcp_get_max_con\n Description  : get the number of simulatenously active TCP connections\n Parameters   : none\n Returns      : none"]
    pub fn espconn_tcp_get_max_con() -> uint8;
    #[doc = " FunctionName : espconn_tcp_set_max_con\n Description  : set the number of simulatenously active TCP connections\n Parameters   : num -- total number\n Returns      : none"]
    pub fn espconn_tcp_set_max_con(num: uint8) -> sint8;
    #[doc = " FunctionName : espconn_tcp_get_max_retran\n Description  : get the Maximum number of retransmissions of data active TCP connections\n Parameters   : none\n Returns      : the Maximum number of retransmissions"]
    pub fn espconn_tcp_get_max_retran() -> uint8;
    #[doc = " FunctionName : espconn_tcp_set_max_retran\n Description  : set the Maximum number of retransmissions of data active TCP connections\n Parameters   : num -- the Maximum number of retransmissions\n Returns      : result"]
    pub fn espconn_tcp_set_max_retran(num: uint8) -> sint8;
    #[doc = " FunctionName : espconn_tcp_get_max_syn\n Description  : get the Maximum number of retransmissions of SYN segments\n Parameters   : none\n Returns      : the Maximum number of retransmissions"]
    pub fn espconn_tcp_get_max_syn() -> uint8;
    #[doc = " FunctionName : espconn_tcp_set_max_syn\n Description  : set the Maximum number of retransmissions of SYN segments\n Parameters   : num -- the Maximum number of retransmissions\n Returns      : result"]
    pub fn espconn_tcp_set_max_syn(num: uint8) -> sint8;
    #[doc = " FunctionName : espconn_tcp_get_max_con_allow\n Description  : get the count of simulatenously active connections on the server\n Parameters   : espconn -- espconn to get the count\n Returns      : result"]
    pub fn espconn_tcp_get_max_con_allow(espconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_tcp_set_max_con_allow\n Description  : set the count of simulatenously active connections on the server\n Parameters   : espconn -- espconn to set the count\n Returns      : result"]
    pub fn espconn_tcp_set_max_con_allow(espconn: *mut espconn, num: uint8) -> sint8;
    #[doc = " FunctionName : espconn_tcp_set_buf_count\n Description  : set the total number of espconn_buf on the unsent lists\n Parameters   : espconn -- espconn to set the count\n \t\t\t\t  num -- the total number of espconn_buf\n Returns      : result"]
    pub fn espconn_tcp_set_buf_count(espconn: *mut espconn, num: uint8) -> sint8;
    #[doc = " FunctionName : espconn_regist_time\n Description  : used to specify the time that should be called when don't recv data\n Parameters   : espconn -- the espconn used to the connection\n \t\t\t\t  interval -- the timer when don't recv data\n Returns      : none"]
    pub fn espconn_regist_time(espconn: *mut espconn, interval: uint32, type_flag: uint8) -> sint8;
    #[doc = " FunctionName : espconn_regist_sentcb\n Description  : Used to specify the function that should be called when data\n \t\t\t\t  has been successfully delivered to the remote host.\n Parameters   : struct espconn *espconn -- espconn to set the sent callback\n \t\t\t\t  espconn_sent_callback sent_cb -- sent callback function to\n \t\t\t\t  call for this espconn when data is successfully sent\n Returns      : none"]
    pub fn espconn_regist_sentcb(espconn: *mut espconn, sent_cb: espconn_sent_callback) -> sint8;
    #[doc = " FunctionName : espconn_regist_sentcb\n Description  : Used to specify the function that should be called when data\n                has been successfully delivered to the remote host.\n Parameters   : espconn -- espconn to set the sent callback\n                sent_cb -- sent callback function to call for this espconn\n                when data is successfully sent\n Returns      : none"]
    pub fn espconn_regist_write_finish(
        espconn: *mut espconn,
        write_finish_fn: espconn_connect_callback,
    ) -> sint8;
    #[doc = " FunctionName : espconn_sent\n Description  : sent data for client or server\n Parameters   : espconn -- espconn to set for client or server\n \t\t\t\t  psent -- data to send\n                length -- length of data to send\n Returns      : none"]
    pub fn espconn_sent(espconn: *mut espconn, psent: *mut uint8, length: uint16) -> sint8;
    #[doc = " FunctionName : espconn_regist_connectcb\n Description  : used to specify the function that should be called when\n \t\t\t\t  connects to host.\n Parameters   : espconn -- espconn to set the connect callback\n \t\t\t\t  connect_cb -- connected callback function to call when connected\n Returns      : none"]
    pub fn espconn_regist_connectcb(
        espconn: *mut espconn,
        connect_cb: espconn_connect_callback,
    ) -> sint8;
    #[doc = " FunctionName : espconn_regist_recvcb\n Description  : used to specify the function that should be called when recv\n \t\t\t\t  data from host.\n Parameters   : espconn -- espconn to set the recv callback\n \t\t\t\t  recv_cb -- recv callback function to call when recv data\n Returns      : none"]
    pub fn espconn_regist_recvcb(espconn: *mut espconn, recv_cb: espconn_recv_callback) -> sint8;
    #[doc = " FunctionName : espconn_regist_reconcb\n Description  : used to specify the function that should be called when connection\n \t\t\t\t  because of err disconnect.\n Parameters   : espconn -- espconn to set the err callback\n \t\t\t\t  recon_cb -- err callback function to call when err\n Returns      : none"]
    pub fn espconn_regist_reconcb(
        espconn: *mut espconn,
        recon_cb: espconn_reconnect_callback,
    ) -> sint8;
    #[doc = " FunctionName : espconn_regist_disconcb\n Description  : used to specify the function that should be called when disconnect\n Parameters   : espconn -- espconn to set the err callback\n                discon_cb -- err callback function to call when err\n Returns      : none"]
    pub fn espconn_regist_disconcb(
        espconn: *mut espconn,
        discon_cb: espconn_connect_callback,
    ) -> sint8;
    #[doc = " FunctionName : espconn_port\n Description  : access port value for client so that we don't end up bouncing\n                all connections at the same time .\n Parameters   : none\n Returns      : access port value"]
    pub fn espconn_port() -> uint32;
    #[doc = " FunctionName : espconn_set_opt\n Description  : access port value for client so that we don't end up bouncing\n                all connections at the same time .\n Parameters   : none\n Returns      : access port value"]
    pub fn espconn_set_opt(espconn: *mut espconn, opt: uint8) -> sint8;
    #[doc = " FunctionName : espconn_set_keepalive\n Description  : access level value for connection so that we set the value for\n \t\t\t\t  keep alive\n Parameters   : espconn -- the espconn used to set the connection\n \t\t\t\t  level -- the connection's level\n \t\t\t\t  value -- the value of time(s)\n Returns      : access port value"]
    pub fn espconn_set_keepalive(
        espconn: *mut espconn,
        level: uint8,
        optarg: *mut ::core::ffi::c_void,
    ) -> sint8;
    #[doc = " FunctionName : espconn_get_keepalive\n Description  : access level value for connection so that we get the value for\n \t\t\t\t  keep alive\n Parameters   : espconn -- the espconn used to get the connection\n \t\t\t\t  level -- the connection's level\n Returns      : access keep alive value"]
    pub fn espconn_get_keepalive(
        espconn: *mut espconn,
        level: uint8,
        optarg: *mut ::core::ffi::c_void,
    ) -> sint8;
    #[doc = " FunctionName : espconn_gethostbyname\n Description  : Resolve a hostname (string) into an IP address.\n Parameters   : pespconn -- espconn to resolve a hostname\n                hostname -- the hostname that is to be queried\n                addr -- pointer to a ip_addr_t where to store the address if\n                        it is already cached in the dns_table (only valid if\n                        ESPCONN_OK is returned!)\n                found -- a callback function to be called on success, failure\n                         or timeout (only if ERR_INPROGRESS is returned!)\n Returns      : err_t return code\n                - ESPCONN_OK if hostname is a valid IP address string or the host\n                  name is already in the local names table.\n                - ESPCONN_INPROGRESS enqueue a request to be sent to the DNS server\n                  for resolution if no errors are present.\n                - ESPCONN_ARG: dns client not initialized or invalid hostname"]
    pub fn espconn_gethostbyname(
        pespconn: *mut espconn,
        name: *const ::core::ffi::c_char,
        addr: *mut ip_addr_t,
        found: dns_found_callback,
    ) -> err_t;
    #[doc = " FunctionName : espconn_igmp_join\n Description  : join a multicast group\n Parameters   : host_ip -- the ip address of udp server\n \t\t\t\t  multicast_ip -- multicast ip given by user\n Returns      : none"]
    pub fn espconn_igmp_join(host_ip: *mut ip_addr_t, multicast_ip: *mut ip_addr_t) -> sint8;
    #[doc = " FunctionName : espconn_igmp_leave\n Description  : leave a multicast group\n Parameters   : host_ip -- the ip address of udp server\n \t\t\t\t  multicast_ip -- multicast ip given by user\n Returns      : none"]
    pub fn espconn_igmp_leave(host_ip: *mut ip_addr_t, multicast_ip: *mut ip_addr_t) -> sint8;
    #[doc = " FunctionName : espconn_mdns_init\n Description  : register a device with mdns\n Parameters   : ipAddr -- the ip address of device\n \t\t\t\t  hostname -- the hostname of device\n Returns      : none"]
    pub fn espconn_mdns_init(info: *mut mdns_info);
    #[doc = " FunctionName : espconn_mdns_init\n Description  : close mdns socket\n Parameters   : void\n Returns      : none"]
    pub fn espconn_mdns_close();
    #[doc = " FunctionName : mdns_server_register\n Description  : register a server and join a multicast group\n Parameters   : none\n Returns      : none"]
    pub fn espconn_mdns_server_register();
    #[doc = " FunctionName : mdns_server_register\n Description  : unregister server and leave multicast group\n Parameters   : none\n Returns      : none"]
    pub fn espconn_mdns_server_unregister();
    #[doc = " FunctionName : espconn_mdns_get_servername\n Description  : get server name\n Parameters   : none\n Returns      : server name"]
    pub fn espconn_mdns_get_servername() -> *mut ::core::ffi::c_char;
    #[doc = " FunctionName : espconn_mdns_get_servername\n Description  : set server name\n Parameters   : server name\n Returns      : none"]
    pub fn espconn_mdns_set_servername(name: *const ::core::ffi::c_char);
    #[doc = " FunctionName : espconn_mdns_set_hostname\n Description  : set host name\n Parameters   : host name\n Returns      : none"]
    pub fn espconn_mdns_set_hostname(name: *mut ::core::ffi::c_char);
    #[doc = " FunctionName : espconn_mdns_init\n Description  : get host name\n Parameters   : void\n Returns      : hostname"]
    pub fn espconn_mdns_get_hostname() -> *mut ::core::ffi::c_char;
    #[doc = " FunctionName : espconn_mdns_disable\n Description  : join a multicast group\n Parameters   : host_ip -- the ip address of udp server\n \t\t\t\t  multicast_ip -- multicast ip given by user\n Returns      : none"]
    pub fn espconn_mdns_disable();
    #[doc = " FunctionName : espconn_mdns_enable\n Description  : enable mdns\n Parameters   : void\n Returns      : none"]
    pub fn espconn_mdns_enable();
    #[doc = " FunctionName : espconn_dns_setserver\n Description  : Initialize one of the DNS servers.\n Parameters   : numdns -- the index of the DNS server to set must\n \t\t\t\t  be < DNS_MAX_SERVERS = 2\n \t\t\t      dnsserver -- IP address of the DNS server to set\n  Returns     : none"]
    pub fn espconn_dns_setserver(numdns: u8_t, dnsserver: *mut ip_addr_t);
    #[doc = " FunctionName : espconn_dns_getserver\n Description  : get dns server.\n Parameters   : numdns -- the index of the DNS server ,must\n \t\t\t\t  be < DNS_MAX_SERVERS = 2\n  Returns     : dnsserver -- struct ip_addr_t"]
    pub fn espconn_dns_getserver(numdns: u8_t) -> ip_addr_t;
    #[doc = " FunctionName : espconn_udp_client\n Description  : Initialize the client: set up a PCB and bind it to the port\n Parameters   : pespconn -- the espconn used to build client\n Returns      : none"]
    pub fn espconn_udp_client(pespconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_udp_disconnect\n Description  : A new incoming connection has been disconnected.\n Parameters   : espconn -- the espconn used to disconnect with host\n Returns      : none"]
    pub fn espconn_udp_disconnect(pdiscon: *mut espconn_msg);
    #[doc = " FunctionName : espconn_udp_server\n Description  : Initialize the server: set up a PCB and bind it to the port\n Parameters   : pespconn -- the espconn used to build server\n Returns      : none"]
    pub fn espconn_udp_server(espconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_udp_sent\n Description  : sent data for client or server\n Parameters   : void *arg -- client or server to send\n                uint8* psent -- Data to send\n                uint16 length -- Length of data to send\n Returns      : none"]
    pub fn espconn_udp_sent(
        arg: *mut ::core::ffi::c_void,
        psent: *mut uint8,
        length: uint16,
    ) -> err_t;
    #[doc = " FunctionName : espconn_udp_sendto\n Description  : sent data for UDP\n Parameters   : void *arg -- UDP to send\n \t\t\t\t  uint8* psent -- Data to send\n                uint16 length -- Length of data to send\n Returns      : return espconn error code.\n - ESPCONN_OK. Successful. No error occured.\n - ESPCONN_MEM. Out of memory.\n - ESPCONN_RTE. Could not find route to destination address.\n - More errors could be returned by lower protocol layers."]
    pub fn espconn_udp_sendto(
        arg: *mut ::core::ffi::c_void,
        psent: *mut uint8,
        length: uint16,
    ) -> err_t;
    pub fn ets_task() -> ::core::ffi::c_int;
    pub fn ets_post() -> ::core::ffi::c_int;
    #[doc = " FunctionName : espconn_pbuf_delete\n Description  : remove the node from the active connection list\n Parameters   : arg -- Additional argument to pass to the callback function\n Returns      : none"]
    pub fn espconn_pbuf_delete(phead: *mut *mut espconn_buf, pdelete: *mut espconn_buf);
    #[doc = " FunctionName : espconn_tcp_delete\n Description  : delete the server: delete a listening PCB and free it\n Parameters   : pdeletecon -- the espconn used to delete a server\n Returns      : none"]
    pub fn espconn_tcp_delete(pdeletecon: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_tcp_write\n Description  : write the packet which in the active connection's list.\n Parameters   : arg -- the node pointer which reverse the packet\n Returns      : ESPCONN_MEM: memory error\n \t\t\t\t  ESPCONN_OK:have enough space for write packet"]
    pub fn espconn_tcp_write(arg: *mut ::core::ffi::c_void) -> err_t;
    #[doc = " FunctionName : espconn_kill_pcb\n Description  : kill all the TCP block by port\n Parameters   : none\n Returns      : none"]
    pub fn espconn_kill_pcb(port: u16_t);
    #[doc = " FunctionName : espconn_kill_oldest_pcb\n Description  : A oldest incoming connection has been killed.\n Parameters   : none\n Returns      : none"]
    pub fn espconn_kill_oldest_pcb();
    #[doc = " FunctionName : espconn_tcp_disconnect\n Description  : A new incoming connection has been disconnected.\n Parameters   : espconn -- the espconn used to disconnect with host\n Returns      : none"]
    pub fn espconn_tcp_disconnect(pdiscon: *mut espconn_msg, type_: u8_);
    #[doc = " FunctionName : espconn_tcp_client\n Description  : Initialize the client: set up a connect PCB and bind it to\n                the defined port\n Parameters   : espconn -- the espconn used to build client\n Returns      : none"]
    pub fn espconn_tcp_client(espconn: *mut espconn) -> sint8;
    #[doc = " FunctionName : espconn_tcp_server\n Description  : Initialize the server: set up a listening PCB and bind it to\n                the defined port\n Parameters   : espconn -- the espconn used to build server\n Returns      : none"]
    pub fn espconn_tcp_server(espconn: *mut espconn) -> sint8;
    pub static mut dhcps_lease_time: uint32;
    pub fn dhcps_start(info: *mut ip_info);
    pub fn dhcps_stop();
    pub fn ping_start(ping_opt: *mut ping_option) -> bool_;
    pub fn ping_regist_recv(ping_opt: *mut ping_option, ping_recv: ping_recv_function) -> bool_;
    pub fn ping_regist_sent(ping_opt: *mut ping_option, ping_sent: ping_sent_function) -> bool_;
    pub fn system_relative_time(time: uint32) -> uint32;
    pub fn system_get_time() -> ::core::ffi::c_int;
    pub fn select(
        __nfds: ::core::ffi::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::core::ffi::c_int;
    pub fn pselect(
        __nfds: ::core::ffi::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::core::ffi::c_int;
    pub fn gettimeofday(__tv: *mut timeval, __tz: *mut ::core::ffi::c_void) -> ::core::ffi::c_int;
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone) -> ::core::ffi::c_int;
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval) -> ::core::ffi::c_int;
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval) -> ::core::ffi::c_int;
    pub fn setitimer(
        __which: __itimer_which_t,
        __new: *const itimerval,
        __old: *mut itimerval,
    ) -> ::core::ffi::c_int;
    pub fn utimes(__file: *const ::core::ffi::c_char, __tvp: *const timeval) -> ::core::ffi::c_int;
    pub fn lutimes(__file: *const ::core::ffi::c_char, __tvp: *const timeval)
        -> ::core::ffi::c_int;
    pub fn futimes(__fd: ::core::ffi::c_int, __tvp: *const timeval) -> ::core::ffi::c_int;
    pub fn system_update_rtc(t: time_t, us: u32);
    pub fn sntp_get_rtc_time(us: *mut sint32_t) -> time_t;
    pub fn sntp_update_rtc(sec: time_t, us: u32_t) -> ::core::ffi::c_int;
    pub fn updateTime(ms: uint32);
    pub fn configTime(
        timezone: ::core::ffi::c_int,
        daylightOffset: ::core::ffi::c_int,
        server1: *mut ::core::ffi::c_char,
        server2: *mut ::core::ffi::c_char,
        server3: *mut ::core::ffi::c_char,
        enable: bool_,
    ) -> bool_;
    pub fn millis() -> ::core::ffi::c_ulong;
    pub fn micros() -> ::core::ffi::c_ulong;
}
