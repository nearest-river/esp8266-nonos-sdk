/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }
}
pub const REG_SLC_BASE: u32 = 1610615552;
pub const SLC_CONF0: u32 = 1610615552;
pub const SLC_MODE: u32 = 3;
pub const SLC_MODE_S: u32 = 12;
pub const SLC_INT_RAW: u32 = 1610615556;
pub const SLC_INT_STATUS: u32 = 1610615560;
pub const SLC_INT_ENA: u32 = 1610615564;
pub const SLC_FRHOST_BIT_INT_ENA_ALL: u32 = 255;
pub const SLC_INT_CLR: u32 = 1610615568;
pub const SLC_RX_STATUS: u32 = 1610615572;
pub const SLC_RX_FIFO_PUSH: u32 = 1610615576;
pub const SLC_RXFIFO_WDATA: u32 = 511;
pub const SLC_RXFIFO_WDATA_S: u32 = 0;
pub const SLC_TX_STATUS: u32 = 1610615580;
pub const SLC_TX_FIFO_POP: u32 = 1610615584;
pub const SLC_TXFIFO_RDATA: u32 = 2047;
pub const SLC_TXFIFO_RDATA_S: u32 = 0;
pub const SLC_RX_LINK: u32 = 1610615588;
pub const SLC_RXLINK_DESCADDR_MASK: u32 = 1048575;
pub const SLC_RXLINK_ADDR_S: u32 = 0;
pub const SLC_TX_LINK: u32 = 1610615592;
pub const SLC_TXLINK_DESCADDR_MASK: u32 = 1048575;
pub const SLC_TXLINK_ADDR_S: u32 = 0;
pub const SLC_INTVEC_TOHOST: u32 = 1610615596;
pub const SLC_TOHOST_INTVEC: u32 = 255;
pub const SLC_TOHOST_INTVEC_S: u32 = 0;
pub const SLC_TOKEN0: u32 = 1610615600;
pub const SLC_TOKEN0_MASK: u32 = 4095;
pub const SLC_TOKEN0_S: u32 = 16;
pub const SLC_TOKEN0_LOCAL_WDATA_MASK: u32 = 4095;
pub const SLC_TOKEN0_LOCAL_WDATA_S: u32 = 0;
pub const SLC_TOKEN1: u32 = 1610615604;
pub const SLC_TOKEN1_MASK: u32 = 4095;
pub const SLC_TOKEN1_S: u32 = 16;
pub const SLC_TOKEN1_LOCAL_WDATA: u32 = 4095;
pub const SLC_TOKEN1_LOCAL_WDATA_S: u32 = 0;
pub const SLC_CONF1: u32 = 1610615608;
pub const SLC_STATE0: u32 = 1610615612;
pub const SLC_STATE1: u32 = 1610615616;
pub const SLC_BRIDGE_CONF: u32 = 1610615620;
pub const SLC_TX_PUSH_IDLE_NUM: u32 = 65535;
pub const SLC_TX_PUSH_IDLE_NUM_S: u32 = 16;
pub const SLC_FIFO_MAP_ENA: u32 = 15;
pub const SLC_FIFO_MAP_ENA_S: u32 = 8;
pub const SLC_TXEOF_ENA: u32 = 63;
pub const SLC_TXEOF_ENA_S: u32 = 0;
pub const SLC_RX_EOF_DES_ADDR: u32 = 1610615624;
pub const SLC_TX_EOF_DES_ADDR: u32 = 1610615628;
pub const SLC_FROM_HOST_LAST_DESC: u32 = 1610615628;
pub const SLC_TO_HOST_LAST_DESC: u32 = 1610615624;
pub const SLC_RX_EOF_BFR_DES_ADDR: u32 = 1610615632;
pub const SLC_AHB_TEST: u32 = 1610615636;
pub const SLC_AHB_TESTADDR: u32 = 3;
pub const SLC_AHB_TESTADDR_S: u32 = 4;
pub const SLC_AHB_TESTMODE: u32 = 7;
pub const SLC_AHB_TESTMODE_S: u32 = 0;
pub const SLC_SDIO_ST: u32 = 1610615640;
pub const SLC_BUS_ST: u32 = 7;
pub const SLC_BUS_ST_S: u32 = 12;
pub const SLC_FUNC_ST: u32 = 15;
pub const SLC_FUNC_ST_S: u32 = 4;
pub const SLC_CMD_ST: u32 = 7;
pub const SLC_CMD_ST_S: u32 = 0;
pub const SLC_RX_DSCR_CONF: u32 = 1610615644;
pub const SLC_POP_IDLE_CNT: u32 = 65535;
pub const SLC_POP_IDLE_CNT_S: u32 = 0;
pub const SLC_TXLINK_DSCR: u32 = 1610615648;
pub const SLC_TXLINK_DSCR_BF0: u32 = 1610615652;
pub const SLC_TXLINK_DSCR_BF1: u32 = 1610615656;
pub const SLC_RXLINK_DSCR: u32 = 1610615660;
pub const SLC_RXLINK_DSCR_BF0: u32 = 1610615664;
pub const SLC_RXLINK_DSCR_BF1: u32 = 1610615668;
pub const SLC_DATE: u32 = 1610615672;
pub const SLC_ID: u32 = 1610615676;
pub const SLC_HOST_CONF_W0: u32 = 1610615700;
pub const SLC_HOST_CONF_W1: u32 = 1610615704;
pub const SLC_HOST_CONF_W2: u32 = 1610615712;
pub const SLC_HOST_CONF_W3: u32 = 1610615716;
pub const SLC_HOST_CONF_W4: u32 = 1610615720;
pub const SLC_HOST_INTR_ST: u32 = 1610615708;
pub const SLC_HOST_INTR_CLR: u32 = 1610615728;
pub const SLC_HOST_INTR_ENA: u32 = 1610615732;
pub const SLC_HOST_CONF_W5: u32 = 1610615740;
pub const SLC_HOST_INTR_RAW: u32 = 1610615688;
pub const SLC_DATA_ADDR_CLEAR_MASK: i32 = -61441;
pub const SLC_FROM_HOST_ADDR_MASK: u32 = 4096;
pub const SLC_TO_HOST_ADDR_MASK: u32 = 12288;
pub const SLC_TX_DESC_DEBUG_REG: u32 = 1072693292;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const BIT31: u32 = 2147483648;
pub const BIT30: u32 = 1073741824;
pub const BIT29: u32 = 536870912;
pub const BIT28: u32 = 268435456;
pub const BIT27: u32 = 134217728;
pub const BIT26: u32 = 67108864;
pub const BIT25: u32 = 33554432;
pub const BIT24: u32 = 16777216;
pub const BIT23: u32 = 8388608;
pub const BIT22: u32 = 4194304;
pub const BIT21: u32 = 2097152;
pub const BIT20: u32 = 1048576;
pub const BIT19: u32 = 524288;
pub const BIT18: u32 = 262144;
pub const BIT17: u32 = 131072;
pub const BIT16: u32 = 65536;
pub const BIT15: u32 = 32768;
pub const BIT14: u32 = 16384;
pub const BIT13: u32 = 8192;
pub const BIT12: u32 = 4096;
pub const BIT11: u32 = 2048;
pub const BIT10: u32 = 1024;
pub const BIT9: u32 = 512;
pub const BIT8: u32 = 256;
pub const BIT7: u32 = 128;
pub const BIT6: u32 = 64;
pub const BIT5: u32 = 32;
pub const BIT4: u32 = 16;
pub const BIT3: u32 = 8;
pub const BIT2: u32 = 4;
pub const BIT1: u32 = 2;
pub const BIT0: u32 = 1;
pub const APB_CLK_FREQ: u32 = 80000000;
pub const UART_CLK_FREQ: u32 = 80000000;
pub const TIMER_CLK_FREQ: u32 = 312500;
pub const PERIPHS_DPORT_BASEADDR: u32 = 1072693248;
pub const PERIPHS_GPIO_BASEADDR: u32 = 1610613504;
pub const PERIPHS_TIMER_BASEDDR: u32 = 1610614272;
pub const PERIPHS_RTC_BASEADDR: u32 = 1610614528;
pub const PERIPHS_IO_MUX: u32 = 1610614784;
pub const EDGE_INT_ENABLE_REG: u32 = 1072693252;
pub const GPIO_OUT_ADDRESS: u32 = 0;
pub const GPIO_OUT_W1TS_ADDRESS: u32 = 4;
pub const GPIO_OUT_W1TC_ADDRESS: u32 = 8;
pub const GPIO_ENABLE_ADDRESS: u32 = 12;
pub const GPIO_ENABLE_W1TS_ADDRESS: u32 = 16;
pub const GPIO_ENABLE_W1TC_ADDRESS: u32 = 20;
pub const GPIO_OUT_W1TC_DATA_MASK: u32 = 65535;
pub const GPIO_IN_ADDRESS: u32 = 24;
pub const GPIO_STATUS_ADDRESS: u32 = 28;
pub const GPIO_STATUS_W1TS_ADDRESS: u32 = 32;
pub const GPIO_STATUS_W1TC_ADDRESS: u32 = 36;
pub const GPIO_STATUS_INTERRUPT_MASK: u32 = 65535;
pub const GPIO_RTC_CALIB_SYNC: u32 = 1610613612;
pub const RTC_CALIB_START: u32 = 2147483648;
pub const RTC_PERIOD_NUM_MASK: u32 = 1023;
pub const GPIO_RTC_CALIB_VALUE: u32 = 1610613616;
pub const RTC_CALIB_RDY_S: u32 = 31;
pub const RTC_CALIB_VALUE_MASK: u32 = 1048575;
pub const GPIO_PIN0_ADDRESS: u32 = 40;
pub const GPIO_ID_PIN0: u32 = 0;
pub const GPIO_ID_NONE: u32 = 4294967295;
pub const GPIO_PIN_COUNT: u32 = 16;
pub const GPIO_PIN_CONFIG_MSB: u32 = 12;
pub const GPIO_PIN_CONFIG_LSB: u32 = 11;
pub const GPIO_PIN_CONFIG_MASK: u32 = 6144;
pub const GPIO_WAKEUP_ENABLE: u32 = 1;
pub const GPIO_WAKEUP_DISABLE: i32 = -2;
pub const GPIO_PIN_WAKEUP_ENABLE_MSB: u32 = 10;
pub const GPIO_PIN_WAKEUP_ENABLE_LSB: u32 = 10;
pub const GPIO_PIN_WAKEUP_ENABLE_MASK: u32 = 1024;
pub const GPIO_PIN_INT_TYPE_MASK: u32 = 896;
pub const GPIO_PIN_INT_TYPE_MSB: u32 = 9;
pub const GPIO_PIN_INT_TYPE_LSB: u32 = 7;
pub const GPIO_PAD_DRIVER_ENABLE: u32 = 1;
pub const GPIO_PAD_DRIVER_DISABLE: i32 = -2;
pub const GPIO_PIN_PAD_DRIVER_MSB: u32 = 2;
pub const GPIO_PIN_PAD_DRIVER_LSB: u32 = 2;
pub const GPIO_PIN_PAD_DRIVER_MASK: u32 = 4;
pub const GPIO_AS_PIN_SOURCE: u32 = 0;
pub const SIGMA_AS_PIN_SOURCE: i32 = -1;
pub const GPIO_PIN_SOURCE_MSB: u32 = 0;
pub const GPIO_PIN_SOURCE_LSB: u32 = 0;
pub const GPIO_PIN_SOURCE_MASK: u32 = 1;
pub const FRC1_LOAD_ADDRESS: u32 = 0;
pub const FRC1_COUNT_ADDRESS: u32 = 4;
pub const FRC1_CTRL_ADDRESS: u32 = 8;
pub const FRC1_INT_ADDRESS: u32 = 12;
pub const FRC1_INT_CLR_MASK: u32 = 1;
pub const FRC2_COUNT_ADDRESS: u32 = 36;
pub const REG_RTC_BASE: u32 = 1610614528;
pub const RTC_STORE0: u32 = 1610614576;
pub const RTC_STORE1: u32 = 1610614580;
pub const RTC_STORE2: u32 = 1610614584;
pub const RTC_STORE3: u32 = 1610614588;
pub const RTC_GPIO_OUT: u32 = 1610614632;
pub const RTC_GPIO_ENABLE: u32 = 1610614644;
pub const RTC_GPIO_IN_DATA: u32 = 1610614668;
pub const RTC_GPIO_CONF: u32 = 1610614672;
pub const PAD_XPD_DCDC_CONF: u32 = 1610614688;
pub const PERIPHS_IO_MUX_FUNC: u32 = 19;
pub const PERIPHS_IO_MUX_FUNC_S: u32 = 4;
pub const PERIPHS_IO_MUX_PULLUP: u32 = 128;
pub const PERIPHS_IO_MUX_PULLUP2: u32 = 64;
pub const PERIPHS_IO_MUX_SLEEP_PULLUP: u32 = 8;
pub const PERIPHS_IO_MUX_SLEEP_PULLUP2: u32 = 4;
pub const PERIPHS_IO_MUX_SLEEP_OE: u32 = 2;
pub const PERIPHS_IO_MUX_OE: u32 = 1;
pub const PERIPHS_IO_MUX_CONF_U: u32 = 1610614784;
pub const SPI0_CLK_EQU_SYS_CLK: u32 = 256;
pub const SPI1_CLK_EQU_SYS_CLK: u32 = 512;
pub const PERIPHS_IO_MUX_MTDI_U: u32 = 1610614788;
pub const FUNC_GPIO12: u32 = 3;
pub const PERIPHS_IO_MUX_MTCK_U: u32 = 1610614792;
pub const FUNC_GPIO13: u32 = 3;
pub const PERIPHS_IO_MUX_MTMS_U: u32 = 1610614796;
pub const FUNC_GPIO14: u32 = 3;
pub const PERIPHS_IO_MUX_MTDO_U: u32 = 1610614800;
pub const FUNC_GPIO15: u32 = 3;
pub const FUNC_U0RTS: u32 = 4;
pub const PERIPHS_IO_MUX_U0RXD_U: u32 = 1610614804;
pub const FUNC_GPIO3: u32 = 3;
pub const PERIPHS_IO_MUX_U0TXD_U: u32 = 1610614808;
pub const FUNC_U0TXD: u32 = 0;
pub const FUNC_GPIO1: u32 = 3;
pub const PERIPHS_IO_MUX_SD_CLK_U: u32 = 1610614812;
pub const FUNC_SDCLK: u32 = 0;
pub const FUNC_SPICLK: u32 = 1;
pub const PERIPHS_IO_MUX_SD_DATA0_U: u32 = 1610614816;
pub const FUNC_SDDATA0: u32 = 0;
pub const FUNC_SPIQ: u32 = 1;
pub const FUNC_U1TXD: u32 = 4;
pub const PERIPHS_IO_MUX_SD_DATA1_U: u32 = 1610614820;
pub const FUNC_SDDATA1: u32 = 0;
pub const FUNC_SPID: u32 = 1;
pub const FUNC_U1RXD: u32 = 4;
pub const FUNC_SDDATA1_U1RXD: u32 = 7;
pub const PERIPHS_IO_MUX_SD_DATA2_U: u32 = 1610614824;
pub const FUNC_SDDATA2: u32 = 0;
pub const FUNC_SPIHD: u32 = 1;
pub const FUNC_GPIO9: u32 = 3;
pub const PERIPHS_IO_MUX_SD_DATA3_U: u32 = 1610614828;
pub const FUNC_SDDATA3: u32 = 0;
pub const FUNC_SPIWP: u32 = 1;
pub const FUNC_GPIO10: u32 = 3;
pub const PERIPHS_IO_MUX_SD_CMD_U: u32 = 1610614832;
pub const FUNC_SDCMD: u32 = 0;
pub const FUNC_SPICS0: u32 = 1;
pub const PERIPHS_IO_MUX_GPIO0_U: u32 = 1610614836;
pub const FUNC_GPIO0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO2_U: u32 = 1610614840;
pub const FUNC_GPIO2: u32 = 0;
pub const FUNC_U1TXD_BK: u32 = 2;
pub const FUNC_U0TXD_BK: u32 = 4;
pub const PERIPHS_IO_MUX_GPIO4_U: u32 = 1610614844;
pub const FUNC_GPIO4: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO5_U: u32 = 1610614848;
pub const FUNC_GPIO5: u32 = 0;
pub const ETS_SDIO_INUM: u32 = 1;
pub const ETS_SPI_INUM: u32 = 2;
pub const ETS_GPIO_INUM: u32 = 4;
pub const ETS_UART_INUM: u32 = 5;
pub const ETS_UART1_INUM: u32 = 5;
pub const ETS_FRC_TIMER1_INUM: u32 = 9;
pub const UART_RXFIFO_RD_BYTE: u32 = 255;
pub const UART_RXFIFO_RD_BYTE_S: u32 = 0;
pub const UART_CLKDIV_CNT: u32 = 1048575;
pub const UART_CLKDIV_S: u32 = 0;
pub const UART_GLITCH_FILT: u32 = 255;
pub const UART_GLITCH_FILT_S: u32 = 8;
pub const UART_TXFIFO_CNT: u32 = 255;
pub const UART_TXFIFO_CNT_S: u32 = 16;
pub const UART_RXFIFO_CNT: u32 = 255;
pub const UART_RXFIFO_CNT_S: u32 = 0;
pub const UART_STOP_BIT_NUM: u32 = 3;
pub const UART_STOP_BIT_NUM_S: u32 = 4;
pub const UART_BIT_NUM: u32 = 3;
pub const UART_BIT_NUM_S: u32 = 2;
pub const UART_PARITY_EN_M: u32 = 1;
pub const UART_PARITY_EN_S: u32 = 1;
pub const UART_PARITY_M: u32 = 1;
pub const UART_PARITY_S: u32 = 0;
pub const UART_RX_TOUT_THRHD: u32 = 127;
pub const UART_RX_TOUT_THRHD_S: u32 = 24;
pub const UART_RX_FLOW_THRHD: u32 = 127;
pub const UART_RX_FLOW_THRHD_S: u32 = 16;
pub const UART_TXFIFO_EMPTY_THRHD: u32 = 127;
pub const UART_TXFIFO_EMPTY_THRHD_S: u32 = 8;
pub const UART_RXFIFO_FULL_THRHD: u32 = 127;
pub const UART_RXFIFO_FULL_THRHD_S: u32 = 0;
pub const UART_LOWPULSE_MIN_CNT: u32 = 1048575;
pub const UART_LOWPULSE_MIN_CNT_S: u32 = 0;
pub const UART_HIGHPULSE_MIN_CNT: u32 = 1048575;
pub const UART_HIGHPULSE_MIN_CNT_S: u32 = 0;
pub const UART_PULSE_NUM_CNT: u32 = 1023;
pub const UART_PULSE_NUM_CNT_S: u32 = 0;
pub const SPI_FLASH_READ: u32 = 2147483648;
pub const SPI_FLASH_WREN: u32 = 1073741824;
pub const SPI_FLASH_WRDI: u32 = 536870912;
pub const SPI_FLASH_RDID: u32 = 268435456;
pub const SPI_FLASH_RDSR: u32 = 134217728;
pub const SPI_FLASH_WRSR: u32 = 67108864;
pub const SPI_FLASH_PP: u32 = 33554432;
pub const SPI_FLASH_SE: u32 = 16777216;
pub const SPI_FLASH_BE: u32 = 8388608;
pub const SPI_FLASH_CE: u32 = 4194304;
pub const SPI_FLASH_RES: u32 = 1048576;
pub const SPI_CS_HOLD_DELAY: u32 = 15;
pub const SPI_CS_HOLD_DELAY_S: u32 = 28;
pub const SPI_CS_HOLD_DELAY_RES: u32 = 4095;
pub const SPI_CS_HOLD_DELAY_RES_S: u32 = 16;
pub const SPI_CS_DELAY_NUM: u32 = 15;
pub const SPI_CS_DELAY_NUM_S: u32 = 28;
pub const SPI_CS_DELAY_MODE: u32 = 3;
pub const SPI_CS_DELAY_MODE_S: u32 = 26;
pub const SPI_MOSI_DELAY_NUM: u32 = 7;
pub const SPI_MOSI_DELAY_NUM_S: u32 = 23;
pub const SPI_MOSI_DELAY_MODE: u32 = 3;
pub const SPI_MOSI_DELAY_MODE_S: u32 = 21;
pub const SPI_MISO_DELAY_NUM: u32 = 7;
pub const SPI_MISO_DELAY_NUM_S: u32 = 18;
pub const SPI_MISO_DELAY_MODE: u32 = 3;
pub const SPI_MISO_DELAY_MODE_S: u32 = 16;
pub const SPI_CLKDIV_PRE: u32 = 8191;
pub const SPI_CLKDIV_PRE_S: u32 = 18;
pub const SPI_CLKCNT_N: u32 = 63;
pub const SPI_CLKCNT_N_S: u32 = 12;
pub const SPI_CLKCNT_H: u32 = 63;
pub const SPI_CLKCNT_H_S: u32 = 6;
pub const SPI_CLKCNT_L: u32 = 63;
pub const SPI_CLKCNT_L_S: u32 = 0;
pub const SPI_USR_ADDR_BITLEN: u32 = 63;
pub const SPI_USR_ADDR_BITLEN_S: u32 = 26;
pub const SPI_USR_MOSI_BITLEN: u32 = 511;
pub const SPI_USR_MOSI_BITLEN_S: u32 = 17;
pub const SPI_USR_MISO_BITLEN: u32 = 511;
pub const SPI_USR_MISO_BITLEN_S: u32 = 8;
pub const SPI_USR_DUMMY_CYCLELEN: u32 = 255;
pub const SPI_USR_DUMMY_CYCLELEN_S: u32 = 0;
pub const SPI_USR_COMMAND_BITLEN: u32 = 15;
pub const SPI_USR_COMMAND_BITLEN_S: u32 = 28;
pub const SPI_USR_COMMAND_VALUE: u32 = 65535;
pub const SPI_USR_COMMAND_VALUE_S: u32 = 0;
pub const SPI_TRANS_CNT: u32 = 15;
pub const SPI_TRANS_CNT_S: u32 = 23;
pub const SLV_SPI_INT_EN: u32 = 31;
pub const SLV_SPI_INT_EN_S: u32 = 5;
pub const SPI_SLV_STATUS_BITLEN: u32 = 31;
pub const SPI_SLV_STATUS_BITLEN_S: u32 = 27;
pub const SPI_SLV_BUF_BITLEN: u32 = 511;
pub const SPI_SLV_BUF_BITLEN_S: u32 = 16;
pub const SPI_SLV_RD_ADDR_BITLEN: u32 = 63;
pub const SPI_SLV_RD_ADDR_BITLEN_S: u32 = 10;
pub const SPI_SLV_WR_ADDR_BITLEN: u32 = 63;
pub const SPI_SLV_WR_ADDR_BITLEN_S: u32 = 4;
pub const SPI_SLV_WRBUF_DUMMY_CYCLELEN: u32 = 255;
pub const SPI_SLV_WRBUF_DUMMY_CYCLELEN_S: u32 = 24;
pub const SPI_SLV_RDBUF_DUMMY_CYCLELEN: u32 = 255;
pub const SPI_SLV_RDBUF_DUMMY_CYCLELEN_S: u32 = 16;
pub const SPI_SLV_WRSTR_DUMMY_CYCLELEN: u32 = 255;
pub const SPI_SLV_WRSTR_DUMMY_CYCLELEN_S: u32 = 8;
pub const SPI_SLV_RDSTR_DUMMY_CYCLELEN: u32 = 255;
pub const SPI_SLV_RDSTR_DUMMY_CYCLELEN_S: u32 = 0;
pub const SPI_SLV_WRSTA_CMD_VALUE: u32 = 255;
pub const SPI_SLV_WRSTA_CMD_VALUE_S: u32 = 24;
pub const SPI_SLV_RDSTA_CMD_VALUE: u32 = 255;
pub const SPI_SLV_RDSTA_CMD_VALUE_S: u32 = 16;
pub const SPI_SLV_WRBUF_CMD_VALUE: u32 = 255;
pub const SPI_SLV_WRBUF_CMD_VALUE_S: u32 = 8;
pub const SPI_SLV_RDBUF_CMD_VALUE: u32 = 255;
pub const SPI_SLV_RDBUF_CMD_VALUE_S: u32 = 0;
pub const SPI_INT_HOLD_ENA: u32 = 3;
pub const SPI_INT_HOLD_ENA_S: u32 = 0;
pub const MASTER_WRITE_DATA_TO_SLAVE_CMD: u32 = 2;
pub const MASTER_READ_DATA_FROM_SLAVE_CMD: u32 = 3;
pub const MASTER_WRITE_STATUS_TO_SLAVE_CMD: u32 = 1;
pub const MASTER_READ_STATUS_FROM_SLAVE_CMD: u32 = 4;
pub const I2C_MASTER_SDA_MUX: u32 = 1610614840;
pub const I2C_MASTER_SCL_MUX: u32 = 1610614796;
pub const I2C_MASTER_SDA_GPIO: u32 = 2;
pub const I2C_MASTER_SCL_GPIO: u32 = 14;
pub const I2C_MASTER_SDA_FUNC: u32 = 0;
pub const I2C_MASTER_SCL_FUNC: u32 = 3;
pub const UART_TX_BUFFER_SIZE: u32 = 256;
pub const UART_RX_BUFFER_SIZE: u32 = 256;
pub const UART_BUFF_EN: u32 = 0;
pub const UART_SELFTEST: u32 = 0;
pub const UART_HW_RTS: u32 = 0;
pub const UART_HW_CTS: u32 = 0;
pub const UART0: u32 = 0;
pub const UART1: u32 = 1;
pub const UART_FIFO_LEN: u32 = 128;
pub const UART_TX_EMPTY_THRESH_VAL: u32 = 16;
pub const FUNC_UART0_CTS: u32 = 4;
pub const FUNC_U0CTS: u32 = 4;
pub const UART_LINE_INV_MASK: u32 = 33030144;
pub const _STRING_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC23: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_TIME_BITS64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C23_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 40;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const SPI_FLASH_SEC_SIZE: u32 = 4096;
pub const SPI_FLASH_BYTES_LEN: u32 = 24;
pub const IODATA_START_ADDR: u32 = 1;
pub const SPI_BUFF_BYTE_NUM: u32 = 32;
pub const SPI: u32 = 0;
pub const HSPI: u32 = 1;
pub const HOST_INF_SEL: u32 = 1072693288;
pub const FUNC_SPI_CS2: u32 = 1;
pub const FUNC_SPI_CS1: u32 = 1;
pub const reg_cspi_overlap: u32 = 128;
pub const PERIPHS_IO_MUX_BACKUP: u32 = 0;
pub const SPI_USER_BACKUP: u32 = 1;
pub const SPI_CTRL_BACKUP: u32 = 2;
pub const SPI_CLOCK_BACKUP: u32 = 3;
pub const SPI_USER1_BACKUP: u32 = 4;
pub const SPI_USER2_BACKUP: u32 = 5;
pub const SPI_CMD_BACKUP: u32 = 6;
pub const SPI_PIN_BACKUP: u32 = 7;
pub const SPI_SLAVE_BACKUP: u32 = 8;
pub const HSPI_CS_DEV: u32 = 0;
pub const SPI_CS1_DEV: u32 = 1;
pub const SPI_CS2_DEV: u32 = 2;
pub const SPI_CS0_FLASH: u32 = 3;
pub const HSPI_IDLE: u32 = 4;
pub const IPSTR: &[u8; 12] = b"%d.%d.%d.%d\0";
pub const MACSTR: &[u8; 30] = b"%02x:%02x:%02x:%02x:%02x:%02x\0";
pub const UPGRADE_FW_BIN1: u32 = 0;
pub const UPGRADE_FW_BIN2: u32 = 1;
pub const SYS_BOOT_ENHANCE_MODE: u32 = 0;
pub const SYS_BOOT_NORMAL_MODE: u32 = 1;
pub const SYS_BOOT_NORMAL_BIN: u32 = 0;
pub const SYS_BOOT_TEST_BIN: u32 = 1;
pub const SYS_CPU_80MHZ: u32 = 80;
pub const SYS_CPU_160MHZ: u32 = 160;
pub const NULL_MODE: u32 = 0;
pub const STATION_MODE: u32 = 1;
pub const SOFTAP_MODE: u32 = 2;
pub const STATIONAP_MODE: u32 = 3;
pub const STATION_IF: u32 = 0;
pub const SOFTAP_IF: u32 = 1;
pub const FIXED_RATE_MASK_NONE: u32 = 0;
pub const FIXED_RATE_MASK_STA: u32 = 1;
pub const FIXED_RATE_MASK_AP: u32 = 2;
pub const FIXED_RATE_MASK_ALL: u32 = 3;
pub const RC_LIMIT_11B: u32 = 0;
pub const RC_LIMIT_11G: u32 = 1;
pub const RC_LIMIT_11N: u32 = 2;
pub const RC_LIMIT_P2P_11G: u32 = 3;
pub const RC_LIMIT_P2P_11N: u32 = 4;
pub const RC_LIMIT_NUM: u32 = 5;
pub const LIMIT_RATE_MASK_NONE: u32 = 0;
pub const LIMIT_RATE_MASK_STA: u32 = 1;
pub const LIMIT_RATE_MASK_AP: u32 = 2;
pub const LIMIT_RATE_MASK_ALL: u32 = 3;
pub const RX_AVAILIBLE: u32 = 2;
pub const TX_AVAILIBLE: u32 = 1;
pub const INIT_STAGE: u32 = 0;
pub type sint8_t = ::core::ffi::c_schar;
pub type sint16_t = ::core::ffi::c_short;
pub type sint32_t = ::core::ffi::c_int;
pub type sint64_t = ::core::ffi::c_longlong;
pub type u_int64_t = ::core::ffi::c_ulonglong;
pub type real32_t = f32;
pub type real64_t = f64;
pub type uint8 = ::core::ffi::c_uchar;
pub type u8_ = ::core::ffi::c_uchar;
pub type sint8 = ::core::ffi::c_schar;
pub type int8 = ::core::ffi::c_schar;
pub type s8 = ::core::ffi::c_schar;
pub type uint16 = ::core::ffi::c_ushort;
pub type u16_ = ::core::ffi::c_ushort;
pub type sint16 = ::core::ffi::c_short;
pub type s16 = ::core::ffi::c_short;
pub type uint32 = ::core::ffi::c_uint;
pub type u_int = ::core::ffi::c_uint;
pub type u32_ = ::core::ffi::c_uint;
pub type sint32 = ::core::ffi::c_int;
pub type s32 = ::core::ffi::c_int;
pub type int32 = ::core::ffi::c_int;
pub type sint64 = ::core::ffi::c_longlong;
pub type uint64 = ::core::ffi::c_ulonglong;
pub type u64_ = ::core::ffi::c_ulonglong;
pub type real32 = f32;
pub type real64 = f64;
pub const STATUS_OK: STATUS = 0;
pub const STATUS_FAIL: STATUS = 1;
pub const STATUS_PENDING: STATUS = 2;
pub const STATUS_BUSY: STATUS = 3;
pub const STATUS_CANCEL: STATUS = 4;
pub type STATUS = ::core::ffi::c_uint;
pub type bool_ = ::core::ffi::c_uchar;
pub type ETSSignal = u32;
pub type ETSParam = u32;
pub type ETSEvent = ETSEventTag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ETSEventTag {
    pub sig: ETSSignal,
    pub par: ETSParam,
}
pub type ETSTask = ::core::option::Option<unsafe extern "C" fn(e: *mut ETSEvent)>;
pub type ETSHandle = u32;
pub type ETSTimerFunc =
    ::core::option::Option<unsafe extern "C" fn(timer_arg: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETSTIMER_ {
    pub timer_next: *mut _ETSTIMER_,
    pub timer_expire: u32,
    pub timer_period: u32,
    pub timer_func: ETSTimerFunc,
    pub timer_arg: *mut ::core::ffi::c_void,
}
pub type ETSTimer = _ETSTIMER_;
pub type ets_isr_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_DISABLE: GPIO_INT_TYPE = 0;
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_POSEDGE: GPIO_INT_TYPE = 1;
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_NEGEDGE: GPIO_INT_TYPE = 2;
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_ANYEDGE: GPIO_INT_TYPE = 3;
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_LOLEVEL: GPIO_INT_TYPE = 4;
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_HILEVEL: GPIO_INT_TYPE = 5;
pub type GPIO_INT_TYPE = ::core::ffi::c_uint;
pub type gpio_intr_handler_fn_t =
    ::core::option::Option<unsafe extern "C" fn(intr_mask: uint32, arg: *mut ::core::ffi::c_void)>;
pub type key_function = ::core::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct single_key_param {
    pub key_level: u8,
    pub gpio_id: u8,
    pub gpio_func: u8,
    pub gpio_name: u32,
    pub key_5s: ETSTimer,
    pub key_50ms: ETSTimer,
    pub short_press: key_function,
    pub long_press: key_function,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct keys_param {
    pub key_num: u8,
    pub single_key: *mut *mut single_key_param,
}
pub const SpiNum_SpiNum_SPI: SpiNum = 0;
pub const SpiNum_SpiNum_HSPI: SpiNum = 1;
#[doc = " @brief Support HSPI and SPI module.\n"]
pub type SpiNum = ::core::ffi::c_uint;
pub const SpiMode_SpiMode_Master: SpiMode = 0;
pub const SpiMode_SpiMode_Slave: SpiMode = 1;
#[doc = " @brief The SPI module can work in either master or slave mode.\n"]
pub type SpiMode = ::core::ffi::c_uint;
pub const SpiSubMode_SpiSubMode_0: SpiSubMode = 0;
pub const SpiSubMode_SpiSubMode_1: SpiSubMode = 1;
pub const SpiSubMode_SpiSubMode_2: SpiSubMode = 2;
pub const SpiSubMode_SpiSubMode_3: SpiSubMode = 3;
#[doc = "  @brief SPI sub mode\n\n Support 4 sub modes based on SPI clock polarity and phase.\n SPI_CPOL SPI_CPHA  SubMode\n   0        0        0\n   0        1        1\n   1        0        2\n   1        1        3"]
pub type SpiSubMode = ::core::ffi::c_uint;
pub const SpiSpeed_SpiSpeed_0_5MHz: SpiSpeed = 160;
pub const SpiSpeed_SpiSpeed_1MHz: SpiSpeed = 80;
pub const SpiSpeed_SpiSpeed_2MHz: SpiSpeed = 40;
pub const SpiSpeed_SpiSpeed_5MHz: SpiSpeed = 16;
pub const SpiSpeed_SpiSpeed_8MHz: SpiSpeed = 10;
pub const SpiSpeed_SpiSpeed_10MHz: SpiSpeed = 8;
#[doc = " @brief The SPI module working speed.\n\n @attention Max speed 80MHz\n"]
pub type SpiSpeed = ::core::ffi::c_uint;
pub const SpiBitOrder_SpiBitOrder_MSBFirst: SpiBitOrder = 0;
pub const SpiBitOrder_SpiBitOrder_LSBFirst: SpiBitOrder = 1;
#[doc = " @brief The SPI mode working speed.\n"]
pub type SpiBitOrder = ::core::ffi::c_uint;
pub const SpiIntSrc_SpiIntSrc_TransDone: SpiIntSrc = 16;
pub const SpiIntSrc_SpiIntSrc_WrStaDone: SpiIntSrc = 8;
pub const SpiIntSrc_SpiIntSrc_RdStaDone: SpiIntSrc = 4;
pub const SpiIntSrc_SpiIntSrc_WrBufDone: SpiIntSrc = 2;
pub const SpiIntSrc_SpiIntSrc_RdBufDone: SpiIntSrc = 1;
pub type SpiIntSrc = ::core::ffi::c_uint;
pub const SpiPinCS_SpiPinCS_0: SpiPinCS = 1;
pub const SpiPinCS_SpiPinCS_1: SpiPinCS = 2;
pub const SpiPinCS_SpiPinCS_2: SpiPinCS = 4;
pub type SpiPinCS = ::core::ffi::c_uint;
#[doc = " @brief SPI attribute"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SpiAttr {
    #[doc = "< Master or slave mode"]
    pub mode: SpiMode,
    #[doc = "< SPI SPI_CPOL SPI_CPHA mode"]
    pub subMode: SpiSubMode,
    #[doc = "< SPI Clock"]
    pub speed: SpiSpeed,
    #[doc = "< SPI bit order"]
    pub bitOrder: SpiBitOrder,
}
#[doc = " @brief SPI data package"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SpiData {
    #[doc = "< Command value"]
    pub cmd: u16,
    #[doc = "< Command byte length"]
    pub cmdLen: u8,
    #[doc = "< Point to address value"]
    pub addr: *mut u32,
    #[doc = "< Address byte length"]
    pub addrLen: u8,
    #[doc = "< Point to data buffer"]
    pub data: *mut u32,
    #[doc = "< Data byte length."]
    pub dataLen: u8,
}
#[doc = " @brief SPI interrupt information"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SpiIntInfo {
    #[doc = "< Interrupt source"]
    pub src: SpiIntSrc,
    #[doc = "< SPI interrupt callback function."]
    pub isrFunc: *mut ::core::ffi::c_void,
}
pub const UartBitsNum4Char_FIVE_BITS: UartBitsNum4Char = 0;
pub const UartBitsNum4Char_SIX_BITS: UartBitsNum4Char = 1;
pub const UartBitsNum4Char_SEVEN_BITS: UartBitsNum4Char = 2;
pub const UartBitsNum4Char_EIGHT_BITS: UartBitsNum4Char = 3;
pub type UartBitsNum4Char = ::core::ffi::c_uint;
pub const UartStopBitsNum_ONE_STOP_BIT: UartStopBitsNum = 1;
pub const UartStopBitsNum_ONE_HALF_STOP_BIT: UartStopBitsNum = 2;
pub const UartStopBitsNum_TWO_STOP_BIT: UartStopBitsNum = 3;
pub type UartStopBitsNum = ::core::ffi::c_uint;
pub const UartParityMode_NONE_BITS: UartParityMode = 2;
pub const UartParityMode_ODD_BITS: UartParityMode = 1;
pub const UartParityMode_EVEN_BITS: UartParityMode = 0;
pub type UartParityMode = ::core::ffi::c_uint;
pub const UartExistParity_STICK_PARITY_DIS: UartExistParity = 0;
pub const UartExistParity_STICK_PARITY_EN: UartExistParity = 1;
pub type UartExistParity = ::core::ffi::c_uint;
pub const UART_LineLevelInverse_UART_None_Inverse: UART_LineLevelInverse = 0;
pub const UART_LineLevelInverse_UART_Rxd_Inverse: UART_LineLevelInverse = 524288;
pub const UART_LineLevelInverse_UART_CTS_Inverse: UART_LineLevelInverse = 1048576;
pub const UART_LineLevelInverse_UART_Txd_Inverse: UART_LineLevelInverse = 4194304;
pub const UART_LineLevelInverse_UART_RTS_Inverse: UART_LineLevelInverse = 8388608;
pub type UART_LineLevelInverse = ::core::ffi::c_uint;
pub const UartBautRate_BIT_RATE_300: UartBautRate = 300;
pub const UartBautRate_BIT_RATE_600: UartBautRate = 600;
pub const UartBautRate_BIT_RATE_1200: UartBautRate = 1200;
pub const UartBautRate_BIT_RATE_2400: UartBautRate = 2400;
pub const UartBautRate_BIT_RATE_4800: UartBautRate = 4800;
pub const UartBautRate_BIT_RATE_9600: UartBautRate = 9600;
pub const UartBautRate_BIT_RATE_19200: UartBautRate = 19200;
pub const UartBautRate_BIT_RATE_38400: UartBautRate = 38400;
pub const UartBautRate_BIT_RATE_57600: UartBautRate = 57600;
pub const UartBautRate_BIT_RATE_74880: UartBautRate = 74880;
pub const UartBautRate_BIT_RATE_115200: UartBautRate = 115200;
pub const UartBautRate_BIT_RATE_230400: UartBautRate = 230400;
pub const UartBautRate_BIT_RATE_460800: UartBautRate = 460800;
pub const UartBautRate_BIT_RATE_921600: UartBautRate = 921600;
pub const UartBautRate_BIT_RATE_1843200: UartBautRate = 1843200;
pub const UartBautRate_BIT_RATE_3686400: UartBautRate = 3686400;
pub type UartBautRate = ::core::ffi::c_uint;
pub const UartFlowCtrl_NONE_CTRL: UartFlowCtrl = 0;
pub const UartFlowCtrl_HARDWARE_CTRL: UartFlowCtrl = 1;
pub const UartFlowCtrl_XON_XOFF_CTRL: UartFlowCtrl = 2;
pub type UartFlowCtrl = ::core::ffi::c_uint;
pub const UART_HwFlowCtrl_USART_HardwareFlowControl_None: UART_HwFlowCtrl = 0;
pub const UART_HwFlowCtrl_USART_HardwareFlowControl_RTS: UART_HwFlowCtrl = 1;
pub const UART_HwFlowCtrl_USART_HardwareFlowControl_CTS: UART_HwFlowCtrl = 2;
pub const UART_HwFlowCtrl_USART_HardwareFlowControl_CTS_RTS: UART_HwFlowCtrl = 3;
pub type UART_HwFlowCtrl = ::core::ffi::c_uint;
pub const RcvMsgBuffState_EMPTY: RcvMsgBuffState = 0;
pub const RcvMsgBuffState_UNDER_WRITE: RcvMsgBuffState = 1;
pub const RcvMsgBuffState_WRITE_OVER: RcvMsgBuffState = 2;
pub type RcvMsgBuffState = ::core::ffi::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RcvMsgBuff {
    pub RcvBuffSize: u32,
    pub pRcvMsgBuff: *mut u8,
    pub pWritePos: *mut u8,
    pub pReadPos: *mut u8,
    pub TrigLvl: u8,
    pub BuffState: RcvMsgBuffState,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TrxMsgBuff {
    pub TrxBuffSize: u32,
    pub pTrxBuff: *mut u8,
}
pub const RcvMsgState_BAUD_RATE_DET: RcvMsgState = 0;
pub const RcvMsgState_WAIT_SYNC_FRM: RcvMsgState = 1;
pub const RcvMsgState_SRCH_MSG_HEAD: RcvMsgState = 2;
pub const RcvMsgState_RCV_MSG_BODY: RcvMsgState = 3;
pub const RcvMsgState_RCV_ESC_CHAR: RcvMsgState = 4;
pub type RcvMsgState = ::core::ffi::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct UartDevice {
    pub baut_rate: UartBautRate,
    pub data_bits: UartBitsNum4Char,
    pub exist_parity: UartExistParity,
    pub parity: UartParityMode,
    pub stop_bits: UartStopBitsNum,
    pub flow_ctrl: UartFlowCtrl,
    pub rcv_buff: RcvMsgBuff,
    pub trx_buff: TrxMsgBuff,
    pub rcv_state: RcvMsgState,
    pub received: i32,
    pub buff_uart_no: i32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct UartBuffer {
    pub UartBuffSize: u32,
    pub pUartBuff: *mut u8,
    pub pInPos: *mut u8,
    pub pOutPos: *mut u8,
    pub BuffState: STATUS,
    pub Space: u16,
    pub TcpControl: u8,
    pub nextBuff: *mut UartBuffer,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct UartRxBuff {
    pub UartRxBuffSize: u32,
    pub pUartRxBuff: *mut u8,
    pub pWritePos: *mut u8,
    pub pReadPos: *mut u8,
    pub RxBuffState: STATUS,
    pub Space: u32,
}
pub const TCPState_RUN: TCPState = 0;
pub const TCPState_BLOCK: TCPState = 1;
pub type TCPState = ::core::ffi::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::core::ffi::c_ushort,
    pub __ctype_tolower: *const ::core::ffi::c_int,
    pub __ctype_toupper: *const ::core::ffi::c_int,
    pub __names: [*const ::core::ffi::c_char; 13usize],
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
pub const SpiFlashOpResult_SPI_FLASH_RESULT_OK: SpiFlashOpResult = 0;
pub const SpiFlashOpResult_SPI_FLASH_RESULT_ERR: SpiFlashOpResult = 1;
pub const SpiFlashOpResult_SPI_FLASH_RESULT_TIMEOUT: SpiFlashOpResult = 2;
pub type SpiFlashOpResult = ::core::ffi::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SpiFlashChip {
    pub deviceId: uint32,
    pub chip_size: uint32,
    pub block_size: uint32,
    pub sector_size: uint32,
    pub page_size: uint32,
    pub status_mask: uint32,
}
pub type user_spi_flash_read = ::core::option::Option<
    unsafe extern "C" fn(
        spi: *mut SpiFlashChip,
        src_addr: uint32,
        des_addr: *mut uint32,
        size: uint32,
    ) -> SpiFlashOpResult,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hspi_device_config {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl hspi_device_config {
    #[inline]
    pub fn active(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_active(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn active_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_active_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn clk_polar(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_clk_polar(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn clk_polar_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_clk_polar_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn res(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_res(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn res_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_res_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn clk_div(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_clk_div(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn clk_div_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_clk_div_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        active: u8,
        clk_polar: u8,
        res: u8,
        clk_div: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let active: u8 = unsafe { ::core::mem::transmute(active) };
            active as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let clk_polar: u8 = unsafe { ::core::mem::transmute(clk_polar) };
            clk_polar as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let res: u8 = unsafe { ::core::mem::transmute(res) };
            res as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let clk_div: u8 = unsafe { ::core::mem::transmute(clk_div) };
            clk_div as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct hspi_device_register {
    pub hspi_flash_reg_backup: [u32; 9usize],
    pub hspi_dev_reg_backup: [u32; 9usize],
    pub hspi_dev_conf: [hspi_device_config; 4usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl hspi_device_register {
    #[inline]
    pub fn selected_dev_num(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_selected_dev_num(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn selected_dev_num_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_selected_dev_num_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn spi_io_80m(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_spi_io_80m(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn spi_io_80m_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_spi_io_80m_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hspi_reg_backup_flag(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hspi_reg_backup_flag(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hspi_reg_backup_flag_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hspi_reg_backup_flag_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn res(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_res(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn res_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_res_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        selected_dev_num: u8,
        spi_io_80m: u8,
        hspi_reg_backup_flag: u8,
        res: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let selected_dev_num: u8 = unsafe { ::core::mem::transmute(selected_dev_num) };
            selected_dev_num as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let spi_io_80m: u8 = unsafe { ::core::mem::transmute(spi_io_80m) };
            spi_io_80m as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let hspi_reg_backup_flag: u8 = unsafe { ::core::mem::transmute(hspi_reg_backup_flag) };
            hspi_reg_backup_flag as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let res: u8 = unsafe { ::core::mem::transmute(res) };
            res as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const time_predived_mode_DIVDED_BY_1: time_predived_mode = 0;
pub const time_predived_mode_DIVDED_BY_16: time_predived_mode = 4;
pub const time_predived_mode_DIVDED_BY_256: time_predived_mode = 8;
pub type time_predived_mode = ::core::ffi::c_uint;
pub const time_int_mode_TM_LEVEL_INT: time_int_mode = 1;
pub const time_int_mode_TM_EDGE_INT: time_int_mode = 0;
pub type time_int_mode = ::core::ffi::c_uint;
pub const frc1_timer_source_type_FRC1_SOURCE: frc1_timer_source_type = 0;
pub const frc1_timer_source_type_NMI_SOURCE: frc1_timer_source_type = 1;
pub type frc1_timer_source_type = ::core::ffi::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ip_addr {
    pub addr: uint32,
}
pub type ip_addr_t = ip_addr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_info {
    pub ip: ip_addr,
    pub netmask: ip_addr,
    pub gw: ip_addr,
}
pub const rst_reason_REASON_DEFAULT_RST: rst_reason = 0;
pub const rst_reason_REASON_WDT_RST: rst_reason = 1;
pub const rst_reason_REASON_EXCEPTION_RST: rst_reason = 2;
pub const rst_reason_REASON_SOFT_WDT_RST: rst_reason = 3;
pub const rst_reason_REASON_SOFT_RESTART: rst_reason = 4;
pub const rst_reason_REASON_DEEP_SLEEP_AWAKE: rst_reason = 5;
pub const rst_reason_REASON_EXT_SYS_RST: rst_reason = 6;
pub type rst_reason = ::core::ffi::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rst_info {
    pub reason: uint32,
    pub exccause: uint32,
    pub epc1: uint32,
    pub epc2: uint32,
    pub epc3: uint32,
    pub excvaddr: uint32,
    pub depc: uint32,
}
pub const USER_TASK_PRIO_0: _bindgen_ty_1 = 0;
pub const USER_TASK_PRIO_1: _bindgen_ty_1 = 1;
pub const USER_TASK_PRIO_2: _bindgen_ty_1 = 2;
pub const USER_TASK_PRIO_MAX: _bindgen_ty_1 = 3;
pub type _bindgen_ty_1 = ::core::ffi::c_uint;
pub type init_done_cb_t = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = "<  Flash size : 4Mbits. Map : 256KBytes + 256KBytes"]
pub const flash_size_map_FLASH_SIZE_4M_MAP_256_256: flash_size_map = 0;
#[doc = "<  Flash size : 2Mbits. Map : 256KBytes"]
pub const flash_size_map_FLASH_SIZE_2M: flash_size_map = 1;
#[doc = "<  Flash size : 8Mbits. Map : 512KBytes + 512KBytes"]
pub const flash_size_map_FLASH_SIZE_8M_MAP_512_512: flash_size_map = 2;
#[doc = "<  Flash size : 16Mbits. Map : 512KBytes + 512KBytes"]
pub const flash_size_map_FLASH_SIZE_16M_MAP_512_512: flash_size_map = 3;
#[doc = "<  Flash size : 32Mbits. Map : 512KBytes + 512KBytes"]
pub const flash_size_map_FLASH_SIZE_32M_MAP_512_512: flash_size_map = 4;
#[doc = "<  Flash size : 16Mbits. Map : 1024KBytes + 1024KBytes"]
pub const flash_size_map_FLASH_SIZE_16M_MAP_1024_1024: flash_size_map = 5;
#[doc = "<  Flash size : 32Mbits. Map : 1024KBytes + 1024KBytes"]
pub const flash_size_map_FLASH_SIZE_32M_MAP_1024_1024: flash_size_map = 6;
#[doc = "<  attention: don't support now ,just compatible for nodemcu;\nFlash size : 32Mbits. Map : 2048KBytes + 2048KBytes"]
pub const flash_size_map_FLASH_SIZE_32M_MAP_2048_2048: flash_size_map = 7;
#[doc = "<  Flash size : 64Mbits. Map : 1024KBytes + 1024KBytes"]
pub const flash_size_map_FLASH_SIZE_64M_MAP_1024_1024: flash_size_map = 8;
#[doc = "<  Flash size : 128Mbits. Map : 1024KBytes + 1024KBytes"]
pub const flash_size_map_FLASH_SIZE_128M_MAP_1024_1024: flash_size_map = 9;
pub type flash_size_map = ::core::ffi::c_uint;
pub const _auth_mode_AUTH_OPEN: _auth_mode = 0;
pub const _auth_mode_AUTH_WEP: _auth_mode = 1;
pub const _auth_mode_AUTH_WPA_PSK: _auth_mode = 2;
pub const _auth_mode_AUTH_WPA2_PSK: _auth_mode = 3;
pub const _auth_mode_AUTH_WPA_WPA2_PSK: _auth_mode = 4;
pub const _auth_mode_AUTH_MAX: _auth_mode = 5;
pub type _auth_mode = ::core::ffi::c_uint;
pub use self::_auth_mode as AUTH_MODE;
pub const _cipher_type_CIPHER_NONE: _cipher_type = 0;
pub const _cipher_type_CIPHER_WEP40: _cipher_type = 1;
pub const _cipher_type_CIPHER_WEP104: _cipher_type = 2;
pub const _cipher_type_CIPHER_TKIP: _cipher_type = 3;
pub const _cipher_type_CIPHER_CCMP: _cipher_type = 4;
pub const _cipher_type_CIPHER_TKIP_CCMP: _cipher_type = 5;
pub const _cipher_type_CIPHER_UNKNOWN: _cipher_type = 6;
pub type _cipher_type = ::core::ffi::c_uint;
pub use self::_cipher_type as CIPHER_TYPE;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct bss_info {
    pub next: bss_info__bindgen_ty_1,
    pub bssid: [uint8; 6usize],
    pub ssid: [uint8; 32usize],
    pub ssid_len: uint8,
    pub channel: uint8,
    pub rssi: sint8,
    pub authmode: AUTH_MODE,
    pub is_hidden: uint8,
    pub freq_offset: sint16,
    pub freqcal_val: sint16,
    pub esp_mesh_ie: *mut uint8,
    pub simple_pair: uint8,
    pub pairwise_cipher: CIPHER_TYPE,
    pub group_cipher: CIPHER_TYPE,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct bss_info__bindgen_ty_1 {
    pub stqe_next: *mut bss_info,
}
impl bss_info {
    #[inline]
    pub fn phy_11b(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11b(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn phy_11b_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_phy_11b_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn phy_11g(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11g(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn phy_11g_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_phy_11g_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn phy_11n(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11n(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn phy_11n_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_phy_11n_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wps(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wps(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wps_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wps_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                28u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                28u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        phy_11b: u32,
        phy_11g: u32,
        phy_11n: u32,
        wps: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let phy_11b: u32 = unsafe { ::core::mem::transmute(phy_11b) };
            phy_11b as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let phy_11g: u32 = unsafe { ::core::mem::transmute(phy_11g) };
            phy_11g as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let phy_11n: u32 = unsafe { ::core::mem::transmute(phy_11n) };
            phy_11n as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let wps: u32 = unsafe { ::core::mem::transmute(wps) };
            wps as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _scaninfo {
    pub pbss: *mut _scaninfo__bindgen_ty_1,
    pub pespconn: *mut espconn,
    pub totalpage: uint8,
    pub pagenum: uint8,
    pub page_sn: uint8,
    pub data_cnt: uint8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _scaninfo__bindgen_ty_1 {
    pub stqh_first: *mut bss_info,
    pub stqh_last: *mut *mut bss_info,
}
pub type scaninfo = _scaninfo;
pub type scan_done_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, status: STATUS)>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_fast_scan_threshold_t {
    pub rssi: int8,
    pub authmode: AUTH_MODE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct station_config {
    pub ssid: [uint8; 32usize],
    pub password: [uint8; 64usize],
    pub channel: uint8,
    pub bssid_set: uint8,
    pub bssid: [uint8; 6usize],
    pub threshold: wifi_fast_scan_threshold_t,
    pub open_and_wep_mode_disable: bool_,
    pub all_channel_scan: bool_,
}
#[doc = "< active scan"]
pub const wifi_scan_type_t_WIFI_SCAN_TYPE_ACTIVE: wifi_scan_type_t = 0;
#[doc = "< passive scan"]
pub const wifi_scan_type_t_WIFI_SCAN_TYPE_PASSIVE: wifi_scan_type_t = 1;
pub type wifi_scan_type_t = ::core::ffi::c_uint;
#[doc = " @brief Range of active scan times per channel"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_active_scan_time_t {
    #[doc = "< minimum active scan time per channel, units: millisecond"]
    pub min: u32,
    #[doc = "< maximum active scan time per channel, units: millisecond, values above 1500ms may\ncause station to disconnect from AP and are not recommended."]
    pub max: u32,
}
#[doc = " @brief Aggregate of active & passive scan time per channel"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union wifi_scan_time_t {
    #[doc = "< active scan time per channel, units: millisecond."]
    pub active: wifi_active_scan_time_t,
    #[doc = "< passive scan time per channel, units: millisecond, values above 1500ms may\ncause station to disconnect from AP and are not recommended."]
    pub passive: u32,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct scan_config {
    pub ssid: *mut uint8,
    pub bssid: *mut uint8,
    pub channel: uint8,
    pub show_hidden: uint8,
    pub scan_type: wifi_scan_type_t,
    pub scan_time: wifi_scan_time_t,
}
pub const STATION_IDLE: _bindgen_ty_2 = 0;
pub const STATION_CONNECTING: _bindgen_ty_2 = 1;
pub const STATION_WRONG_PASSWORD: _bindgen_ty_2 = 2;
pub const STATION_NO_AP_FOUND: _bindgen_ty_2 = 3;
pub const STATION_CONNECT_FAIL: _bindgen_ty_2 = 4;
pub const STATION_GOT_IP: _bindgen_ty_2 = 5;
pub type _bindgen_ty_2 = ::core::ffi::c_uint;
pub const dhcp_status_DHCP_STOPPED: dhcp_status = 0;
pub const dhcp_status_DHCP_STARTED: dhcp_status = 1;
pub type dhcp_status = ::core::ffi::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct softap_config {
    pub ssid: [uint8; 32usize],
    pub password: [uint8; 64usize],
    pub ssid_len: uint8,
    pub channel: uint8,
    pub authmode: AUTH_MODE,
    pub ssid_hidden: uint8,
    pub max_connection: uint8,
    pub beacon_interval: uint16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct station_info {
    pub next: station_info__bindgen_ty_1,
    pub bssid: [uint8; 6usize],
    pub ip: ip_addr,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct station_info__bindgen_ty_1 {
    pub stqe_next: *mut station_info,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dhcps_lease {
    pub enable: bool_,
    pub start_ip: ip_addr,
    pub end_ip: ip_addr,
}
pub const dhcps_offer_option_OFFER_START: dhcps_offer_option = 0;
pub const dhcps_offer_option_OFFER_ROUTER: dhcps_offer_option = 1;
pub const dhcps_offer_option_OFFER_END: dhcps_offer_option = 2;
pub type dhcps_offer_option = ::core::ffi::c_uint;
pub type wifi_promiscuous_cb_t =
    ::core::option::Option<unsafe extern "C" fn(buf: *mut uint8, len: uint16)>;
pub const phy_mode_PHY_MODE_11B: phy_mode = 1;
pub const phy_mode_PHY_MODE_11G: phy_mode = 2;
pub const phy_mode_PHY_MODE_11N: phy_mode = 3;
pub type phy_mode = ::core::ffi::c_uint;
pub const sleep_type_NONE_SLEEP_T: sleep_type = 0;
pub const sleep_type_LIGHT_SLEEP_T: sleep_type = 1;
pub const sleep_type_MODEM_SLEEP_T: sleep_type = 2;
pub type sleep_type = ::core::ffi::c_uint;
pub const sleep_level_MIN_SLEEP_T: sleep_level = 0;
pub const sleep_level_MAX_SLEEP_T: sleep_level = 1;
pub type sleep_level = ::core::ffi::c_uint;
pub type fpm_wakeup_cb = ::core::option::Option<unsafe extern "C" fn()>;
pub const EVENT_STAMODE_CONNECTED: _bindgen_ty_3 = 0;
pub const EVENT_STAMODE_DISCONNECTED: _bindgen_ty_3 = 1;
pub const EVENT_STAMODE_AUTHMODE_CHANGE: _bindgen_ty_3 = 2;
pub const EVENT_STAMODE_GOT_IP: _bindgen_ty_3 = 3;
pub const EVENT_STAMODE_DHCP_TIMEOUT: _bindgen_ty_3 = 4;
pub const EVENT_SOFTAPMODE_STACONNECTED: _bindgen_ty_3 = 5;
pub const EVENT_SOFTAPMODE_STADISCONNECTED: _bindgen_ty_3 = 6;
pub const EVENT_SOFTAPMODE_PROBEREQRECVED: _bindgen_ty_3 = 7;
pub const EVENT_OPMODE_CHANGED: _bindgen_ty_3 = 8;
pub const EVENT_SOFTAPMODE_DISTRIBUTE_STA_IP: _bindgen_ty_3 = 9;
pub const EVENT_MAX: _bindgen_ty_3 = 10;
pub type _bindgen_ty_3 = ::core::ffi::c_uint;
pub const REASON_UNSPECIFIED: _bindgen_ty_4 = 1;
pub const REASON_AUTH_EXPIRE: _bindgen_ty_4 = 2;
pub const REASON_AUTH_LEAVE: _bindgen_ty_4 = 3;
pub const REASON_ASSOC_EXPIRE: _bindgen_ty_4 = 4;
pub const REASON_ASSOC_TOOMANY: _bindgen_ty_4 = 5;
pub const REASON_NOT_AUTHED: _bindgen_ty_4 = 6;
pub const REASON_NOT_ASSOCED: _bindgen_ty_4 = 7;
pub const REASON_ASSOC_LEAVE: _bindgen_ty_4 = 8;
pub const REASON_ASSOC_NOT_AUTHED: _bindgen_ty_4 = 9;
pub const REASON_DISASSOC_PWRCAP_BAD: _bindgen_ty_4 = 10;
pub const REASON_DISASSOC_SUPCHAN_BAD: _bindgen_ty_4 = 11;
pub const REASON_IE_INVALID: _bindgen_ty_4 = 13;
pub const REASON_MIC_FAILURE: _bindgen_ty_4 = 14;
pub const REASON_4WAY_HANDSHAKE_TIMEOUT: _bindgen_ty_4 = 15;
pub const REASON_GROUP_KEY_UPDATE_TIMEOUT: _bindgen_ty_4 = 16;
pub const REASON_IE_IN_4WAY_DIFFERS: _bindgen_ty_4 = 17;
pub const REASON_GROUP_CIPHER_INVALID: _bindgen_ty_4 = 18;
pub const REASON_PAIRWISE_CIPHER_INVALID: _bindgen_ty_4 = 19;
pub const REASON_AKMP_INVALID: _bindgen_ty_4 = 20;
pub const REASON_UNSUPP_RSN_IE_VERSION: _bindgen_ty_4 = 21;
pub const REASON_INVALID_RSN_IE_CAP: _bindgen_ty_4 = 22;
pub const REASON_802_1X_AUTH_FAILED: _bindgen_ty_4 = 23;
pub const REASON_CIPHER_SUITE_REJECTED: _bindgen_ty_4 = 24;
pub const REASON_BEACON_TIMEOUT: _bindgen_ty_4 = 200;
pub const REASON_NO_AP_FOUND: _bindgen_ty_4 = 201;
pub const REASON_AUTH_FAIL: _bindgen_ty_4 = 202;
pub const REASON_ASSOC_FAIL: _bindgen_ty_4 = 203;
pub const REASON_HANDSHAKE_TIMEOUT: _bindgen_ty_4 = 204;
pub type _bindgen_ty_4 = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Event_StaMode_Connected_t {
    pub ssid: [uint8; 32usize],
    pub ssid_len: uint8,
    pub bssid: [uint8; 6usize],
    pub channel: uint8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Event_StaMode_Disconnected_t {
    pub ssid: [uint8; 32usize],
    pub ssid_len: uint8,
    pub bssid: [uint8; 6usize],
    pub reason: uint8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Event_StaMode_AuthMode_Change_t {
    pub old_mode: uint8,
    pub new_mode: uint8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Event_StaMode_Got_IP_t {
    pub ip: ip_addr,
    pub mask: ip_addr,
    pub gw: ip_addr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Event_SoftAPMode_StaConnected_t {
    pub mac: [uint8; 6usize],
    pub aid: uint8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Event_SoftAPMode_Distribute_Sta_IP_t {
    pub mac: [uint8; 6usize],
    pub ip: ip_addr,
    pub aid: uint8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Event_SoftAPMode_StaDisconnected_t {
    pub mac: [uint8; 6usize],
    pub aid: uint8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct Event_SoftAPMode_ProbeReqRecved_t {
    pub rssi: ::core::ffi::c_int,
    pub mac: [uint8; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Event_OpMode_Change_t {
    pub old_opmode: uint8,
    pub new_opmode: uint8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Event_Info_u {
    pub connected: Event_StaMode_Connected_t,
    pub disconnected: Event_StaMode_Disconnected_t,
    pub auth_change: Event_StaMode_AuthMode_Change_t,
    pub got_ip: Event_StaMode_Got_IP_t,
    pub sta_connected: Event_SoftAPMode_StaConnected_t,
    pub distribute_sta_ip: Event_SoftAPMode_Distribute_Sta_IP_t,
    pub sta_disconnected: Event_SoftAPMode_StaDisconnected_t,
    pub ap_probereqrecved: Event_SoftAPMode_ProbeReqRecved_t,
    pub opmode_changed: Event_OpMode_Change_t,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _esp_event {
    pub event: uint32,
    pub event_info: Event_Info_u,
}
pub type System_Event_t = _esp_event;
pub type wifi_event_handler_cb_t =
    ::core::option::Option<unsafe extern "C" fn(event: *mut System_Event_t)>;
pub const wps_type_WPS_TYPE_DISABLE: wps_type = 0;
pub const wps_type_WPS_TYPE_PBC: wps_type = 1;
pub const wps_type_WPS_TYPE_PIN: wps_type = 2;
pub const wps_type_WPS_TYPE_DISPLAY: wps_type = 3;
pub const wps_type_WPS_TYPE_MAX: wps_type = 4;
pub type wps_type = ::core::ffi::c_uint;
pub use self::wps_type as WPS_TYPE_t;
pub const wps_cb_status_WPS_CB_ST_SUCCESS: wps_cb_status = 0;
pub const wps_cb_status_WPS_CB_ST_FAILED: wps_cb_status = 1;
pub const wps_cb_status_WPS_CB_ST_TIMEOUT: wps_cb_status = 2;
pub const wps_cb_status_WPS_CB_ST_WEP: wps_cb_status = 3;
pub type wps_cb_status = ::core::ffi::c_uint;
pub type wps_st_cb_t = ::core::option::Option<unsafe extern "C" fn(status: ::core::ffi::c_int)>;
pub type freedom_outside_cb_t = ::core::option::Option<unsafe extern "C" fn(status: uint8)>;
pub type rfid_locp_cb_t = ::core::option::Option<
    unsafe extern "C" fn(frm: *mut uint8, len: ::core::ffi::c_int, rssi: ::core::ffi::c_int),
>;
pub const FIXED_RATE_PHY_RATE_48: FIXED_RATE = 8;
pub const FIXED_RATE_PHY_RATE_24: FIXED_RATE = 9;
pub const FIXED_RATE_PHY_RATE_12: FIXED_RATE = 10;
pub const FIXED_RATE_PHY_RATE_6: FIXED_RATE = 11;
pub const FIXED_RATE_PHY_RATE_54: FIXED_RATE = 12;
pub const FIXED_RATE_PHY_RATE_36: FIXED_RATE = 13;
pub const FIXED_RATE_PHY_RATE_18: FIXED_RATE = 14;
pub const FIXED_RATE_PHY_RATE_9: FIXED_RATE = 15;
pub type FIXED_RATE = ::core::ffi::c_uint;
pub const support_rate_RATE_11B5M: support_rate = 0;
pub const support_rate_RATE_11B11M: support_rate = 1;
pub const support_rate_RATE_11B1M: support_rate = 2;
pub const support_rate_RATE_11B2M: support_rate = 3;
pub const support_rate_RATE_11G6M: support_rate = 4;
pub const support_rate_RATE_11G12M: support_rate = 5;
pub const support_rate_RATE_11G24M: support_rate = 6;
pub const support_rate_RATE_11G48M: support_rate = 7;
pub const support_rate_RATE_11G54M: support_rate = 8;
pub const support_rate_RATE_11G9M: support_rate = 9;
pub const support_rate_RATE_11G18M: support_rate = 10;
pub const support_rate_RATE_11G36M: support_rate = 11;
pub type support_rate = ::core::ffi::c_uint;
pub const RATE_11B_ID_RATE_11B_B11M: RATE_11B_ID = 0;
pub const RATE_11B_ID_RATE_11B_B5M: RATE_11B_ID = 1;
pub const RATE_11B_ID_RATE_11B_B2M: RATE_11B_ID = 2;
pub const RATE_11B_ID_RATE_11B_B1M: RATE_11B_ID = 3;
pub type RATE_11B_ID = ::core::ffi::c_uint;
pub const RATE_11G_ID_RATE_11G_G54M: RATE_11G_ID = 0;
pub const RATE_11G_ID_RATE_11G_G48M: RATE_11G_ID = 1;
pub const RATE_11G_ID_RATE_11G_G36M: RATE_11G_ID = 2;
pub const RATE_11G_ID_RATE_11G_G24M: RATE_11G_ID = 3;
pub const RATE_11G_ID_RATE_11G_G18M: RATE_11G_ID = 4;
pub const RATE_11G_ID_RATE_11G_G12M: RATE_11G_ID = 5;
pub const RATE_11G_ID_RATE_11G_G9M: RATE_11G_ID = 6;
pub const RATE_11G_ID_RATE_11G_G6M: RATE_11G_ID = 7;
pub const RATE_11G_ID_RATE_11G_B5M: RATE_11G_ID = 8;
pub const RATE_11G_ID_RATE_11G_B2M: RATE_11G_ID = 9;
pub const RATE_11G_ID_RATE_11G_B1M: RATE_11G_ID = 10;
pub type RATE_11G_ID = ::core::ffi::c_uint;
pub const RATE_11N_ID_RATE_11N_MCS7S: RATE_11N_ID = 0;
pub const RATE_11N_ID_RATE_11N_MCS7: RATE_11N_ID = 1;
pub const RATE_11N_ID_RATE_11N_MCS6: RATE_11N_ID = 2;
pub const RATE_11N_ID_RATE_11N_MCS5: RATE_11N_ID = 3;
pub const RATE_11N_ID_RATE_11N_MCS4: RATE_11N_ID = 4;
pub const RATE_11N_ID_RATE_11N_MCS3: RATE_11N_ID = 5;
pub const RATE_11N_ID_RATE_11N_MCS2: RATE_11N_ID = 6;
pub const RATE_11N_ID_RATE_11N_MCS1: RATE_11N_ID = 7;
pub const RATE_11N_ID_RATE_11N_MCS0: RATE_11N_ID = 8;
pub const RATE_11N_ID_RATE_11N_B5M: RATE_11N_ID = 9;
pub const RATE_11N_ID_RATE_11N_B2M: RATE_11N_ID = 10;
pub const RATE_11N_ID_RATE_11N_B1M: RATE_11N_ID = 11;
pub type RATE_11N_ID = ::core::ffi::c_uint;
pub const USER_IE_BEACON: _bindgen_ty_5 = 0;
pub const USER_IE_PROBE_REQ: _bindgen_ty_5 = 1;
pub const USER_IE_PROBE_RESP: _bindgen_ty_5 = 2;
pub const USER_IE_ASSOC_REQ: _bindgen_ty_5 = 3;
pub const USER_IE_ASSOC_RESP: _bindgen_ty_5 = 4;
pub const USER_IE_MAX: _bindgen_ty_5 = 5;
pub type _bindgen_ty_5 = ::core::ffi::c_uint;
pub type user_ie_manufacturer_recv_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        type_: uint8,
        sa: *const uint8,
        m_oui: *const uint8,
        ie: *mut uint8,
        ie_len: uint8,
        rssi: ::core::ffi::c_int,
    ),
>;
#[doc = "< Country policy is auto, use the country info of AP to which the station is connected"]
pub const WIFI_COUNTRY_POLICY_WIFI_COUNTRY_POLICY_AUTO: WIFI_COUNTRY_POLICY = 0;
#[doc = "< Country policy is manual, always use the configured country info"]
pub const WIFI_COUNTRY_POLICY_WIFI_COUNTRY_POLICY_MANUAL: WIFI_COUNTRY_POLICY = 1;
pub type WIFI_COUNTRY_POLICY = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_country_t {
    #[doc = "< country code string"]
    pub cc: [::core::ffi::c_char; 3usize],
    #[doc = "< start channel"]
    pub schan: u8,
    #[doc = "< total channel number"]
    pub nchan: u8,
    #[doc = "< country policy"]
    pub policy: u8,
}
pub const partition_type_t_SYSTEM_PARTITION_INVALID: partition_type_t = 0;
pub const partition_type_t_SYSTEM_PARTITION_BOOTLOADER: partition_type_t = 1;
pub const partition_type_t_SYSTEM_PARTITION_OTA_1: partition_type_t = 2;
pub const partition_type_t_SYSTEM_PARTITION_OTA_2: partition_type_t = 3;
pub const partition_type_t_SYSTEM_PARTITION_RF_CAL: partition_type_t = 4;
pub const partition_type_t_SYSTEM_PARTITION_PHY_DATA: partition_type_t = 5;
pub const partition_type_t_SYSTEM_PARTITION_SYSTEM_PARAMETER: partition_type_t = 6;
pub const partition_type_t_SYSTEM_PARTITION_AT_PARAMETER: partition_type_t = 7;
pub const partition_type_t_SYSTEM_PARTITION_SSL_CLIENT_CERT_PRIVKEY: partition_type_t = 8;
pub const partition_type_t_SYSTEM_PARTITION_SSL_CLIENT_CA: partition_type_t = 9;
pub const partition_type_t_SYSTEM_PARTITION_SSL_SERVER_CERT_PRIVKEY: partition_type_t = 10;
pub const partition_type_t_SYSTEM_PARTITION_SSL_SERVER_CA: partition_type_t = 11;
pub const partition_type_t_SYSTEM_PARTITION_WPA2_ENTERPRISE_CERT_PRIVKEY: partition_type_t = 12;
pub const partition_type_t_SYSTEM_PARTITION_WPA2_ENTERPRISE_CA: partition_type_t = 13;
pub const partition_type_t_SYSTEM_PARTITION_CUSTOMER_BEGIN: partition_type_t = 100;
pub const partition_type_t_SYSTEM_PARTITION_MAX: partition_type_t = 101;
pub type partition_type_t = ::core::ffi::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct partition_item_t {
    pub type_: partition_type_t,
    pub addr: u32,
    pub size: u32,
}
pub type sdio_recv_data_callback_t =
    ::core::option::Option<unsafe extern "C" fn(data: *mut u8, len: u32)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct espconn {
    pub _address: u8,
}
extern "C" {
    pub fn ets_intr_lock();
    pub fn ets_intr_unlock();
    pub fn ets_isr_attach(i: ::core::ffi::c_int, func: ets_isr_t, arg: *mut ::core::ffi::c_void);
    pub fn ets_isr_mask(mask: uint32);
    pub fn ets_isr_unmask(unmask: uint32);
    pub fn NmiTimSetFunc(func: ::core::option::Option<unsafe extern "C" fn()>);
    pub fn gpio16_output_conf();
    pub fn gpio16_output_set(value: u8);
    pub fn gpio16_input_conf();
    pub fn gpio16_input_get() -> u8;
    pub fn gpio_init();
    pub fn gpio_output_set(
        set_mask: uint32,
        clear_mask: uint32,
        enable_mask: uint32,
        disable_mask: uint32,
    );
    pub fn gpio_input_get() -> uint32;
    pub fn gpio_register_set(reg_id: uint32, value: uint32);
    pub fn gpio_register_get(reg_id: uint32) -> uint32;
    pub fn gpio_intr_handler_register(fn_: gpio_intr_handler_fn_t, arg: *mut ::core::ffi::c_void);
    pub fn gpio_intr_pending() -> uint32;
    pub fn gpio_intr_ack(ack_mask: uint32);
    pub fn gpio_pin_wakeup_enable(i: uint32, intr_state: GPIO_INT_TYPE);
    pub fn gpio_pin_wakeup_disable();
    pub fn gpio_pin_intr_state_set(i: uint32, intr_state: GPIO_INT_TYPE);
    pub fn key_init_single(
        gpio_id: u8,
        gpio_name: u32,
        gpio_func: u8,
        long_press: key_function,
        short_press: key_function,
    ) -> *mut single_key_param;
    pub fn key_init(key: *mut keys_param);
    #[doc = " @brief Initialize SPI module.\n\n @param [in] spiNum\n             Indicates which submode to be used, SPI or HSPI.\n @param [in] pAttr\n             Pointer to a struct SpiAttr that indicates SPI working attribution.\n\n @return void."]
    pub fn SPIInit(spiNum: SpiNum, pAttr: *mut SpiAttr);
    #[doc = " @brief Set slave address value by master.\n\n @param [in] spiNum\n             Indicates which submode to be used, SPI or HSPI.\n @param [in] addr\n             Slave address to be set.\n\n @return void."]
    pub fn SPIMasterCfgAddr(spiNum: SpiNum, addr: u32);
    #[doc = " @brief Set command value by master.\n\n @param [in] spiNum\n             Indicates which submode to be used, SPI or HSPI.\n @param [in] cmd\n             Command will be send to slave.\n\n @return void."]
    pub fn SPIMasterCfgCmd(spiNum: SpiNum, cmd: u32);
    #[doc = " @brief Send data to slave from master.\n\n @param [in] spiNum\n             Indicates which submode to be used, SPI or HSPI.\n @param [in] pInData\n             Pointer to a strcuture that will be send.\n\n @return int32_t, -1:indicates failure,others indicates success."]
    pub fn SPIMasterSendData(spiNum: SpiNum, pInData: *mut SpiData) -> i32;
    #[doc = " @brief Receive data from slave by master.\n\n @param [in] spiNum\n             Indicates which submode to be used, SPI or HSPI.\n @param [in] pOutData\n             Point to data buffer.\n\n @return int32_t, -1:indicates failure,others indicates success.\n"]
    pub fn SPIMasterRecvData(spiNum: SpiNum, pOutData: *mut SpiData) -> i32;
    #[doc = " @brief Load data to slave send buffer.\n\n @param [in] spiNum\n             Indicates which submode to be used, SPI or HSPI.\n @param [in] pInData\n             Point to data buffer.\n @param [in] inLen\n             The number of bytes to be set.\n\n @return int32_t, -1:indicates failure,others indicates success."]
    pub fn SPISlaveSendData(spiNum: SpiNum, pInData: *mut u32, inLen: u8) -> i32;
    #[doc = " @brief Receive data by slave.\n\n @param [in] spiNum\n             Indicates which submode to be used, SPI or HSPI.\n @param [in] isrFunc\n             isrFunc is a pointer to the function to be called when the SPI interrupt occurs.\n\n @return int32_t, -1:indicates failure,others indicates success."]
    pub fn SPISlaveRecvData(spiNum: SpiNum) -> i32;
    #[doc = " @brief Set slave status by master.\n\n @param [in] spiNum\n             Indicates which submode to be used, SPI or HSPI.\n @param [in] data\n             Data will be write to slave SPI_WR_STATUS.\n\n @return void.\n\n @attention Just for ESP8266(slave) register of RD_STATUS or WR_STATUS."]
    pub fn SPIMasterSendStatus(spiNum: SpiNum, data: u8);
    #[doc = " @brief Get salve status by master.\n\n @param [in] spiNum\n             Indicates which submode to be used, SPI or HSPI.\n\n @return int32_t, -1: indicates failure; other value in slave status.\n\n @attention Just for ESP8266(slave) register of RD_STATUS or WR_STATUS."]
    pub fn SPIMasterRecvStatus(spiNum: SpiNum) -> i32;
    #[doc = " @brief Select SPI CS pin.\n\n @param [in] spiNum\n             Indicates which submode to be used, SPI or HSPI.\n @param [in] pinCs\n             Indicates which SPI pin to choose.\n\n @return void."]
    pub fn SPICsPinSelect(spiNum: SpiNum, pinCs: SpiPinCS);
    #[doc = " @brief Set SPI module interrupt source and callback function.\n\n @param [in] spiNum\n             Indicates which submode to be used, SPI or HSPI.\n @param [in] pIntInfo\n             Pointer to a struct SpiIntInfo that indicates SPI interrupt information.\n\n @return void."]
    pub fn SPIIntCfg(spiNum: SpiNum, pIntInfo: *mut SpiIntInfo);
    #[doc = " @brief Enable SPI module interrupt source.\n\n @param [in] spiNum\n             Indicates which submode to be used, SPI or HSPI.\n @param [in] intSrc\n             Indicates which interrupt source to enable.\n\n @return void."]
    pub fn SPIIntEnable(spiNum: SpiNum, intSrc: SpiIntSrc);
    #[doc = " @brief Disable SPI module interrupt source.\n\n @param [in] spiNum\n             Indicates which submode to be used, SPI or HSPI.\n @param [in] intSrc\n             Indicates which interrupt source to disable.\n\n @return void."]
    pub fn SPIIntDisable(spiNum: SpiNum, intSrc: SpiIntSrc);
    #[doc = " @brief Clear all of spi interrupt.\n\n @param [in] spiNum\n             Indicates which submode to be used, SPI or HSPI.\n\n @return void."]
    pub fn SPIIntClear(spiNum: SpiNum);
    pub fn i2c_master_gpio_init();
    pub fn i2c_master_init();
    pub fn i2c_master_stop();
    pub fn i2c_master_start();
    pub fn i2c_master_setAck(level: u8);
    pub fn i2c_master_getAck() -> u8;
    pub fn i2c_master_readByte() -> u8;
    pub fn i2c_master_writeByte(wrdata: u8);
    pub fn i2c_master_checkAck() -> bool_;
    pub fn i2c_master_send_ack();
    pub fn i2c_master_send_nack();
    pub fn uart_init(uart0_br: UartBautRate, uart1_br: UartBautRate);
    pub fn uart0_sendStr(str_: *const ::core::ffi::c_char);
    pub fn uart_tx_one_char(uart: u8, TxChar: u8) -> STATUS;
    pub fn uart_tx_one_char_no_wait(uart: u8, TxChar: u8) -> STATUS;
    pub fn uart1_sendStr_no_wait(str_: *const ::core::ffi::c_char);
    pub fn Uart_Buf_Init() -> *mut UartBuffer;
    pub fn uart_rx_intr_enable(uart_no: u8);
    pub fn uart_rx_intr_disable(uart_no: u8);
    pub fn uart0_tx_buffer(buf: *mut u8, len: u16);
    pub fn UART_SetWordLength(uart_no: u8, len: UartBitsNum4Char);
    pub fn UART_SetStopBits(uart_no: u8, bit_num: UartStopBitsNum);
    pub fn UART_SetLineInverse(uart_no: u8, inverse_mask: UART_LineLevelInverse);
    pub fn UART_SetParity(uart_no: u8, Parity_mode: UartParityMode);
    pub fn UART_SetBaudrate(uart_no: u8, baud_rate: u32);
    pub fn UART_SetFlowCtrl(uart_no: u8, flow_ctrl: UART_HwFlowCtrl, rx_thresh: u8);
    pub fn UART_WaitTxFifoEmpty(uart_no: u8, time_out_us: u32);
    pub fn UART_ResetFifo(uart_no: u8);
    pub fn UART_ClearIntrStatus(uart_no: u8, clr_mask: u32);
    pub fn UART_SetIntrEna(uart_no: u8, ena_mask: u32);
    pub fn UART_SetPrintPort(uart_no: u8);
    pub fn UART_CheckOutputFinished(uart_no: u8, time_out_us: u32) -> bool_;
    pub fn memcpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn memmove(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn memccpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn memset(
        __s: *mut ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn memcmp(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
    pub fn __memcmpeq(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: usize,
    ) -> ::core::ffi::c_int;
    pub fn memchr(
        __s: *const ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn strcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
    pub fn strcat(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strncat(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
    pub fn strcmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn strncmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
    pub fn strcoll(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn strxfrm(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
    pub fn strcoll_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __l: locale_t,
    ) -> ::core::ffi::c_int;
    pub fn strxfrm_l(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
    pub fn strdup(__s: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn strndup(
        __string: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
    pub fn strchr(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn strrchr(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn strchrnul(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn strcspn(
        __s: *const ::core::ffi::c_char,
        __reject: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_ulong;
    pub fn strspn(
        __s: *const ::core::ffi::c_char,
        __accept: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_ulong;
    pub fn strpbrk(
        __s: *const ::core::ffi::c_char,
        __accept: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strstr(
        __haystack: *const ::core::ffi::c_char,
        __needle: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strtok(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn __strtok_r(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
        __save_ptr: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strtok_r(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
        __save_ptr: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strcasestr(
        __haystack: *const ::core::ffi::c_char,
        __needle: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn memmem(
        __haystack: *const ::core::ffi::c_void,
        __haystacklen: usize,
        __needle: *const ::core::ffi::c_void,
        __needlelen: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn __mempcpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn mempcpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
    pub fn strlen(__s: *const ::core::ffi::c_char) -> ::core::ffi::c_ulong;
    pub fn strnlen(__string: *const ::core::ffi::c_char, __maxlen: usize) -> usize;
    pub fn strerror(__errnum: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_char,
        __buflen: usize,
    ) -> ::core::ffi::c_int;
    pub fn strerror_l(__errnum: ::core::ffi::c_int, __l: locale_t) -> *mut ::core::ffi::c_char;
    pub fn bcmp(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
    pub fn bcopy(
        __src: *const ::core::ffi::c_void,
        __dest: *mut ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    );
    pub fn bzero(__s: *mut ::core::ffi::c_void, __n: ::core::ffi::c_ulong);
    pub fn index(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn rindex(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn ffs(__i: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn ffsl(__l: ::core::ffi::c_long) -> ::core::ffi::c_int;
    pub fn ffsll(__ll: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
    pub fn strcasecmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn strncasecmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
    pub fn strcasecmp_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __loc: locale_t,
    ) -> ::core::ffi::c_int;
    pub fn strncasecmp_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::core::ffi::c_int;
    pub fn explicit_bzero(__s: *mut ::core::ffi::c_void, __n: usize);
    pub fn strsep(
        __stringp: *mut *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strsignal(__sig: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
    pub fn __stpcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn stpcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn __stpncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: usize,
    ) -> *mut ::core::ffi::c_char;
    pub fn stpncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
    pub fn strlcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
    pub fn strlcat(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
    pub fn ets_bzero(s: *mut ::core::ffi::c_void, n: usize);
    pub fn ets_delay_us(us: u32);
    pub fn ets_install_putc1(
        p: ::core::option::Option<unsafe extern "C" fn(c: ::core::ffi::c_char)>,
    );
    pub fn ets_memcmp(
        str1: *const ::core::ffi::c_void,
        str2: *const ::core::ffi::c_void,
        nbyte: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
    pub fn ets_memcpy(
        dest: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        nbyte: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub fn ets_memmove(
        dest: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        nbyte: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub fn ets_memset(
        dest: *mut ::core::ffi::c_void,
        val: ::core::ffi::c_int,
        nbyte: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
    pub fn ets_strcmp(
        s1: *const ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn ets_strcpy(
        s1: *mut ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn ets_strlen(s: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn ets_strncmp(
        s1: *const ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
        n: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
    pub fn ets_strncpy(
        s1: *mut ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
        n: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_char;
    pub fn ets_strstr(
        s1: *const ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn ets_timer_arm_new(ptimer: *mut ETSTimer, time: u32, repeat_flag: bool_, ms_flag: bool_);
    pub fn ets_timer_disarm(ptimer: *mut ETSTimer);
    pub fn ets_timer_setfn(
        ptimer: *mut ETSTimer,
        pfunction: ETSTimerFunc,
        parg: *mut ::core::ffi::c_void,
    );
    pub fn ets_sprintf(
        str_: *mut ::core::ffi::c_char,
        format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn os_printf_plus(format: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn ets_snprintf(
        str_: *mut ::core::ffi::c_char,
        size: ::core::ffi::c_uint,
        format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn os_random() -> ::core::ffi::c_ulong;
    pub fn os_get_random(buf: *mut ::core::ffi::c_uchar, len: usize) -> ::core::ffi::c_int;
    pub fn spi_flash_get_id() -> uint32;
    pub fn spi_flash_erase_sector(sec: uint16) -> SpiFlashOpResult;
    pub fn spi_flash_write(
        des_addr: uint32,
        src_addr: *mut uint32,
        size: uint32,
    ) -> SpiFlashOpResult;
    pub fn spi_flash_read(
        src_addr: uint32,
        des_addr: *mut uint32,
        size: uint32,
    ) -> SpiFlashOpResult;
    pub fn spi_flash_set_read_func(read: user_spi_flash_read);
    pub fn spi_flash_erase_protect_enable() -> bool_;
    pub fn spi_flash_erase_protect_disable() -> bool_;
    pub fn cache_flush();
    pub fn spi_master_init(spi_no: u8);
    pub fn spi_lcd_9bit_write(spi_no: u8, high_bit: u8, low_8bit: u8);
    pub fn spi_mast_byte_write(spi_no: u8, data: u8);
    pub fn spi_byte_write_espslave(spi_no: u8, data: u8);
    pub fn spi_byte_read_espslave(spi_no: u8, data: *mut u8);
    pub fn spi_slave_init(spi_no: u8, data_len: u8);
    pub fn spi_slave_isr_handler(para: *mut ::core::ffi::c_void);
    pub fn hspi_master_readwrite_repeat();
    pub fn spi_test_init();
    pub fn hspi_overlap_init();
    pub fn hspi_overlap_deinit();
    pub fn spi_reg_recover(spi_no: u8, backup_mem: *mut u32);
    pub fn spi_reg_backup(spi_no: u8, backup_mem: *mut u32);
    pub fn hspi_master_dev_init(dev_no: u8, clk_polar: u8, clk_div: u8);
    pub fn hspi_dev_sel(dev_no: u8);
    pub fn hspi_overlap_flash_init();
    pub fn hspi_overlap_read_flash_data(
        spi: *mut SpiFlashChip,
        flash_addr: u32,
        addr_dest: *mut u32,
        byte_length: u32,
    ) -> SpiFlashOpResult;
    pub fn hw_timer_init(source_type: frc1_timer_source_type, req: u8);
    pub fn hw_timer_set_func(user_hw_timer_cb_set: ::core::option::Option<unsafe extern "C" fn()>);
    pub fn hw_timer_arm(val: u32);
    pub fn ipaddr_addr(cp: *const ::core::ffi::c_char) -> uint32;
    pub fn system_get_rst_info() -> *mut rst_info;
    pub fn system_restore();
    pub fn system_restart();
    pub fn system_deep_sleep_set_option(option: uint8) -> bool_;
    pub fn system_deep_sleep(time_in_us: uint64) -> bool_;
    pub fn system_deep_sleep_instant(time_in_us: uint64) -> bool_;
    pub fn system_upgrade_userbin_check() -> uint8;
    pub fn system_upgrade_reboot();
    pub fn system_upgrade_flag_check() -> uint8;
    pub fn system_upgrade_flag_set(flag: uint8);
    pub fn system_timer_reinit();
    pub fn system_get_time() -> uint32;
    pub fn system_os_task(task: ETSTask, prio: uint8, queue: *mut ETSEvent, qlen: uint8) -> bool_;
    pub fn system_os_post(prio: uint8, sig: ETSSignal, par: ETSParam) -> bool_;
    pub fn system_print_meminfo();
    pub fn system_get_free_heap_size() -> uint32;
    pub fn system_set_os_print(onoff: uint8);
    pub fn system_get_os_print() -> uint8;
    pub fn system_mktime(
        year: uint32,
        mon: uint32,
        day: uint32,
        hour: uint32,
        min: uint32,
        sec: uint32,
    ) -> uint64;
    pub fn system_get_chip_id() -> uint32;
    pub fn system_init_done_cb(cb: init_done_cb_t);
    pub fn system_rtc_clock_cali_proc() -> uint32;
    pub fn system_get_rtc_time() -> uint32;
    pub fn system_rtc_mem_read(
        src_addr: uint8,
        des_addr: *mut ::core::ffi::c_void,
        load_size: uint16,
    ) -> bool_;
    pub fn system_rtc_mem_write(
        des_addr: uint8,
        src_addr: *const ::core::ffi::c_void,
        save_size: uint16,
    ) -> bool_;
    pub fn system_uart_swap();
    pub fn system_uart_de_swap();
    pub fn system_adc_read() -> uint16;
    pub fn system_adc_read_fast(adc_addr: *mut uint16, adc_num: uint16, adc_clk_div: uint8);
    pub fn system_get_vdd33() -> uint16;
    pub fn system_get_sdk_version() -> *const ::core::ffi::c_char;
    pub fn system_get_boot_version() -> uint8;
    pub fn system_get_userbin_addr() -> uint32;
    pub fn system_get_boot_mode() -> uint8;
    pub fn system_restart_enhance(bin_type: uint8, bin_addr: uint32) -> bool_;
    pub fn system_update_cpu_freq(freq: uint8) -> bool_;
    pub fn system_get_cpu_freq() -> uint8;
    pub fn system_get_flash_size_map() -> flash_size_map;
    pub fn system_phy_set_max_tpw(max_tpw: uint8);
    pub fn system_phy_set_tpw_via_vdd33(vdd33: uint16);
    pub fn system_phy_set_rfoption(option: uint8);
    pub fn system_phy_set_powerup_option(option: uint8);
    pub fn system_param_save_with_protect(
        start_sec: uint16,
        param: *mut ::core::ffi::c_void,
        len: uint16,
    ) -> bool_;
    pub fn system_param_load(
        start_sec: uint16,
        offset: uint16,
        param: *mut ::core::ffi::c_void,
        len: uint16,
    ) -> bool_;
    pub fn system_soft_wdt_stop();
    pub fn system_soft_wdt_restart();
    pub fn system_soft_wdt_feed();
    pub fn system_show_malloc();
    pub fn wifi_get_opmode() -> uint8;
    pub fn wifi_get_opmode_default() -> uint8;
    pub fn wifi_set_opmode(opmode: uint8) -> bool_;
    pub fn wifi_set_opmode_current(opmode: uint8) -> bool_;
    pub fn wifi_get_broadcast_if() -> uint8;
    pub fn wifi_set_broadcast_if(interface: uint8) -> bool_;
    pub fn wifi_station_get_config(config: *mut station_config) -> bool_;
    pub fn wifi_station_get_config_default(config: *mut station_config) -> bool_;
    pub fn wifi_station_set_config(config: *mut station_config) -> bool_;
    pub fn wifi_station_set_config_current(config: *mut station_config) -> bool_;
    pub fn wifi_station_connect() -> bool_;
    pub fn wifi_station_disconnect() -> bool_;
    pub fn wifi_enable_signaling_measurement();
    pub fn wifi_disable_signaling_measurement();
    pub fn wifi_station_get_rssi() -> sint8;
    pub fn wifi_station_scan(config: *mut scan_config, cb: scan_done_cb_t) -> bool_;
    pub fn wifi_station_get_auto_connect() -> uint8;
    pub fn wifi_station_set_auto_connect(set: uint8) -> bool_;
    pub fn wifi_station_set_reconnect_policy(set: bool_) -> bool_;
    pub fn wifi_station_get_connect_status() -> uint8;
    pub fn wifi_station_get_current_ap_id() -> uint8;
    pub fn wifi_station_ap_change(current_ap_id: uint8) -> bool_;
    pub fn wifi_station_ap_number_set(ap_number: uint8) -> bool_;
    pub fn wifi_station_get_ap_info(config: *mut station_config) -> uint8;
    pub fn wifi_station_dhcpc_start() -> bool_;
    pub fn wifi_station_dhcpc_stop() -> bool_;
    pub fn wifi_station_dhcpc_status() -> dhcp_status;
    pub fn wifi_station_dhcpc_set_maxtry(num: uint8) -> bool_;
    pub fn wifi_station_get_hostname() -> *mut ::core::ffi::c_char;
    pub fn wifi_station_set_hostname(name: *mut ::core::ffi::c_char) -> bool_;
    pub fn wifi_station_set_cert_key(
        client_cert: *mut uint8,
        client_cert_len: ::core::ffi::c_int,
        private_key: *mut uint8,
        private_key_len: ::core::ffi::c_int,
        private_key_passwd: *mut uint8,
        private_key_passwd_len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn wifi_station_clear_cert_key();
    pub fn wifi_station_set_username(
        username: *mut uint8,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn wifi_station_clear_username();
    pub fn wifi_softap_get_config(config: *mut softap_config) -> bool_;
    pub fn wifi_softap_get_config_default(config: *mut softap_config) -> bool_;
    pub fn wifi_softap_set_config(config: *mut softap_config) -> bool_;
    pub fn wifi_softap_set_config_current(config: *mut softap_config) -> bool_;
    pub fn wifi_softap_get_station_num() -> uint8;
    pub fn wifi_softap_get_station_info() -> *mut station_info;
    pub fn wifi_softap_free_station_info();
    pub fn wifi_softap_dhcps_start() -> bool_;
    pub fn wifi_softap_dhcps_stop() -> bool_;
    pub fn wifi_softap_set_dhcps_lease(please: *mut dhcps_lease) -> bool_;
    pub fn wifi_softap_get_dhcps_lease(please: *mut dhcps_lease) -> bool_;
    pub fn wifi_softap_get_dhcps_lease_time() -> uint32;
    pub fn wifi_softap_set_dhcps_lease_time(minute: uint32) -> bool_;
    pub fn wifi_softap_reset_dhcps_lease_time() -> bool_;
    pub fn wifi_softap_dhcps_status() -> dhcp_status;
    pub fn wifi_softap_set_dhcps_offer_option(
        level: uint8,
        optarg: *mut ::core::ffi::c_void,
    ) -> bool_;
    pub fn wifi_get_ip_info(if_index: uint8, info: *mut ip_info) -> bool_;
    pub fn wifi_set_ip_info(if_index: uint8, info: *mut ip_info) -> bool_;
    pub fn wifi_get_macaddr(if_index: uint8, macaddr: *mut uint8) -> bool_;
    pub fn wifi_set_macaddr(if_index: uint8, macaddr: *mut uint8) -> bool_;
    pub fn wifi_get_channel() -> uint8;
    pub fn wifi_set_channel(channel: uint8) -> bool_;
    pub fn wifi_status_led_install(gpio_id: uint8, gpio_name: uint32, gpio_func: uint8);
    pub fn wifi_status_led_uninstall();
    pub fn wifi_promiscuous_enable(promiscuous: uint8);
    pub fn wifi_set_promiscuous_rx_cb(cb: wifi_promiscuous_cb_t);
    pub fn wifi_promiscuous_set_mac(address: *const u8);
    pub fn wifi_get_phy_mode() -> phy_mode;
    pub fn wifi_set_phy_mode(mode: phy_mode) -> bool_;
    pub fn wifi_set_sleep_type(type_: sleep_type) -> bool_;
    pub fn wifi_get_sleep_type() -> sleep_type;
    pub fn wifi_set_sleep_level(level: sleep_level) -> bool_;
    pub fn wifi_get_sleep_level() -> sleep_level;
    pub fn wifi_set_listen_interval(interval: uint8) -> bool_;
    pub fn wifi_get_listen_interval() -> uint8;
    pub fn wifi_fpm_open();
    pub fn wifi_fpm_close();
    pub fn wifi_fpm_do_wakeup();
    pub fn wifi_fpm_do_sleep(sleep_time_in_us: uint32) -> sint8;
    pub fn wifi_fpm_set_sleep_type(type_: sleep_type);
    pub fn wifi_fpm_get_sleep_type() -> sleep_type;
    pub fn wifi_fpm_set_wakeup_cb(cb: fpm_wakeup_cb);
    pub fn wifi_fpm_auto_sleep_set_in_null_mode(req: uint8);
    pub fn wifi_set_event_handler_cb(cb: wifi_event_handler_cb_t);
    pub fn wifi_wps_enable(wps_type: WPS_TYPE_t) -> bool_;
    pub fn wifi_wps_disable() -> bool_;
    pub fn wifi_wps_start() -> bool_;
    pub fn wifi_set_wps_cb(cb: wps_st_cb_t) -> bool_;
    pub fn wifi_register_send_pkt_freedom_cb(cb: freedom_outside_cb_t) -> ::core::ffi::c_int;
    pub fn wifi_unregister_send_pkt_freedom_cb();
    pub fn wifi_send_pkt_freedom(
        buf: *mut uint8,
        len: ::core::ffi::c_int,
        sys_seq: bool_,
    ) -> ::core::ffi::c_int;
    pub fn wifi_rfid_locp_recv_open() -> ::core::ffi::c_int;
    pub fn wifi_rfid_locp_recv_close();
    pub fn wifi_register_rfid_locp_recv_cb(cb: rfid_locp_cb_t) -> ::core::ffi::c_int;
    pub fn wifi_unregister_rfid_locp_recv_cb();
    pub fn wifi_set_user_fixed_rate(enable_mask: uint8, rate: uint8) -> ::core::ffi::c_int;
    pub fn wifi_get_user_fixed_rate(
        enable_mask: *mut uint8,
        rate: *mut uint8,
    ) -> ::core::ffi::c_int;
    pub fn wifi_set_user_sup_rate(min: uint8, max: uint8) -> ::core::ffi::c_int;
    pub fn wifi_set_user_rate_limit(mode: uint8, ifidx: uint8, max: uint8, min: uint8) -> bool_;
    pub fn wifi_get_user_limit_rate_mask() -> uint8;
    pub fn wifi_set_user_limit_rate_mask(enable_mask: uint8) -> bool_;
    pub fn wifi_set_user_ie(
        enable: bool_,
        m_oui: *mut uint8,
        type_: uint8,
        user_ie: *mut uint8,
        len: uint8,
    ) -> bool_;
    pub fn wifi_register_user_ie_manufacturer_recv_cb(
        cb: user_ie_manufacturer_recv_cb_t,
    ) -> ::core::ffi::c_int;
    pub fn wifi_unregister_user_ie_manufacturer_recv_cb();
    pub fn wifi_enable_gpio_wakeup(i: uint32, intr_status: GPIO_INT_TYPE);
    pub fn wifi_disable_gpio_wakeup();
    pub fn uart_div_modify(uart_no: uint8, DivLatchValue: uint32);
    #[doc = " @brief     configure country info\n\n @attention 1. The default country is {.cc=\"CN\", .schan=1, .nchan=13, policy=WIFI_COUNTRY_POLICY_AUTO}\n @attention 2. When the country policy is WIFI_COUNTRY_POLICY_AUTO, use the country info of AP to which the station is\n               connected. E.g. if the configured country info is {.cc=\"USA\", .schan=1, .nchan=11}, the country info of\n               the AP to which the station is connected is {.cc=\"JP\", .schan=1, .nchan=14}, then our country info is\n               {.cc=\"JP\", .schan=1, .nchan=14}. If the station disconnected from the AP, the country info back to\n               {.cc=\"USA\", .schan=1, .nchan=11} again.\n @attention 3. When the country policy is WIFI_COUNTRY_POLICY_MANUAL, always use the configured country info.\n @attention 4. When the country info is changed because of configuration or because the station connects to a different\n               external AP, the country IE in probe response/beacon of the soft-AP is changed also.\n @attention 5. The country configuration is not stored into flash\n\n @param     wifi_country_t *country: the configured country info\n\n @return  true : succeed\n @return false : fail"]
    pub fn wifi_set_country(country: *mut wifi_country_t) -> bool_;
    #[doc = " @brief     get the current country info\n\n @param     wifi_country_t *country: country info\n\n @return  true : succeed\n @return false : fail"]
    pub fn wifi_get_country(country: *mut wifi_country_t) -> bool_;
    #[doc = " @brief     regist partition table information, user MUST call it in user_pre_init()\n\n @param     partition_table: the partition table\n @param     partition_num:   the partition number in partition table\n @param     map:             the flash map\n\n @return  true : succeed\n @return false : fail"]
    pub fn system_partition_table_regist(
        partition_table: *const partition_item_t,
        partition_num: u32,
        map: u32,
    ) -> bool_;
    #[doc = " @brief     get ota partition size\n\n @return    the size of ota partition"]
    pub fn system_partition_get_ota_partition_size() -> u32;
    #[doc = " @brief     get partition information\n\n @param     type:             the partition type\n @param     partition_item:   the point to store partition information\n\n @return  true : succeed\n @return false : fail"]
    pub fn system_partition_get_item(
        type_: partition_type_t,
        partition_item: *mut partition_item_t,
    ) -> bool_;
    pub fn sdio_slave_init();
    pub fn sdio_load_data(data: *const u8, len: u32) -> i32;
    pub fn sdio_register_recv_cb(cb: sdio_recv_data_callback_t) -> bool_;
}
